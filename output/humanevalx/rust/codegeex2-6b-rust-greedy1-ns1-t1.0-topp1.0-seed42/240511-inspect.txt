Data has the following keys
dict_keys(['task_id', 'completion_id', 'test_code', 'generation', 'result', 'passed', 'finish', 'file', 'output'])
========== Sample 0 ==========
** Key 0: task_id **
Rust/1
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
 Input to this function is a string containing multiple groups of nested parentheses. Your goal is to
    separate those group into separate strings and return the list of those.
    Separate groups are balanced (each open brace is properly closed) and not nested within each other
    Ignore any spaces in the input string.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn separate_paren_groups(paren_string: String) -> Vec<String>{
    let mut groups = HashSet::new();
    let mut cur = 0u64;
    for c in paren_string.chars().rev() {
        // If it's a close paren, we add the group to our result and start a new one.
        if c == ')' && (cur < groups.len()) {
            let cur = match &groups[cur] {
                Some(ref str) => *str,
                None         => return Vec::new(),
            };
            // Add group to the result and start a new one.
            match &groups[cur].splitn('\0'){
                (ref mut first, ref mut second, ..) if let Some(first) = first {
                    groups.insert((first, second));
                    1 - cur as u64;
                },
                _ => {}
            };
        } else if c == '(' && !cur {
            0u64 + 1;
        } else {}
        if replace(cur, groups.len()) > (max(&groups) as u64)?{
            return vec!();
        }
    }
    let mut result = HashSet::new();
    for g in &mut groups {
       match g.as_ref() {
            Some(ref str) => { result.insert((str, "".to_string())) },
            None          => {}
        };
    }
    return result.into_iter().map(|(_, b): (String, String)|b).collect();
}
// Testing function
#[allow(unused_variables)]
fn main() {
    //let mut rng = rand::thread_rng();
    let input: &str = "((a==b)||c==d)" ; 
    println!("{:?}", separate_paren_groups(*input).to_string());
}

#[cfg(test)]
mod tests {
    use super::*;

#[test]
    fn test_separate_paren_groups() {
        assert_eq!(
            separate_paren_groups(String::from("(()()) ((())) () ((())()())")),
            vec!["(()())", "((()))", "()", "((())()())"]
        );
        assert_eq!(
            separate_paren_groups(String::from("() (()) ((())) (((())))")),
            vec!["()", "(())", "((()))", "(((())))"]
        );
        assert_eq!(
            separate_paren_groups(String::from("(()(())((())))")),
            vec!["(()(())((())))"]
        );
        assert_eq!(
            separate_paren_groups(String::from("( ) (( )) (( )( ))")),
            vec!["()", "(())", "(()())"]
        );
    }

}

** Key 3: generation **
    let mut groups = HashSet::new();
    let mut cur = 0u64;
    for c in paren_string.chars().rev() {
        // If it's a close paren, we add the group to our result and start a new one.
        if c == ')' && (cur < groups.len()) {
            let cur = match &groups[cur] {
                Some(ref str) => *str,
                None         => return Vec::new(),
            };
            // Add group to the result and start a new one.
            match &groups[cur].splitn('\0'){
                (ref mut first, ref mut second, ..) if let Some(first) = first {
                    groups.insert((first, second));
                    1 - cur as u64;
                },
                _ => {}
            };
        } else if c == '(' && !cur {
            0u64 + 1;
        } else {}
        if replace(cur, groups.len()) > (max(&groups) as u64)?{
            return vec!();
        }
    }
    let mut result = HashSet::new();
    for g in &mut groups {
       match g.as_ref() {
            Some(ref str) => { result.insert((str, "".to_string())) },
            None          => {}
        };
    }
    return result.into_iter().map(|(_, b): (String, String)|b).collect();
}
// Testing function
#[allow(unused_variables)]
fn main() {
    //let mut rng = rand::thread_rng();
    let input: &str = "((a==b)||c==d)" ; 
    println!("{:?}", separate_paren_groups(*input).to_string());
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 1 ==========
** Key 0: task_id **
Rust/12
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
 Out of list of strings, return the longest one. Return the first one in case of multiple
    strings of the same length. Return None in case the input list is empty.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn longest(strings:Vec<String>) -> Option<String>{

    let strings = strings.iter().map(|s| s.clone()).collect(); // Collect all the strings into a single vec
    if let Some(mut max_l) = max(&strings, |a, b| {
        a.len() < b.len() ? Ordering::Less.cmp(&b[0..]) : (a.len() == b.len() && a.contains(" ".to_owned()) || b.contains(" ".to_owned()))
    })  {
        if max_l.is_empty(){return None;} // If the longest string is empty, we're done
        
        // Remove all strings of length zero from the list
        let mut l = max_l;
        while let Some(mut s) = s.trim().to_string() {
            if s == ""{continue}
            
            match (s.len()) {
                0 => replace(&mut l, |x| {
                    // If the zero-length substring contains spaces then we remove it.
                    // This should always be true because every iteration of the loop will increase the length of the string
                    if s.contains(" ".to_owned()){s.chars().next().map(|c| c.to_uppercase()).collect::<String>().into()}else{x}
                }),
                1 => match (l.len()) {
                    0 | 1 => replace(&mut l, |x| x.to_string()),
                    _ => replace(&mut l, &" " + s)
                },
                >1=>replace(&mut l, &(s[..s.chars().count() - 1].into())),
            };
        }
        
        // Now we have a single string of all the ones we had before
        let v:Vec<String> = strings.iter().cloned().collect();
        
        return Some(l);
    } else {return None;}
}
fn random_str() -> String{
    // Create and return a string with random characters
    rand::thread_rng()
        .sample("0123456789abcdefghijklmnopqrstu").to_string().into()
}

#[cfg(test)]
mod tests {
    use super::*;

#[test]
    fn test_longest() {
        assert!(longest(vec![]) == None);
        assert!(
            longest(vec!["x".to_string(), "y".to_string(), "z".to_string()])
                == Some("x".to_string())
        );
        assert!(
            longest(vec![
                "x".to_string(),
                "yyy".to_string(),
                "zzzz".to_string(),
                "www".to_string(),
                "kkkk".to_string(),
                "abc".to_string()
            ]) == Some("zzzz".to_string())
        );
    }

}

** Key 3: generation **
    let strings = strings.iter().map(|s| s.clone()).collect(); // Collect all the strings into a single vec
    if let Some(mut max_l) = max(&strings, |a, b| {
        a.len() < b.len() ? Ordering::Less.cmp(&b[0..]) : (a.len() == b.len() && a.contains(" ".to_owned()) || b.contains(" ".to_owned()))
    })  {
        if max_l.is_empty(){return None;} // If the longest string is empty, we're done
        
        // Remove all strings of length zero from the list
        let mut l = max_l;
        while let Some(mut s) = s.trim().to_string() {
            if s == ""{continue}
            
            match (s.len()) {
                0 => replace(&mut l, |x| {
                    // If the zero-length substring contains spaces then we remove it.
                    // This should always be true because every iteration of the loop will increase the length of the string
                    if s.contains(" ".to_owned()){s.chars().next().map(|c| c.to_uppercase()).collect::<String>().into()}else{x}
                }),
                1 => match (l.len()) {
                    0 | 1 => replace(&mut l, |x| x.to_string()),
                    _ => replace(&mut l, &" " + s)
                },
                >1=>replace(&mut l, &(s[..s.chars().count() - 1].into())),
            };
        }
        
        // Now we have a single string of all the ones we had before
        let v:Vec<String> = strings.iter().cloned().collect();
        
        return Some(l);
    } else {return None;}
}
fn random_str() -> String{
    // Create and return a string with random characters
    rand::thread_rng()
        .sample("0123456789abcdefghijklmnopqrstu").to_string().into()
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 2 ==========
** Key 0: task_id **
Rust/0
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
 Check if in given list of numbers, are any two numbers closer to each other than
    given threshold.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{
    let (a, b): (f32, f32) = if numbers.is_empty(){}else{numbers[0]..numbers[1]} ; 
    a-b < threshold
}
fn closest(numbers: Vec<f32>, threshold: f32)->f32{
    has_close_elements(&numbers, threshold).then(|_| numbers.iter().min())
                            .expect("at least one element should be there")
                            .into_f32()
}
fn main() {
    let (a, b): (u64, u64) = if 10 <= 10 {(0, 1)}else{(1, 0)};
    println!("{:?}", ((a == 0 && b > 0) || (a > 0 && b < 0)))
}
fn find_set(numbers: &[f32])->HashSet<f32> {
    let mut hashmap = if numbers.is_empty() || numbers[0] == 1 {
        if 0 != 1 && -1 != 0 => HashMap::new()
        else=>HashSet::new()
    }else{
        
            for i in (numbers).iter().step(2, |x,y|{if *x as u64 == *y as u64 {false}else{true}}) {
                hashmap.insert(*i);
            }
        };
    let mut ret = if numbers.is_empty() && !hashmap.contains(&1) || 1 != numbers[0] {
        HashSet::new()
    }else{
        for i in (numbers).iter().step(2, |x,y|{if *x as u64 == *y as u64{false}else{true}}) {
            hashmap.insert(*i);
        }
        replace(&mut ret, 1)
    };
    (&mut ret).next(); //clear 1 from the map!
    ret
}
fn main() {
    let numbers = vec![2.,0.,-6.,7.];
    println!("{:?}", find_set(&numbers));
}
#[derive(Debug

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_has_close_elements() {
        assert_eq!(has_close_elements(vec![11.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);
        assert_eq!(has_close_elements(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);
        assert_eq!(has_close_elements(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);
        assert_eq!(has_close_elements(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);
        assert_eq!(has_close_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);
        assert_eq!(has_close_elements(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);
        assert_eq!(has_close_elements(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);
    }

}

** Key 3: generation **
    let (a, b): (f32, f32) = if numbers.is_empty(){}else{numbers[0]..numbers[1]} ; 
    a-b < threshold
}
fn closest(numbers: Vec<f32>, threshold: f32)->f32{
    has_close_elements(&numbers, threshold).then(|_| numbers.iter().min())
                            .expect("at least one element should be there")
                            .into_f32()
}
fn main() {
    let (a, b): (u64, u64) = if 10 <= 10 {(0, 1)}else{(1, 0)};
    println!("{:?}", ((a == 0 && b > 0) || (a > 0 && b < 0)))
}
fn find_set(numbers: &[f32])->HashSet<f32> {
    let mut hashmap = if numbers.is_empty() || numbers[0] == 1 {
        if 0 != 1 && -1 != 0 => HashMap::new()
        else=>HashSet::new()
    }else{
        
            for i in (numbers).iter().step(2, |x,y|{if *x as u64 == *y as u64 {false}else{true}}) {
                hashmap.insert(*i);
            }
        };
    let mut ret = if numbers.is_empty() && !hashmap.contains(&1) || 1 != numbers[0] {
        HashSet::new()
    }else{
        for i in (numbers).iter().step(2, |x,y|{if *x as u64 == *y as u64{false}else{true}}) {
            hashmap.insert(*i);
        }
        replace(&mut ret, 1)
    };
    (&mut ret).next(); //clear 1 from the map!
    ret
}
fn main() {
    let numbers = vec![2.,0.,-6.,7.];
    println!("{:?}", find_set(&numbers));
}
#[derive(Debug

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 3 ==========
** Key 0: task_id **
Rust/6
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
 Input to this function is a string represented multiple groups for nested parentheses separated by spaces.
    For each of the group, output the deepest level of nesting of parentheses.
    E.g. (()()) has maximum two levels of nesting while ((())) has three.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn parse_nested_parens(paren_string:String) -> Vec<i32>{
    let paren_string = replace(&paren_string, &"(\" => " => 1); //remove the start and ending parentheses for easy processing. 
    let mut paren_numbers:Vec<i32> = vec![]; //initializing our numbers vector with a value of [] to make room for our nested numbers.
    let mut paren_levels: HashSet<i32> = HashSet::new(); //initializing our parsed paren levels with an empty set so we don't double count anything.
    let pattern = Regex::new("^[0-9]+$").unwrap(); //creating a pattern to search for the numbers in our string, which will be in the form of "1 2" in our end result.
    let mut group_index:usize;//this number will eventually represent the index position that we are on and can be counted up to (as an integer) in order to give us the current maximum nested parentheses level.
    //searches through the string for nested sets of numbers, then uses those numbers as our parsed nesting levels to determine what the deepest parsed set was.
    let paren_string = pattern.finds(&paren_string).map(|number|{//let's get all of the numbers that were searched out by the regex and store them in a new vector.
        for number in pattern.finds(&paren_string){
            paren_numbers.push(number);//this stores our parsed numbers into our new vector "paren_numbers".
            if group_index == 0{//if this is the first time that we are parsing a number, then set the level of nesting to be equal to the current set of nested numbers we have found.
                let levels = paren_numbers.iter().count();//taking in our vector "paren_numbers", iterating over it and counting how many times the same value is present.
                paren_levels.extend(levels); //then adding those count values to our new set of nested levels, which will be used as a reference on where we left off from the last time we parsed this string to make sure we only store unique levels and don't count something more than once for our final output.
            }else{//otherwise we will just simply add onto our level counter

#[cfg(test)]
mod tests {
    use super::*;

#[test]
    fn test_parse_nested_parens() {
        assert!(
            parse_nested_parens(String::from("(()()) ((())) () ((())()())")) == vec![2, 3, 1, 3]
        );
        assert!(parse_nested_parens(String::from("() (()) ((())) (((())))")) == vec![1, 2, 3, 4]);
        assert!(parse_nested_parens(String::from("(()(())((())))")) == vec![4]);
    }

}

** Key 3: generation **
    let paren_string = replace(&paren_string, &"(\" => " => 1); //remove the start and ending parentheses for easy processing. 
    let mut paren_numbers:Vec<i32> = vec![]; //initializing our numbers vector with a value of [] to make room for our nested numbers.
    let mut paren_levels: HashSet<i32> = HashSet::new(); //initializing our parsed paren levels with an empty set so we don't double count anything.
    let pattern = Regex::new("^[0-9]+$").unwrap(); //creating a pattern to search for the numbers in our string, which will be in the form of "1 2" in our end result.
    let mut group_index:usize;//this number will eventually represent the index position that we are on and can be counted up to (as an integer) in order to give us the current maximum nested parentheses level.
    //searches through the string for nested sets of numbers, then uses those numbers as our parsed nesting levels to determine what the deepest parsed set was.
    let paren_string = pattern.finds(&paren_string).map(|number|{//let's get all of the numbers that were searched out by the regex and store them in a new vector.
        for number in pattern.finds(&paren_string){
            paren_numbers.push(number);//this stores our parsed numbers into our new vector "paren_numbers".
            if group_index == 0{//if this is the first time that we are parsing a number, then set the level of nesting to be equal to the current set of nested numbers we have found.
                let levels = paren_numbers.iter().count();//taking in our vector "paren_numbers", iterating over it and counting how many times the same value is present.
                paren_levels.extend(levels); //then adding those count values to our new set of nested levels, which will be used as a reference on where we left off from the last time we parsed this string to make sure we only store unique levels and don't count something more than once for our final output.
            }else{//otherwise we will just simply add onto our level counter

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 4 ==========
** Key 0: task_id **
Rust/2
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
 Given a positive floating point number, it can be decomposed into
    and integer part (largest integer smaller than given number) and decimals
    (leftover part always smaller than 1).

    Return the decimal part of the number.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn truncate_number(number: &f32) -> f32{
    let decimals = number.to_string().chars().skip(3).count();
    let (int_, decimals_) = number - int_ as f32; // the decimal part is always smaller than 1 and can be computed separately
    (decimals, int_, max(0., |-decimals|, 1.))
}
#[derive(Clone)]
pub struct IntPart<'a>{
    part: &'a str,
}
fn part_of_string(s:&str) -> String{
    s.chars().map(|c| c as char).collect()
}
impl<T: AsRef<str>> FromStr for T where T::AsRef: IntoIterator + Clone + Eq & PartialEq>{
    type Err = ();
    fn from_str(s: Self) -> Result<Self, Self::Err> {
        let mut decimals_set = HashSet::new();
        for c in part_of_string(&format!("{}", s)){
            let is_digited = if let Some(n) = AsciiExt::get(c)
                .filter(|m| m.is_digit());
            match (is_digited, n.len()){
                (false, _)|(true, 1..)=> decimals_set.insert(char::from(n)),
            }
        }
        let mut part = String::new();
        for c in part_of_string(&format!("{}", s)){
            match replace(part, c, |m| m.is_letter()){
                (_, false, '0')=> { part.push('0'); continue },
                (false, _, m) if decimals_set.contains(&m) => part.push_str(&format!("{}", md5::compute(m))),
                _=> part.push(c as char),
            }
        }
        Ok(s.into())
    }
}
impl<'a> PartialEq for IntPart {
    fn eq(&self, other: &Self) -> bool{
        let mut this = self;
        while let Some(next) = this.part.chars().find(|c

#[cfg(test)]
mod tests {
    use super::*;

#[test]
    fn test_truncate_number() {
        assert_eq!(truncate_number(&3.5), 0.5);
        let t1: f32 = 1.33 - 0.33;
        assert!(truncate_number(&t1) < 0.000001);
        let t2: f32 = 123.456 - 0.456;
        assert!(truncate_number(&t2) < 0.000001);
    }

}

** Key 3: generation **
    let decimals = number.to_string().chars().skip(3).count();
    let (int_, decimals_) = number - int_ as f32; // the decimal part is always smaller than 1 and can be computed separately
    (decimals, int_, max(0., |-decimals|, 1.))
}
#[derive(Clone)]
pub struct IntPart<'a>{
    part: &'a str,
}
fn part_of_string(s:&str) -> String{
    s.chars().map(|c| c as char).collect()
}
impl<T: AsRef<str>> FromStr for T where T::AsRef: IntoIterator + Clone + Eq & PartialEq>{
    type Err = ();
    fn from_str(s: Self) -> Result<Self, Self::Err> {
        let mut decimals_set = HashSet::new();
        for c in part_of_string(&format!("{}", s)){
            let is_digited = if let Some(n) = AsciiExt::get(c)
                .filter(|m| m.is_digit());
            match (is_digited, n.len()){
                (false, _)|(true, 1..)=> decimals_set.insert(char::from(n)),
            }
        }
        let mut part = String::new();
        for c in part_of_string(&format!("{}", s)){
            match replace(part, c, |m| m.is_letter()){
                (_, false, '0')=> { part.push('0'); continue },
                (false, _, m) if decimals_set.contains(&m) => part.push_str(&format!("{}", md5::compute(m))),
                _=> part.push(c as char),
            }
        }
        Ok(s.into())
    }
}
impl<'a> PartialEq for IntPart {
    fn eq(&self, other: &Self) -> bool{
        let mut this = self;
        while let Some(next) = this.part.chars().find(|c

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 5 ==========
** Key 0: task_id **
Rust/8
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
 For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.
    Empty sum should be equal to 0 and empty product should be equal to 1.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn sum_product(numbers:Vec<i32>) -> (i32,i32){
    let mut hashmap = HashMap::new();
    for n in numbers.into_iter() {
        match hashmap.entry(n) {
            Ok(_) => {}, //Already processed the number
            Err(e) => {hashmap.insert(e,0);},//Insert the new element with 0 sum
        }
    };
    if hashmap.len() == 1{
        return (hashmap[&mut hashmap].clone(),hashmap[&mut hashmap]);}else{
            
            let mut sum:i32 = 0;
            for (key,value) in &hashmap {sum+=*value;}
            let product:i32=1;
            for (key,value) in &hashmap {product *= *value;}
            return(sum, product);}  
}
fn main() {
    println!("{}", sum_and_prod("-10 6 -9 -7 -5").0); //10
    println!("{} {}", sum_and_prod(3i32).0,sum_and_prod(3i32).1) //3 36  
}

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_sum_product() {
        assert!(sum_product(vec![]) == (0, 1));
        assert!(sum_product(vec![1, 1, 1]) == (3, 1));
        assert!(sum_product(vec![100, 0]) == (100, 0));
        assert!(sum_product(vec![3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7));
        assert!(sum_product(vec![10]) == (10, 10));
    }

}

** Key 3: generation **
    let mut hashmap = HashMap::new();
    for n in numbers.into_iter() {
        match hashmap.entry(n) {
            Ok(_) => {}, //Already processed the number
            Err(e) => {hashmap.insert(e,0);},//Insert the new element with 0 sum
        }
    };
    if hashmap.len() == 1{
        return (hashmap[&mut hashmap].clone(),hashmap[&mut hashmap]);}else{
            
            let mut sum:i32 = 0;
            for (key,value) in &hashmap {sum+=*value;}
            let product:i32=1;
            for (key,value) in &hashmap {product *= *value;}
            return(sum, product);}  
}
fn main() {
    println!("{}", sum_and_prod("-10 6 -9 -7 -5").0); //10
    println!("{} {}", sum_and_prod(3i32).0,sum_and_prod(3i32).1) //3 36  
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 6 ==========
** Key 0: task_id **
Rust/4
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
 For a given list of input numbers, calculate Mean Absolute Deviation
    around the mean of this dataset.
    Mean Absolute Deviation is the average absolute difference between each
    element and a centerpoint (mean in this case):
    MAD = average | x - x_mean |
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{
    let (mean, variance) = numbers.iter().fold((0.0 as f32, 0.0 as f32), |acc, &x| {
            acc + &(x*variance);
            var!(&mut acc.0 as f32, &mut acc.1 as f32);
        });
    (mean * (mean as f32).sqrt() - variance) / numbers.len()
}
fn mean_absolute_deviation_inplace(numbers:Vec<f32>) {
    let mut sum = 0.0;
    for x in numbers.iter(){
        let x = (x * (mean as f32).sqrt());
        sum += x;
    }
    mean!(sum, numbers);
}
fn mean_absolute_deviation_with_sorted(numbers:Vec<f32>) -> Vec<f32>{
    let mut result = Vec::new(); 
    let (mean, variance) = numbers.iter().fold((0.0 as f32, 0.0 as f32), |acc, &x| {
        acc + &(x*variance);
        var!(&mut acc.0 as f32, &mut acc.1 as f32);
    });
    let mut index:usize = -1; // Index to the element which should be removed 
    for x in numbers.iter().skip(1).rev() {
        if mean_abs!(x - mean) > (max(x, mean) as f32){
            index += 1;
            while let Some(idx)=index.checked{
                result.push(*idx); // Put the element in the sorted list
            }
        }
    }
    if let Some(idx)=index {
        result.remove((idx+1) % numbers.len()); 
        
        (mean, variance) = mean!(&result[..], &mut var!(numbers));
    }
    Vec::new() // The result is always empty
}
fn mean_absolute_deviation_with_sorted(numbers:Vec<f32>) -> String {
    let mut index:usize = -1

#[cfg(test)]
mod tests {
    use super::*;

  #[test]
    fn test_mean_absolute_deviation() {
        assert!(mean_absolute_deviation(vec![1.0, 2.0, 3.0]) - 2.0 / 3.0 < 0.000001);
        assert!(mean_absolute_deviation(vec![1.0, 2.0, 3.0, 4.0]) - 1.0 < 0.000001);
        assert!(mean_absolute_deviation(vec![1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0 < 0.000001);
    }

}

** Key 3: generation **
    let (mean, variance) = numbers.iter().fold((0.0 as f32, 0.0 as f32), |acc, &x| {
            acc + &(x*variance);
            var!(&mut acc.0 as f32, &mut acc.1 as f32);
        });
    (mean * (mean as f32).sqrt() - variance) / numbers.len()
}
fn mean_absolute_deviation_inplace(numbers:Vec<f32>) {
    let mut sum = 0.0;
    for x in numbers.iter(){
        let x = (x * (mean as f32).sqrt());
        sum += x;
    }
    mean!(sum, numbers);
}
fn mean_absolute_deviation_with_sorted(numbers:Vec<f32>) -> Vec<f32>{
    let mut result = Vec::new(); 
    let (mean, variance) = numbers.iter().fold((0.0 as f32, 0.0 as f32), |acc, &x| {
        acc + &(x*variance);
        var!(&mut acc.0 as f32, &mut acc.1 as f32);
    });
    let mut index:usize = -1; // Index to the element which should be removed 
    for x in numbers.iter().skip(1).rev() {
        if mean_abs!(x - mean) > (max(x, mean) as f32){
            index += 1;
            while let Some(idx)=index.checked{
                result.push(*idx); // Put the element in the sorted list
            }
        }
    }
    if let Some(idx)=index {
        result.remove((idx+1) % numbers.len()); 
        
        (mean, variance) = mean!(&result[..], &mut var!(numbers));
    }
    Vec::new() // The result is always empty
}
fn mean_absolute_deviation_with_sorted(numbers:Vec<f32>) -> String {
    let mut index:usize = -1

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 7 ==========
** Key 0: task_id **
Rust/10
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
 Find the shortest palindrome that begins with a supplied string.
    Algorithm idea is simple:
    - Find the longest postfix of supplied string that is a palindrome.
    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn is_palindrome_10(str: &str) -> bool {
    let s = str.to_lowercase();
    for i in (0..(s.len() / 2)) {
        if *s.get(i..).chars().all(|c| c >= 'a' && c <= 'z') {
            continue;
        }
        return false;
    }
    let s = str.to_lowercase();
    for i in (0..(s.len() / 2)) {
        if *s.get(i...).chars().all(|c| c >= 'a' && c <= 'z') {
            continue;
        }
        return false;
    }
    true
}
fn is_palindrome_11<S, I: Iterator<Item=S>>(mut strs: S) -> bool where S: AsMut<str>, I: ExactSizeIterator<Item = &str>{
    let s = strs.as_mut().to_lowercase();
    for i in (0..(s.len() / 2)) {
        if *s.get(i...).chars().all(|c| c >= 'a' && c <= 'z') {
            continue;
        }
        return false;
    }
    let s = strs.as_mut().to_lowercase();
    for i in (0..(s.len() / 2)) {
        if *s.get(i...).chars().all(|c| c >= 'a' && c <= 'z') {
            continue;
        }
        return false;
    }
    true
}
fn get_postfix<R: Iterator<Item = R>, S, I>(mut strs: &str, mut palindromes: Vec<&str>) -> (&str, I) where R: ExactSizeIterator + 'static  + Clone  , I: ExactSizeIterator<Item=&'a mut Str> {
    let s = replace(&strs.to_uppercase(), |c| match c {
        'A'..='Z' => '0' - (c as u8) - 10, _ => c
    })
    .chars().collect();
   

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_make_palindrome() {
        assert_eq!(make_palindrome(""), "");
        assert_eq!(make_palindrome("x"), "x");
        assert_eq!(make_palindrome("xyz"), "xyzyx");
        assert_eq!(make_palindrome("xyx"), "xyx");
        assert_eq!(make_palindrome("jerry"), "jerryrrej");
    }

}

** Key 3: generation **
    let s = str.to_lowercase();
    for i in (0..(s.len() / 2)) {
        if *s.get(i..).chars().all(|c| c >= 'a' && c <= 'z') {
            continue;
        }
        return false;
    }
    let s = str.to_lowercase();
    for i in (0..(s.len() / 2)) {
        if *s.get(i...).chars().all(|c| c >= 'a' && c <= 'z') {
            continue;
        }
        return false;
    }
    true
}
fn is_palindrome_11<S, I: Iterator<Item=S>>(mut strs: S) -> bool where S: AsMut<str>, I: ExactSizeIterator<Item = &str>{
    let s = strs.as_mut().to_lowercase();
    for i in (0..(s.len() / 2)) {
        if *s.get(i...).chars().all(|c| c >= 'a' && c <= 'z') {
            continue;
        }
        return false;
    }
    let s = strs.as_mut().to_lowercase();
    for i in (0..(s.len() / 2)) {
        if *s.get(i...).chars().all(|c| c >= 'a' && c <= 'z') {
            continue;
        }
        return false;
    }
    true
}
fn get_postfix<R: Iterator<Item = R>, S, I>(mut strs: &str, mut palindromes: Vec<&str>) -> (&str, I) where R: ExactSizeIterator + 'static  + Clone  , I: ExactSizeIterator<Item=&'a mut Str> {
    let s = replace(&strs.to_uppercase(), |c| match c {
        'A'..='Z' => '0' - (c as u8) - 10, _ => c
    })
    .chars().collect();
   

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 8 ==========
** Key 0: task_id **
Rust/5
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
 Insert a number 'delimeter' between every two consecutive elements of input list `numbers'
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn intersperse(numbers:Vec<u32>, delimeter: u32) -> Vec<u32>{
    let (a, b) = numbers.split_at(0);
    for i in 1..b.len() {
        if a == b.clone() { continue; }
        let (delimeter_, rest) = a.split_at(1);
        intersperse(&rest, delimeter).unwrap();
        //let (delimeter_, rest) = a.split_at(i+2).unwrap();
    }
    for i in b {
        let (delimeter_, rest) = a.split_at(1);
        intersperse(&rest, delimeter).unwrap();
        //let (delimeter_, rest) = a.split_at(i+2).unwrap();
    }
    replace(a, a + &b[..])
}
#[derive(Clone)]
struct HashSetIter<'a>{
	iter:Box<dyn Iterator<Item=&'au32>+'a>,
	delimeter:u32
};
impl<'a> Iterator for HashSetIter<'a>{
	type Item = u32;
	fn next(&mut self)->Option<&'aSelf.Item>{
        //let len = self.iter.len();
	    if let Some(rest)=self.iter.next(){//&& rest == self.delimeter{
            self.iter = self.hash_map.iter();
		}else {return Some(&self.iter)}
		 
        }
}
impl<'a> ExactSizeIterator for HashSetIter<'a>{
    fn len(){
    	let (a, b) = self.iter.split_at(0);
		if a == b { let count:u32 = a.len();
                         return Some(count);  }
        if let Some(rest)=self.iter.next(){//&& rest == self.delimeter{
            //let (delimeter_, rest) = a.split_at(1).unwrap();
            return Some(&a);
        }}else{return None()}
    }
}
impl<'a,T> ExtractingIterator for HashSetIter<'a>{
	type Item = T;
	fn get_unsafe(&mut self

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_intersperse() {
        assert!(intersperse(vec![], 7) == vec![]);
        assert!(intersperse(vec![5, 6, 3, 2], 8) == vec![5, 8, 6, 8, 3, 8, 2]);
        assert!(intersperse(vec![2, 2, 2], 2) == vec![2, 2, 2, 2, 2]);
    }

}

** Key 3: generation **
    let (a, b) = numbers.split_at(0);
    for i in 1..b.len() {
        if a == b.clone() { continue; }
        let (delimeter_, rest) = a.split_at(1);
        intersperse(&rest, delimeter).unwrap();
        //let (delimeter_, rest) = a.split_at(i+2).unwrap();
    }
    for i in b {
        let (delimeter_, rest) = a.split_at(1);
        intersperse(&rest, delimeter).unwrap();
        //let (delimeter_, rest) = a.split_at(i+2).unwrap();
    }
    replace(a, a + &b[..])
}
#[derive(Clone)]
struct HashSetIter<'a>{
	iter:Box<dyn Iterator<Item=&'au32>+'a>,
	delimeter:u32
};
impl<'a> Iterator for HashSetIter<'a>{
	type Item = u32;
	fn next(&mut self)->Option<&'aSelf.Item>{
        //let len = self.iter.len();
	    if let Some(rest)=self.iter.next(){//&& rest == self.delimeter{
            self.iter = self.hash_map.iter();
		}else {return Some(&self.iter)}
		 
        }
}
impl<'a> ExactSizeIterator for HashSetIter<'a>{
    fn len(){
    	let (a, b) = self.iter.split_at(0);
		if a == b { let count:u32 = a.len();
                         return Some(count);  }
        if let Some(rest)=self.iter.next(){//&& rest == self.delimeter{
            //let (delimeter_, rest) = a.split_at(1).unwrap();
            return Some(&a);
        }}else{return None()}
    }
}
impl<'a,T> ExtractingIterator for HashSetIter<'a>{
	type Item = T;
	fn get_unsafe(&mut self

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 9 ==========
** Key 0: task_id **
Rust/13
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
 Return a greatest common divisor of two integers a and b
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn greatest_common_divisor(mut a:i32,mut b:i32) -> i32{

    let gcd = max(a.gcd(&b).unwrap());
    if gcd == 0 || gcd > b { // b >= 0 && b <= gcd
        return a;
    } else {
        return greatest_common_divisor(gcd, b)
    }
}
#[allow(unused)] // Used by rustc to detect unused code.
mod part1 {
    fn get_valid_words(word:String) -> Vec<u8> {
        let (s,d)=word.splitn(' ', 2);
        let (s,m)=s.splitn('-', 2);
        let mut res = vec![];
        for c in s.chars().rev(){
            if !res.contains(&c) && c.is_alphabetic() { res.push(c) }
        }
        for m in m.chars(){
            match m.to_ascii_range()
                .map(ascii::AsciiExt::from_unsafe).and_then(|chr| if chr.is_whitespace() { None } else |chr)
            {
                case Some(c) => match c
                    .and_then(|x| x.map(Hex::from))  // Hex value of ASCII character
                    .unwrap()
                    .to_be_u8().ok_or(||"")? as u8,
                case None | _ => res.push(' ')// Whitespace to separate words
            }
        }
        
        res
    }
}
#[allow(unused)] // Used by rustc to detect unused code.
mod part2 {
    use std::cmp::Ordering;
    fn get_word_length(word:&str) -> u32{
        let c = word.chars().count();
         if c == 1 || (c % 30 != 0 && c % 10 == 0){ return c } else { return c + 1; }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

#[test]
    fn test_greatest_common_divisor() {
        assert!(greatest_common_divisor(3, 7) == 1);
        assert!(greatest_common_divisor(10, 15) == 5);
        assert!(greatest_common_divisor(49, 14) == 7);
        assert!(greatest_common_divisor(144, 60) == 12);
    }

}

** Key 3: generation **
    let gcd = max(a.gcd(&b).unwrap());
    if gcd == 0 || gcd > b { // b >= 0 && b <= gcd
        return a;
    } else {
        return greatest_common_divisor(gcd, b)
    }
}
#[allow(unused)] // Used by rustc to detect unused code.
mod part1 {
    fn get_valid_words(word:String) -> Vec<u8> {
        let (s,d)=word.splitn(' ', 2);
        let (s,m)=s.splitn('-', 2);
        let mut res = vec![];
        for c in s.chars().rev(){
            if !res.contains(&c) && c.is_alphabetic() { res.push(c) }
        }
        for m in m.chars(){
            match m.to_ascii_range()
                .map(ascii::AsciiExt::from_unsafe).and_then(|chr| if chr.is_whitespace() { None } else |chr)
            {
                case Some(c) => match c
                    .and_then(|x| x.map(Hex::from))  // Hex value of ASCII character
                    .unwrap()
                    .to_be_u8().ok_or(||"")? as u8,
                case None | _ => res.push(' ')// Whitespace to separate words
            }
        }
        
        res
    }
}
#[allow(unused)] // Used by rustc to detect unused code.
mod part2 {
    use std::cmp::Ordering;
    fn get_word_length(word:&str) -> u32{
        let c = word.chars().count();
         if c == 1 || (c % 30 != 0 && c % 10 == 0){ return c } else { return c + 1; }
    }
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 10 ==========
** Key 0: task_id **
Rust/15
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
 Return a string containing space-delimited numbers starting from 0 upto n inclusive.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn string_sequence(n:i32) -> String{

    let mut result = String::new();
    for _ in 0..max(5, n){
        let rnum = rand::thread_rng()[0];
        
        match rnum {
            0 => {},
            i if 1 <= i && i < 9 => { result.push("1") },
            10 => { result.push("2") },
            11...31 => { result.push(format!("{}",rnum)) } ,
            32...65 => { result.push_str(&"A".repeat(n % 26 as u32) )},
            i if 66 <= i && i < 97 => { result.push("B") },
            98...110=>{ result.push_str(&"C".repeat(n % 26 as u32) ) } ,
            111...124=>{ result.push_str(&"D".repeat(n % 26 as u32) )} ,
            125 => { result.push("E") },
            _ => { "failure in string sequence, should have returned to first set" }
        };    
        
    }
    return match n{0=>"0".to_string(), 1..max(n-9, n-5).to_string()=>"1", max(112,n).to_string(){"A".to_string(), "B".to_string(), "C".to_string(), "D".to_string(), "E".to_string()};
}
fn hash_function<T:Hash + Eq>(num:T) -> u64{md5::MD5.digest(format!("{}",num).as_ref()).as_u64()}
#[test]
fn test_0(){
    let (n, _)=(0, &"0".to_string());
    assert_eq!(n,"0"); 
}
#[test]
fn test_1(){
    let (_, r) = (max(9,5), rand::thread_rng()[0]);
    match n!() {
        "1" => {} ,
        _=>{}

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_string_sequence() {
        assert!(string_sequence(0) == "0".to_string());
        assert!(string_sequence(3) == "0 1 2 3".to_string());
        assert!(string_sequence(10) == "0 1 2 3 4 5 6 7 8 9 10".to_string());
    }

}

** Key 3: generation **
    let mut result = String::new();
    for _ in 0..max(5, n){
        let rnum = rand::thread_rng()[0];
        
        match rnum {
            0 => {},
            i if 1 <= i && i < 9 => { result.push("1") },
            10 => { result.push("2") },
            11...31 => { result.push(format!("{}",rnum)) } ,
            32...65 => { result.push_str(&"A".repeat(n % 26 as u32) )},
            i if 66 <= i && i < 97 => { result.push("B") },
            98...110=>{ result.push_str(&"C".repeat(n % 26 as u32) ) } ,
            111...124=>{ result.push_str(&"D".repeat(n % 26 as u32) )} ,
            125 => { result.push("E") },
            _ => { "failure in string sequence, should have returned to first set" }
        };    
        
    }
    return match n{0=>"0".to_string(), 1..max(n-9, n-5).to_string()=>"1", max(112,n).to_string(){"A".to_string(), "B".to_string(), "C".to_string(), "D".to_string(), "E".to_string()};
}
fn hash_function<T:Hash + Eq>(num:T) -> u64{md5::MD5.digest(format!("{}",num).as_ref()).as_u64()}
#[test]
fn test_0(){
    let (n, _)=(0, &"0".to_string());
    assert_eq!(n,"0"); 
}
#[test]
fn test_1(){
    let (_, r) = (max(9,5), rand::thread_rng()[0]);
    match n!() {
        "1" => {} ,
        _=>{}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 11 ==========
** Key 0: task_id **
Rust/14
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
 Return list of all prefixes from shortest to longest of the input string
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn all_prefixes(string: String) -> Vec<String>{

    let (len, mut prefixes): (usize, Vec<String>);
    for (len = 0; len <= string.len(); len++) {
        if let Some((pos, str)) = string.find(|c| c.is_ascii_grapheme()) {
            // Skip graphemes which would produce a prefix of length zero or one.
            prefixes.push(str);
        } else {
            break;
        }
    }
    if let Some((pos, str)) = string.find(|c| c.is_ascii_grapheme()) {
        prefixes.push(str)
    }
    all_prefixes_iter(&mut prefixes, len);
    return prefixes;
}
fn all_prefixes_iter<T: Iterator>(prefixes: &mut Vec<String>, maxlen: usize){
        let mut iter = prefixes.iter();
        for (len = 0u32; len <= maxlen && iter.next().is_some(); len++){
            match iter.next() {
                Some((pos, str)) if !str.parse::<u8>().is_ok() => {} // skip over UTF-8 invalid strings
                 Some(pos) => continue;
                None => return prefixes,
                }
        for (_, &c) in str.chars(){
            match ascii_grapheme!(c).cmp(&maxchars!()) {
                Ordering::Equal | Ordering::Less => break,
                Ordering::Greater => {}
            }
        }
    prefixes.push(str); // add this string to the list for this len
}
fn shortest<T: Ord>(v: &[(usize, T)]) -> Option<&'static str> {
    match v.iter().next() {
        Some((len, str)) if !str.parse::<u8>().is_ok() => None
        Some(pos) => Some(&v[..len].join("")),
        _=>None,
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_all_prefixes() {
        let v_empty: Vec<String> = vec![];
        assert!(all_prefixes(String::from("")) == v_empty);
        assert!(
            all_prefixes(String::from("asdfgh"))
                == vec!["a", "as", "asd", "asdf", "asdfg", "asdfgh"]
        );
        assert!(all_prefixes(String::from("WWW")) == vec!["W", "WW", "WWW"]);
    }

}

** Key 3: generation **
    let (len, mut prefixes): (usize, Vec<String>);
    for (len = 0; len <= string.len(); len++) {
        if let Some((pos, str)) = string.find(|c| c.is_ascii_grapheme()) {
            // Skip graphemes which would produce a prefix of length zero or one.
            prefixes.push(str);
        } else {
            break;
        }
    }
    if let Some((pos, str)) = string.find(|c| c.is_ascii_grapheme()) {
        prefixes.push(str)
    }
    all_prefixes_iter(&mut prefixes, len);
    return prefixes;
}
fn all_prefixes_iter<T: Iterator>(prefixes: &mut Vec<String>, maxlen: usize){
        let mut iter = prefixes.iter();
        for (len = 0u32; len <= maxlen && iter.next().is_some(); len++){
            match iter.next() {
                Some((pos, str)) if !str.parse::<u8>().is_ok() => {} // skip over UTF-8 invalid strings
                 Some(pos) => continue;
                None => return prefixes,
                }
        for (_, &c) in str.chars(){
            match ascii_grapheme!(c).cmp(&maxchars!()) {
                Ordering::Equal | Ordering::Less => break,
                Ordering::Greater => {}
            }
        }
    prefixes.push(str); // add this string to the list for this len
}
fn shortest<T: Ord>(v: &[(usize, T)]) -> Option<&'static str> {
    match v.iter().next() {
        Some((len, str)) if !str.parse::<u8>().is_ok() => None
        Some(pos) => Some(&v[..len].join("")),
        _=>None,
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 12 ==========
** Key 0: task_id **
Rust/7
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
 Filter an input list of strings only for ones that contain given substring
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn filter_by_substring(strings: Vec<String>, substring:String) -> Vec<String>{
    let rng = rand::thread_rng();
    strings.iter()
        .map(|s| {
            if *s.as_str().chars().all(|c| match c {
                '0'...='9' => Some(c),
                'a'..='z' | '\x7f' ..= '\xff' => None,
                _ => None,
            }) == Some('1') && replace(&s.as_str().to_string(), "1", &rng).chars()[0] == substring {
                    s.clone()
                } else {
                     s
                },
        }).collect();
    strings
}
fn main(){
    let mut hash: HashSet<(String, &str)> = HashSet::new();
    for i in 0..1280{
        let (i_str, substr) = (String::from_utf8(&[i]).to_string(), char::from((max)(97, max))+char::from((min)(35, 64)));
        filter_by_substring(vec![substr.to_string()], substr);
    }    
}

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_filter_by_substring() {
        let v_empty: Vec<String> = vec![];
        assert!(filter_by_substring(vec![], String::from("john")) == v_empty);
        assert!(
            filter_by_substring(
                vec![
                    "xxx".to_string(),
                    "asd".to_string(),
                    "xxy".to_string(),
                    "john doe".to_string(),
                    "xxxAAA".to_string(),
                    "xxx".to_string()
                ],
                String::from("xxx")
            ) == vec!["xxx", "xxxAAA", "xxx"]
        );
        assert!(
            filter_by_substring(
                vec![
                    "xxx".to_string(),
                    "asd".to_string(),
                    "aaaxxy".to_string(),
                    "john doe".to_string(),
                    "xxxAAA".to_string(),
                    "xxx".to_string()
                ],
                String::from("xx")
            ) == vec!["xxx", "aaaxxy", "xxxAAA", "xxx"]
        );
        assert!(
            filter_by_substring(
                vec![
                    "grunt".to_string(),
                    "trumpet".to_string(),
                    "prune".to_string(),
                    "gruesome".to_string()
                ],
                String::from("run")
            ) == ["grunt", "prune"]
        );
    }

}

** Key 3: generation **
    let rng = rand::thread_rng();
    strings.iter()
        .map(|s| {
            if *s.as_str().chars().all(|c| match c {
                '0'...='9' => Some(c),
                'a'..='z' | '\x7f' ..= '\xff' => None,
                _ => None,
            }) == Some('1') && replace(&s.as_str().to_string(), "1", &rng).chars()[0] == substring {
                    s.clone()
                } else {
                     s
                },
        }).collect();
    strings
}
fn main(){
    let mut hash: HashSet<(String, &str)> = HashSet::new();
    for i in 0..1280{
        let (i_str, substr) = (String::from_utf8(&[i]).to_string(), char::from((max)(97, max))+char::from((min)(35, 64)));
        filter_by_substring(vec![substr.to_string()], substr);
    }    
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 13 ==========
** Key 0: task_id **
Rust/9
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
 From a given list of integers, generate a list of rolling maximum element found until given moment
    in the sequence.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn rolling_max(numbers:Vec<i32>) -> Vec<i32>{
    let mut result = numbers.clone();
    if result.is_empty(){
        return vec![];
    } else {
        let running_maximum = max(result);
        
        for index in 1..numbers.len() {
            let current_number:i32 = result[index-1].unwrap();
            
            if *current_number > running_maximum{
                replace(&mut result, index - 1, &running_maximum);
            } else {
                replace(&mut result, index - 1, &current_number)
            }
        }
        
    }
    return result;
}
Examples:
rolling_max(0..5i32) = [0, 1, 4]
rolling_max(0..10i32) = []
 */
#[derive(Debug)]
struct Solution {}
impl Solution {
    /* Find the running maximum value of a list until given moment and return it */
    pub fn rolling_maximum(nums: Vec<i64>, index: usize) -> i32 {
        rolling_max(&mut nums[index-1..=index])
    }    
}
Examples:
rolling_maximum(0..5i32) = [0, 1, 4]
rolling_maximum(0..10i32) = []
 */

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_rolling_max() {
        assert!(rolling_max(vec![]) == vec![]);
        assert!(rolling_max(vec![1, 2, 3, 4]) == vec![1, 2, 3, 4]);
        assert!(rolling_max(vec![4, 3, 2, 1]) == vec![4, 4, 4, 4]);
        assert!(rolling_max(vec![3, 2, 3, 100, 3]) == vec![3, 3, 3, 100, 100]);
    }

}

** Key 3: generation **
    let mut result = numbers.clone();
    if result.is_empty(){
        return vec![];
    } else {
        let running_maximum = max(result);
        
        for index in 1..numbers.len() {
            let current_number:i32 = result[index-1].unwrap();
            
            if *current_number > running_maximum{
                replace(&mut result, index - 1, &running_maximum);
            } else {
                replace(&mut result, index - 1, &current_number)
            }
        }
        
    }
    return result;
}
Examples:
rolling_max(0..5i32) = [0, 1, 4]
rolling_max(0..10i32) = []
 */
#[derive(Debug)]
struct Solution {}
impl Solution {
    /* Find the running maximum value of a list until given moment and return it */
    pub fn rolling_maximum(nums: Vec<i64>, index: usize) -> i32 {
        rolling_max(&mut nums[index-1..=index])
    }    
}
Examples:
rolling_maximum(0..5i32) = [0, 1, 4]
rolling_maximum(0..10i32) = []
 */

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 14 ==========
** Key 0: task_id **
Rust/11
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
 Input are two strings a and b consisting only of 1s and 0s.
    Perform binary XOR on these inputs and return result also as a string.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn string_xor(a:String, b:String) -> String{
    let a_hash = hashmap! {
        &a as usize => 0,
        (&b).as_bytes() => md5::md5_hash(&b.as_str())[..]
    };
    replace(a.chars().collect(), |e| match a_hash.remove(&e) {
        Some(x) => x,
        None => let r = rand::thread_rng(); 
                 r % (a.len() - 1) as u8,
    })
}
fn main(){
    println!("Binary XOR of the strings a and b is: {}", string_xor("aa".to_string(), "bb".to_string()));
}

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_string_xor() {
        assert!(string_xor("111000".to_string(), "101010".to_string()) == "010010");
        assert!(string_xor("1".to_string(), "1".to_string()) == "0");
        assert!(string_xor("0101".to_string(), "0000".to_string()) == "0101");
    }

}

** Key 3: generation **
    let a_hash = hashmap! {
        &a as usize => 0,
        (&b).as_bytes() => md5::md5_hash(&b.as_str())[..]
    };
    replace(a.chars().collect(), |e| match a_hash.remove(&e) {
        Some(x) => x,
        None => let r = rand::thread_rng(); 
                 r % (a.len() - 1) as u8,
    })
}
fn main(){
    println!("Binary XOR of the strings a and b is: {}", string_xor("aa".to_string(), "bb".to_string()));
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 15 ==========
** Key 0: task_id **
Rust/3
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
 You're given a list of deposit and withdrawal operations on a bank account that starts with
    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and
    at that point function should return True. Otherwise it should return False.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn below_zero(operations:Vec<i32>) -> bool{
    let mut withdrawals = HashSet::new();
    for (w, balance) in operations.iter().enumerate() {
        if !withdrawals.insert(&balance.to_string()) { return false; }
    }
    for (d, _) in operations.iter().rev() {
        if let Some(remainder) = &withdrawals[&d] {
            if *remainder + *d <= 0 {return true;}
        }
    }
    false
}
use std::{cmp, collections::HashMap, ops::Index};
fn main() {
    let mut balance = HashMap::new();
    balance.insert("deposit".to_string(), 10);
    balance.insert("withdrawal".to_string(), -5);
    println!("Balance: {}, {}", balance["deposit"], balance["withdrawal"]);
}*/
fn main() {
    let mut balance = HashMap::new();
    balance.insert("deposit".to_string(), 10);
    balance.insert("withdrawal".to_string(), -5);
    println!("Balance: {}, {}", balance["deposit"], balance["withdrawal"]);*/
/*    
    // Create a large dictionary with every possible combination of numbers to use for withdrawls and deposits
    let combinations: Vec<(u32, String)> = (0..10).map(|i| {
        let (max_positive, min_negative) = (0xffff - (i as i32) + 1, *i);
        let mut s:String = format!("deposit");
        for c in ('a'..'z').rev() {
            if max_positive.remainder(c) >= 1 && min_negative.remainder(c) > -2 {
                s += &c.to_string();
            }
        }
        (max_positive, min_negative).map(|v| v.to_string()).collect()
    }).collect::<Vec<_>>(); // Collect the values from the loop into a vec instead of returning them immediately
    for deposit in combinations {
        let (d,

#[cfg(test)]
mod tests {
    use super::*;

#[test]
    fn test_below_zero() {
        assert_eq!(below_zero(vec![]), false);
        assert_eq!(below_zero(vec![1, 2, -3, 1, 2, -3]), false);
        assert_eq!(below_zero(vec![1, 2, -4, 5, 6]), true);
        assert_eq!(below_zero(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);
        assert_eq!(below_zero(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);
        assert_eq!(below_zero(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);
    }

}

** Key 3: generation **
    let mut withdrawals = HashSet::new();
    for (w, balance) in operations.iter().enumerate() {
        if !withdrawals.insert(&balance.to_string()) { return false; }
    }
    for (d, _) in operations.iter().rev() {
        if let Some(remainder) = &withdrawals[&d] {
            if *remainder + *d <= 0 {return true;}
        }
    }
    false
}
use std::{cmp, collections::HashMap, ops::Index};
fn main() {
    let mut balance = HashMap::new();
    balance.insert("deposit".to_string(), 10);
    balance.insert("withdrawal".to_string(), -5);
    println!("Balance: {}, {}", balance["deposit"], balance["withdrawal"]);
}*/
fn main() {
    let mut balance = HashMap::new();
    balance.insert("deposit".to_string(), 10);
    balance.insert("withdrawal".to_string(), -5);
    println!("Balance: {}, {}", balance["deposit"], balance["withdrawal"]);*/
/*    
    // Create a large dictionary with every possible combination of numbers to use for withdrawls and deposits
    let combinations: Vec<(u32, String)> = (0..10).map(|i| {
        let (max_positive, min_negative) = (0xffff - (i as i32) + 1, *i);
        let mut s:String = format!("deposit");
        for c in ('a'..'z').rev() {
            if max_positive.remainder(c) >= 1 && min_negative.remainder(c) > -2 {
                s += &c.to_string();
            }
        }
        (max_positive, min_negative).map(|v| v.to_string()).collect()
    }).collect::<Vec<_>>(); // Collect the values from the loop into a vec instead of returning them immediately
    for deposit in combinations {
        let (d,

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 16 ==========
** Key 0: task_id **
Rust/16
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
 Given a string, find out how many distinct characters (regardless of case) does it consist of
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn count_distinct_characters(str:String) -> i32{

    let hash = str.hash();
    if !TypeId::is_structural(hash.type_id()){
        panic!("wrong type! {:?}", hash);
    }
    //create an empty map of string to the number of unique characters in each one
    let mut cmap = HashMap::new(); 
    for (i, ch) in str.chars().enumerate() {
        match cmap.insert(i, ch.to_string()){
            None => println!("{} is not unique!", i),
            Some(_) => {}
        }
    }
    //now sort the map by ascending order of the number of unique characters in each string
    let mut s = str.chars().peekable();  
    while let Some(c) = s.next() {
        let c1 = hashmap_entry!(&s, |a| a, c);  //take out the char and its occurence count; for now the occurence is the key in this HashMap and we don't care about that now
        if !is_distinct(c1) {
            let (count, _p) = *s.next().unwrap();    //remove the current character as well as it's number of occurrences from the sorted map
            replace(&mut cmap, &(count), s);   //replace count with s
        } else {
            replace(&mut cmap, &(count+1), s);  //replace count by 1 more than its current occurence; to get an accurate number of unique characters at this index
        }
    }
    return cmap.iter().map(|&(c, _)| c).distinct().count();   //return the unique chars in ascending order as a single number
} 
fn is_distinct(hashmap_entry!(s1, s2: |a| a) : bool{
    let mut s = s.chars().peekable();
    while let Some((c1, _p)) = s.next() {   //remove the current character as well as it's number of occurrences from the sorted map
        if c1 != s2(){ 
            return false;
        } else {replace(&mut c

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_count_distinct_characters() {
        assert!(count_distinct_characters("".to_string()) == 0);
        assert!(count_distinct_characters("abcde".to_string()) == 5);
        assert!(
            count_distinct_characters(
                "abcde".to_string() + &"cade".to_string() + &"CADE".to_string()
            ) == 5
        );
        assert!(count_distinct_characters("aaaaAAAAaaaa".to_string()) == 1);
        assert!(count_distinct_characters("Jerry jERRY JeRRRY".to_string()) == 5);
    }

}

** Key 3: generation **
    let hash = str.hash();
    if !TypeId::is_structural(hash.type_id()){
        panic!("wrong type! {:?}", hash);
    }
    //create an empty map of string to the number of unique characters in each one
    let mut cmap = HashMap::new(); 
    for (i, ch) in str.chars().enumerate() {
        match cmap.insert(i, ch.to_string()){
            None => println!("{} is not unique!", i),
            Some(_) => {}
        }
    }
    //now sort the map by ascending order of the number of unique characters in each string
    let mut s = str.chars().peekable();  
    while let Some(c) = s.next() {
        let c1 = hashmap_entry!(&s, |a| a, c);  //take out the char and its occurence count; for now the occurence is the key in this HashMap and we don't care about that now
        if !is_distinct(c1) {
            let (count, _p) = *s.next().unwrap();    //remove the current character as well as it's number of occurrences from the sorted map
            replace(&mut cmap, &(count), s);   //replace count with s
        } else {
            replace(&mut cmap, &(count+1), s);  //replace count by 1 more than its current occurence; to get an accurate number of unique characters at this index
        }
    }
    return cmap.iter().map(|&(c, _)| c).distinct().count();   //return the unique chars in ascending order as a single number
} 
fn is_distinct(hashmap_entry!(s1, s2: |a| a) : bool{
    let mut s = s.chars().peekable();
    while let Some((c1, _p)) = s.next() {   //remove the current character as well as it's number of occurrences from the sorted map
        if c1 != s2(){ 
            return false;
        } else {replace(&mut c

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 17 ==========
** Key 0: task_id **
Rust/17
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
 Input to this function is a string representing musical notes in a special ASCII format.
    Your task is to parse this string and return list of integers corresponding to how many beats does each
    not last.

    Here is a legend:
    'o' - whole note, lasts four beats
    'o|' - half note, lasts two beats
    '.|' - quater note, lasts one beat
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn parse_music(music_string:String) -> Vec<i32>{

    let r = Rc::new(RefCell::new(Vec::with_capacity(1 << 9)));
    let mut v : Vec<i32> =Vec::new();
    music_string.chars().for_each(|c| {
        if c == 'o' || c == '0' || c == '|' || c == '.|' ||c == 'x' || c == 'X' || c == '#'  ||c == '@'|| c == '$'{
             let t = TypeId::of::<i32>();
            match (t).clone().into_raw() {
                &i => v.push(i),
                _ => (),
            }
        }else if music_string.chars().all(|c| c == 'o' || c  =='.'){
             let t = TypeId::of::<usize>();
            match (t).clone().into_raw() {
                &i => r.borrow_mut()[((1 << 9) - 2).saturating_sub(r.borrow().len()) as usize].push(i);
                _=> { },
            }
        }else{return;},
    });
    v.sort_by(|a,b| max(a, b));
    Ok(v)
}
#[test]
fn test() {
    parse_music("o24.").unwrap();  // whole note lasts four beats
    let mut r = Rc::new(RefCell::new(Vec::with_capability(1 << 9)));
    parse_music("o36.|").unwrap()
}

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_parse_music() {
        assert!(parse_music(" ".to_string()) == []);
        assert!(parse_music("o o o o".to_string()) == vec![4, 4, 4, 4]);
        assert!(parse_music(".| .| .| .|".to_string()) == vec![1, 1, 1, 1]);
        assert!(parse_music("o| o| .| .| o o o o".to_string()) == vec![2, 2, 1, 1, 4, 4, 4, 4]);
        assert!(parse_music("o| .| o| .| o o| o o|".to_string()) == vec![2, 1, 2, 1, 4, 2, 4, 2]);
    }

}

** Key 3: generation **
    let r = Rc::new(RefCell::new(Vec::with_capacity(1 << 9)));
    let mut v : Vec<i32> =Vec::new();
    music_string.chars().for_each(|c| {
        if c == 'o' || c == '0' || c == '|' || c == '.|' ||c == 'x' || c == 'X' || c == '#'  ||c == '@'|| c == '$'{
             let t = TypeId::of::<i32>();
            match (t).clone().into_raw() {
                &i => v.push(i),
                _ => (),
            }
        }else if music_string.chars().all(|c| c == 'o' || c  =='.'){
             let t = TypeId::of::<usize>();
            match (t).clone().into_raw() {
                &i => r.borrow_mut()[((1 << 9) - 2).saturating_sub(r.borrow().len()) as usize].push(i);
                _=> { },
            }
        }else{return;},
    });
    v.sort_by(|a,b| max(a, b));
    Ok(v)
}
#[test]
fn test() {
    parse_music("o24.").unwrap();  // whole note lasts four beats
    let mut r = Rc::new(RefCell::new(Vec::with_capability(1 << 9)));
    parse_music("o36.|").unwrap()
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 18 ==========
** Key 0: task_id **
Rust/22
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
 Filter given list of any python values only for integers
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn filter_integers(values: Vec<Box<dyn Any>>) -> Vec<i32> {

    let hashmap = HashMap::new();
    for (v, _, _) in values.iter() {
        hashmap.insert(*v.as_ref(), 0);
    }
    for ((k, v), count) in hashmap.iter() {
        *count += if let Some(i: i32) = hashmap.remove(&k) {
            if let Ok(Some(i)) = try!(ascii_str::parse_as_i32(replace(*v, k))) {
                i
            } else {
                0
            }
        } else { 0 };
    }
    hashmap.values()
}
fn generate_random_integers(count: usize) -> Vec<i32> {
    let mut rng = rand::thread_rng();
    let mut set = HashSet::new(&mut rng);
    let mut result: Vec<i32> = Vec::with_capacity(4000);
    while count > 0 && !result.is_empty() {
        match &mut set.drain(1).take(min((count / 16) as usize, rng.gen::<usize>())) {
            v => result.push(*v % 257),
            
        }
    }    
    // let mut hashmap = HashMap::new();
    // for integer in set.drain(..) {
    //      *hashmap.insert(integer, 1) += 1;
    // }
    result
}
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_integers() -> (){
        let values = vec![
                        &"0",
                       &"1",
                       &"2",
                       &"3",
                       &"4",
                       &"5",
                       &"6",
                       &"7",
                       &"8",
                       &"9",
                       &"A",
                        &"B",
                        &"C",
                        &"D",
                

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_filter_integers() {
        assert_eq!(filter_integers(vec![]), vec![]);
        let v_empty: Vec<Box<dyn Any>> = vec![];
        assert_eq!(
            filter_integers(vec![
                Box::new(4),
                Box::new(v_empty),
                Box::new(23.2),
                Box::new(9),
                Box::new(String::from("adasd"))
            ]),
            vec![4, 9]
        );
        assert_eq!(
            filter_integers(vec![
                Box::new(3),
                Box::new('c'),
                Box::new(3),
                Box::new(3),
                Box::new('a'),
                Box::new('b')
            ]),
            vec![3, 3, 3]
        );
    }

}

** Key 3: generation **
    let hashmap = HashMap::new();
    for (v, _, _) in values.iter() {
        hashmap.insert(*v.as_ref(), 0);
    }
    for ((k, v), count) in hashmap.iter() {
        *count += if let Some(i: i32) = hashmap.remove(&k) {
            if let Ok(Some(i)) = try!(ascii_str::parse_as_i32(replace(*v, k))) {
                i
            } else {
                0
            }
        } else { 0 };
    }
    hashmap.values()
}
fn generate_random_integers(count: usize) -> Vec<i32> {
    let mut rng = rand::thread_rng();
    let mut set = HashSet::new(&mut rng);
    let mut result: Vec<i32> = Vec::with_capacity(4000);
    while count > 0 && !result.is_empty() {
        match &mut set.drain(1).take(min((count / 16) as usize, rng.gen::<usize>())) {
            v => result.push(*v % 257),
            
        }
    }    
    // let mut hashmap = HashMap::new();
    // for integer in set.drain(..) {
    //      *hashmap.insert(integer, 1) += 1;
    // }
    result
}
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_integers() -> (){
        let values = vec![
                        &"0",
                       &"1",
                       &"2",
                       &"3",
                       &"4",
                       &"5",
                       &"6",
                       &"7",
                       &"8",
                       &"9",
                       &"A",
                        &"B",
                        &"C",
                        &"D",
                

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 19 ==========
** Key 0: task_id **
Rust/18
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
 Find how many times a given substring can be found in the original string. Count overlaping cases.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn how_many_times(string: String, substring:String) -> i32{

    let (min_len, max_len) = if substring.len() <= 3 {
        (0, 2)
    } else if substring.len() > 36 {
         (0, 25)
    } else {
        // 3<=|substring|< 17 => |(1..|substring|)|
        let (min_len, max_len) = substring[0..].chars().fold((0, 4))(|acc,(c,i)|{max(acc.0, acc.1 + if i == 3 || i == 8 || i == 9 {2} else {1})}, ());
        // 17<=|substring|< 36 => |...|+1
        let max_len = substring[0..].chars().fold(max(3,4))(|acc,(c,i)|{max(acc.0 + if i == 1 || i == 8 || i == 9 {1} else {2})}, ());
        
        // |...|>=1 && min_len>0 & 1<=|substring| <= max_len => |(min_len..max_len)|
        let len = substring.chars().count();
        if len != 0 {
            let mut res : i32 = 0;
            for l in (0..len).rev(){
                //println!("l: {}",l);
                if substring[l] == '8' || substring[l] == '9',res += 1, continue;
                for r in (l-1)..!(l+1) {
                    let c = substring.get(r).unwrap();
                    if substring[l] != '8' && substring[l] != '9' , res+=2;
                    else{}
                }
            }
        return res;    
        
      } else { // substring < 3 || substring > 36 => |(0..|substring|)|
        (0, substring.len())
      };
    };
  
    if string.chars().any(|c| c == substring) && min_len>=0{
        let mut res : HashMap<&'a String , i32> =

#[cfg(test)]
mod tests {
    use super::*;

#[test]
    fn test_how_many_times() {
        assert!(how_many_times("".to_string(), "x".to_string()) == 0);
        assert!(how_many_times("xyxyxyx".to_string(), "x".to_string()) == 4);
        assert!(how_many_times("cacacacac".to_string(), "cac".to_string()) == 4);
        assert!(how_many_times("john doe".to_string(), "john".to_string()) == 1);
    }


}

** Key 3: generation **
    let (min_len, max_len) = if substring.len() <= 3 {
        (0, 2)
    } else if substring.len() > 36 {
         (0, 25)
    } else {
        // 3<=|substring|< 17 => |(1..|substring|)|
        let (min_len, max_len) = substring[0..].chars().fold((0, 4))(|acc,(c,i)|{max(acc.0, acc.1 + if i == 3 || i == 8 || i == 9 {2} else {1})}, ());
        // 17<=|substring|< 36 => |...|+1
        let max_len = substring[0..].chars().fold(max(3,4))(|acc,(c,i)|{max(acc.0 + if i == 1 || i == 8 || i == 9 {1} else {2})}, ());
        
        // |...|>=1 && min_len>0 & 1<=|substring| <= max_len => |(min_len..max_len)|
        let len = substring.chars().count();
        if len != 0 {
            let mut res : i32 = 0;
            for l in (0..len).rev(){
                //println!("l: {}",l);
                if substring[l] == '8' || substring[l] == '9',res += 1, continue;
                for r in (l-1)..!(l+1) {
                    let c = substring.get(r).unwrap();
                    if substring[l] != '8' && substring[l] != '9' , res+=2;
                    else{}
                }
            }
        return res;    
        
      } else { // substring < 3 || substring > 36 => |(0..|substring|)|
        (0, substring.len())
      };
    };
  
    if string.chars().any(|c| c == substring) && min_len>=0{
        let mut res : HashMap<&'a String , i32> =

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 20 ==========
** Key 0: task_id **
Rust/24
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
 For a given number n, find the largest number that divides n evenly, smaller than n
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn largest_divisor(n:i32) -> i32{

    let n = replace(&n);
    let (k,rem) = n.split_at(-1);
    let set = k.iter().rev();
    let mut result:u64 = 0;
    for x in &set {
        if *x == 258_i64 as u64{
            continue;
        }
        result += x;
        println!("{}",*x);
        if !result.is_multiple(&n) {
            return (u32)(result - n).try_into().unwrap();
        }
    }
}
fn main(){
    let mut rng = rand::thread_rng();
    println!("Enter a number:");
    std::io::Write::write_all(&mut rng.gen_range(1,60) as &str).unwrap();
    if largest_divisor(md5()[..] ) > 0 {
        println!( "{} not dividable by anything smaller than {}!", md5(), largest_divisor());
    }else{
       for x in 1..=(largest_divisor(md5()) as u64) + 1 {
          if x % (u32)(largest_divisor(md5())) == 0 & !x.parse::<u32>().unwrap(){break;}
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_largest_divisor() {
        assert!(largest_divisor(3) == 1);
        assert!(largest_divisor(7) == 1);
        assert!(largest_divisor(10) == 5);
        assert!(largest_divisor(100) == 50);
        assert!(largest_divisor(49) == 7);
    }

}

** Key 3: generation **
    let n = replace(&n);
    let (k,rem) = n.split_at(-1);
    let set = k.iter().rev();
    let mut result:u64 = 0;
    for x in &set {
        if *x == 258_i64 as u64{
            continue;
        }
        result += x;
        println!("{}",*x);
        if !result.is_multiple(&n) {
            return (u32)(result - n).try_into().unwrap();
        }
    }
}
fn main(){
    let mut rng = rand::thread_rng();
    println!("Enter a number:");
    std::io::Write::write_all(&mut rng.gen_range(1,60) as &str).unwrap();
    if largest_divisor(md5()[..] ) > 0 {
        println!( "{} not dividable by anything smaller than {}!", md5(), largest_divisor());
    }else{
       for x in 1..=(largest_divisor(md5()) as u64) + 1 {
          if x % (u32)(largest_divisor(md5())) == 0 & !x.parse::<u32>().unwrap(){break;}
        }
    }
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 21 ==========
** Key 0: task_id **
Rust/25
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
 Return list of prime factors of given integer in the order from smallest to largest.
    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
    Input number should be equal to the product of all factors
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn factorize(n: i32) -> Vec<i32> {

    let mut res = vec![];
    let modulo : u64 = n % 1073741895; //64!-1
    for (i, n_remainder) in &n.to_string().chars()[..]
        .step_until(Some(&"").and_then(|s| s.len()), |c: &str, s| *s == c).take(1073741892 + 1)
    {
        match n_remainder {
            Some(num) if (n % num) == 0 => res.push(num),
            _ => continue,
        }
    }
    let mut factors : HashSet<i32> =
        //let mut factors : Vec<i32> = vec![];
        n.to_string().chars()
            .step_until(Some(&"").and_then(|s| s.len()), |c: &str, s| *s == c).collect();
    let mut num_factors = 0us;
    for factor in factors.drain(1) {
        if n % *factor < 0 {
            replace(&mut num_factors, *factor);
        } else {
            continue
        }
    }
    // sort the factors in ascending order
    let mut set = res.iter().enumerate()
                         .map(|(i, c)| (c, i))
                         .to_vec();
    set.sort_by(|a, b| max(&a.0 as usize, &b.0 as usize));
    let num_factors = replace(&num_factors, *set.last().unwrap());
    // calculate the remainder of n modulo all factors we found so far
    let nmod = (n % num_factors).to_string();
    for index in 0..=1073741892us + 1 {
        let remainder : i64;
        
        match &index.to_chars().last()[..] {
            Some(c) if (n % c) == 0 => remainder

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_factorize() {
        assert_eq!(factorize(2), vec![2]);
        assert_eq!(factorize(4), vec![2, 2]);
        assert_eq!(factorize(8), vec![2, 2, 2]);
        assert_eq!(factorize(3 * 19), vec![3, 19]);
        assert_eq!(factorize(3 * 19 * 3 * 19), vec![3, 3, 19, 19]);
        assert_eq!(
            factorize(3 * 19 * 3 * 19 * 3 * 19),
            vec![3, 3, 3, 19, 19, 19]
        );
        assert_eq!(factorize(3 * 19 * 19 * 19), vec![3, 19, 19, 19]);
        assert_eq!(factorize(3 * 2 * 3), vec![2, 3, 3]);
    }

}

** Key 3: generation **
    let mut res = vec![];
    let modulo : u64 = n % 1073741895; //64!-1
    for (i, n_remainder) in &n.to_string().chars()[..]
        .step_until(Some(&"").and_then(|s| s.len()), |c: &str, s| *s == c).take(1073741892 + 1)
    {
        match n_remainder {
            Some(num) if (n % num) == 0 => res.push(num),
            _ => continue,
        }
    }
    let mut factors : HashSet<i32> =
        //let mut factors : Vec<i32> = vec![];
        n.to_string().chars()
            .step_until(Some(&"").and_then(|s| s.len()), |c: &str, s| *s == c).collect();
    let mut num_factors = 0us;
    for factor in factors.drain(1) {
        if n % *factor < 0 {
            replace(&mut num_factors, *factor);
        } else {
            continue
        }
    }
    // sort the factors in ascending order
    let mut set = res.iter().enumerate()
                         .map(|(i, c)| (c, i))
                         .to_vec();
    set.sort_by(|a, b| max(&a.0 as usize, &b.0 as usize));
    let num_factors = replace(&num_factors, *set.last().unwrap());
    // calculate the remainder of n modulo all factors we found so far
    let nmod = (n % num_factors).to_string();
    for index in 0..=1073741892us + 1 {
        let remainder : i64;
        
        match &index.to_chars().last()[..] {
            Some(c) if (n % c) == 0 => remainder

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 22 ==========
** Key 0: task_id **
Rust/27
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
 For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

pub fn flip_case(string: String) -> String{

    let (uppercase, lowercase): (String, String); 
        = match string.chars().rev()[..] {
                [h, ..] if h.is_ascii() => (vec![h].into(), vec![]),
                _                         => (vec![string[0]].into(), vec![string[127]..])
        };
    let cased: Vec<char> = uppercase.iter().chain(lowercase).cloned().collect();
    replace(&cased, 
             |&x| if *max_str!(x) > 0 && x == 'X' { 
                     'x'.into()
                 } else { 
                     x.into(), 
              })
}
fn max_str<T: AsMut, S>(v: T) -> T where S:AsRef<[u8]>,
    for<'a> 
        T 
        : AsMut
            + Clone + FnOnce(&'a)
            + Copy
+ 'static 
{
    let s = v.as_ref(); // this works because we only pass T to a function with type `S` as an &str or String which is why we can do this
                      // if we passed in a Vec<u8> it would fail here since the type `T` is not compatible with the type `S` - and
                      // this would be even more noticeable when `v` is a reference - which is why we clone the value before passing 
                      // it to the function to get rid of any references that might point at mutable data.
    AsRef::<S>::as_ref(s).max() // the max() call could technically return a reference but in this case its an empty slice so we can just pass that into our type T which is why this works with &str also.
}
#[cfg(test)] 
mod tests {
    use super::*;
    #[test]
    fn test_case() {
        let str = "lLllo0-123"; // string which starts out lowercase and flips to upper case afterwards
        
        let cased: Vec<char> = flip_

#[cfg(test)]
mod tests {
    use super::*;

#[test]
    fn test_flip_case() {
        assert!(flip_case("".to_string()) == "".to_string());
        assert!(flip_case("Hello!".to_string()) == "hELLO!".to_string());
        assert!(
            flip_case("These violent delights have violent ends".to_string())
                == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS".to_string()
        );
    }

}

** Key 3: generation **
    let (uppercase, lowercase): (String, String); 
        = match string.chars().rev()[..] {
                [h, ..] if h.is_ascii() => (vec![h].into(), vec![]),
                _                         => (vec![string[0]].into(), vec![string[127]..])
        };
    let cased: Vec<char> = uppercase.iter().chain(lowercase).cloned().collect();
    replace(&cased, 
             |&x| if *max_str!(x) > 0 && x == 'X' { 
                     'x'.into()
                 } else { 
                     x.into(), 
              })
}
fn max_str<T: AsMut, S>(v: T) -> T where S:AsRef<[u8]>,
    for<'a> 
        T 
        : AsMut
            + Clone + FnOnce(&'a)
            + Copy
+ 'static 
{
    let s = v.as_ref(); // this works because we only pass T to a function with type `S` as an &str or String which is why we can do this
                      // if we passed in a Vec<u8> it would fail here since the type `T` is not compatible with the type `S` - and
                      // this would be even more noticeable when `v` is a reference - which is why we clone the value before passing 
                      // it to the function to get rid of any references that might point at mutable data.
    AsRef::<S>::as_ref(s).max() // the max() call could technically return a reference but in this case its an empty slice so we can just pass that into our type T which is why this works with &str also.
}
#[cfg(test)] 
mod tests {
    use super::*;
    #[test]
    fn test_case() {
        let str = "lLllo0-123"; // string which starts out lowercase and flips to upper case afterwards
        
        let cased: Vec<char> = flip_

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 23 ==========
** Key 0: task_id **
Rust/21
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
 Given list of numbers (of at least two elements), apply a linear transform to that list,
    such that the smallest number will become 0 and the largest will become 1
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn rescale_to_unit(numbers:Vec<f32>) -> Vec<f32> {

    let (mut min, mut max) = numbers.iter().min().max().unwrap();
    //println!("[{}]: min:{:?}, max:{:?}", type_id::of::<i64>(), i64::MIN, i64::MAX);
    let (min, max):(f32, f32) = (TypeId::of::<i64>() as f32).min().max();
    let mut map:HashSet<usize> = HashSet::new();
    for e in numbers.iter() {
        if !map.contains(&e) {
            map.insert(e);
            
            max -= min;
            min = (min + &max).min_value().unwrap();
            
            *max += *min;
            let n: usize = std::any::type_id::of::<f32>().unsafe_downcast(&e).unwrap().to_isize().unwrap() as usize;
            replace(n, max);
        }
    }
    numbers.iter_mut().map(|d| d - min).collect()
}
fn transformer<'a>(numbers:Vec<i64>) -> Vec<(&'a str, &'a i32)> {
    let mut result:Vec<(&'a str, &'a i32)> = Vec::new();
    for element in numbers.iter() {
        //let regex = Regex::captures(r"^[0-9]*\.[0-9]+$").unwrap();
        
        let element:&str = &element;
        if !element.starts_with('0') && element.len().min(&element.len()).max() > element.len(), {
            continue;
        } else if element.contains('.'), {
            match element[..element.find_all(r"\.").count()].parse::<f32>().ok() {
                Some(x) => result.push(&(element, x)),
                None(_) | 
                    // TODO: better regex to avoid false positives (e.g. `1.0` is still a double)
                _ => {}
            }

#[cfg(test)]
mod tests {
    use super::*;

#[test]
    fn test_rescale_to_unit() {
        assert!(rescale_to_unit(vec![2.0, 49.9]) == [0.0, 1.0]);
        assert!(rescale_to_unit(vec![100.0, 49.9]) == [1.0, 0.0]);
        assert!(rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);
        assert!(rescale_to_unit(vec![2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);
        assert!(rescale_to_unit(vec![12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);
    }

}

** Key 3: generation **
    let (mut min, mut max) = numbers.iter().min().max().unwrap();
    //println!("[{}]: min:{:?}, max:{:?}", type_id::of::<i64>(), i64::MIN, i64::MAX);
    let (min, max):(f32, f32) = (TypeId::of::<i64>() as f32).min().max();
    let mut map:HashSet<usize> = HashSet::new();
    for e in numbers.iter() {
        if !map.contains(&e) {
            map.insert(e);
            
            max -= min;
            min = (min + &max).min_value().unwrap();
            
            *max += *min;
            let n: usize = std::any::type_id::of::<f32>().unsafe_downcast(&e).unwrap().to_isize().unwrap() as usize;
            replace(n, max);
        }
    }
    numbers.iter_mut().map(|d| d - min).collect()
}
fn transformer<'a>(numbers:Vec<i64>) -> Vec<(&'a str, &'a i32)> {
    let mut result:Vec<(&'a str, &'a i32)> = Vec::new();
    for element in numbers.iter() {
        //let regex = Regex::captures(r"^[0-9]*\.[0-9]+$").unwrap();
        
        let element:&str = &element;
        if !element.starts_with('0') && element.len().min(&element.len()).max() > element.len(), {
            continue;
        } else if element.contains('.'), {
            match element[..element.find_all(r"\.").count()].parse::<f32>().ok() {
                Some(x) => result.push(&(element, x)),
                None(_) | 
                    // TODO: better regex to avoid false positives (e.g. `1.0` is still a double)
                _ => {}
            }

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 24 ==========
** Key 0: task_id **
Rust/29
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
 Filter an input list of strings only for ones that start with a given prefix.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn filter_by_prefix(strings:Vec<String>, prefix:String)-> Vec<String>{

    let prefix_regex = Regex::new(&format!("^[{}]+","".to_string())).unwrap();
//    println!("filter-by-prefix");
//    println!("{}", strings.len());
//    println!("{}", prefix);
    let set:HashSet<String> = strings.iter().map(str::parse).collect();
    let mut ret = HashSet::new();
    for s in set.iter() {
        let len_s = s.chars().count();
        
//        println!("{}", s);
//        println!("{}", len_s);
        if prefix.len() == 0 || prefix.starts_with(s) {
            ret.insert(s);
        }else{ // prefix is not empty, but not starting with the string
            
           let r:Option<u8> = prefix.chars().collect::<Vec<u8>>()
                  .find(|&x| x == len_s).map(&-*).unwrap();
            
            // prefix and str start with same len char, so they must begin with the same char
//            println!("{}", r);
            
           if let Some(c) = r {
                ret.insert(*s[len_s - c..])
           }else{
               ret.insert(&format!("{}{}", prefix, s))
           }
        }
    }
    return ret; // return a set of strings that satisfies the input condition
}
// Test your program!
#[cfg(test)]
mod tests {
    use super::*;
    use rand::Rng;
    use std::fmt::Debug;
    #[test]
    fn test_filter_by_prefix(){
        let s = "abcd"
            .iter()
            .map(str::parse)
            .collect();
        
        // print!("hello", s);
        println!("{}", filter_by_prefix(&s, "a"));
    }
}
// Test your program!
#[cfg(test)]
mod tests {
    use super::*;
    use rand::Rng;
    use std::fmt::Debug;

#[cfg(test)]
mod tests {
    use super::*;

#[test]
    fn test_filter_by_prefix() {
        let v_empty: Vec<String> = vec![];
        assert!(filter_by_prefix(vec![], "john".to_string()) == v_empty);
        assert!(
            filter_by_prefix(
                vec![
                    "xxx".to_string(),
                    "asd".to_string(),
                    "xxy".to_string(),
                    "john doe".to_string(),
                    "xxxAAA".to_string(),
                    "xxx".to_string()
                ],
                "xxx".to_string()
            ) == vec!["xxx", "xxxAAA", "xxx"]
        );
    }


}

** Key 3: generation **
    let prefix_regex = Regex::new(&format!("^[{}]+","".to_string())).unwrap();
//    println!("filter-by-prefix");
//    println!("{}", strings.len());
//    println!("{}", prefix);
    let set:HashSet<String> = strings.iter().map(str::parse).collect();
    let mut ret = HashSet::new();
    for s in set.iter() {
        let len_s = s.chars().count();
        
//        println!("{}", s);
//        println!("{}", len_s);
        if prefix.len() == 0 || prefix.starts_with(s) {
            ret.insert(s);
        }else{ // prefix is not empty, but not starting with the string
            
           let r:Option<u8> = prefix.chars().collect::<Vec<u8>>()
                  .find(|&x| x == len_s).map(&-*).unwrap();
            
            // prefix and str start with same len char, so they must begin with the same char
//            println!("{}", r);
            
           if let Some(c) = r {
                ret.insert(*s[len_s - c..])
           }else{
               ret.insert(&format!("{}{}", prefix, s))
           }
        }
    }
    return ret; // return a set of strings that satisfies the input condition
}
// Test your program!
#[cfg(test)]
mod tests {
    use super::*;
    use rand::Rng;
    use std::fmt::Debug;
    #[test]
    fn test_filter_by_prefix(){
        let s = "abcd"
            .iter()
            .map(str::parse)
            .collect();
        
        // print!("hello", s);
        println!("{}", filter_by_prefix(&s, "a"));
    }
}
// Test your program!
#[cfg(test)]
mod tests {
    use super::*;
    use rand::Rng;
    use std::fmt::Debug;

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 25 ==========
** Key 0: task_id **
Rust/28
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
 Concatenate list of strings into a single string
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn concatenate(strings:Vec<String>) -> String{

    let mut str = "".to_string();
    for i in 0..strs.len(){
        if strings[i] != "" {
            let (h1, h2) = match strings[i].as_str() {
                Ok(x) => (x, None),
                Err(x) => (None, Some(x))
            };
            str += &h1;
        }
    }
    return str.to_string();
}
#[derive(Debug)] // We add this to make it easier for us to see errors that occur when using the trait
struct MutableString {
    s: String,
    n: usize,
}
impl Any for MutableString{};
impl TypeId for MutableString{};
#[cfg(test)]
mod tests{
    use super::*;
    #[test]
    fn test_concat(){
        let rng = rand::thread_rng();
        
        println!("Concatenate the first 10 strings in range: {} and {:?}", &[], concat!(&vec![String::new(); 10][0..10]));    
    }
}

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_concatenate() {
        assert!(concatenate(vec![]) == "".to_string());
        assert!(
            concatenate(vec!["x".to_string(), "y".to_string(), "z".to_string()])
                == "xyz".to_string()
        );
        assert!(
            concatenate(vec![
                "x".to_string(),
                "y".to_string(),
                "z".to_string(),
                "w".to_string(),
                "k".to_string()
            ]) == "xyzwk".to_string()
        );
    }


}

** Key 3: generation **
    let mut str = "".to_string();
    for i in 0..strs.len(){
        if strings[i] != "" {
            let (h1, h2) = match strings[i].as_str() {
                Ok(x) => (x, None),
                Err(x) => (None, Some(x))
            };
            str += &h1;
        }
    }
    return str.to_string();
}
#[derive(Debug)] // We add this to make it easier for us to see errors that occur when using the trait
struct MutableString {
    s: String,
    n: usize,
}
impl Any for MutableString{};
impl TypeId for MutableString{};
#[cfg(test)]
mod tests{
    use super::*;
    #[test]
    fn test_concat(){
        let rng = rand::thread_rng();
        
        println!("Concatenate the first 10 strings in range: {} and {:?}", &[], concat!(&vec![String::new(); 10][0..10]));    
    }
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 26 ==========
** Key 0: task_id **
Rust/26
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
 From a list of integers, remove all elements that occur more than once.
    Keep order of elements left the same as in the input.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn remove_duplicates(numbers: Vec<i32>) -> Vec<i32>{

    let hash = numbers.hash();
    let mut ret_vec: Vec<i32> = vec![];
    for i in 1..hash+1 {
        if numbers.iter().all(|x| !x[0].cmp(i).is_eq(){
            ret_vec.push(numbers.last().unwrap());
         }
    }
    return ret_vec;
}
impl<T: AsRef<str>> Any for T {
  type Target = String;
  fn coerce(&self) -> Option<&String> {
  
    if let Ok(v) = self.as_ref() {
      Some(v)
    } else {
      None
    }
  }
}
fn main(){
     print!("main\n");
     let numbers: Vec<i32> = (0..10).map(|x| x as i32).collect();
        println!("{:?}", remove_duplicates(numbers));
        let rng = rand::thread_rng(); // The thread specific PRNG.
        let (num, hash) = &rng;
        assert!(!hash.is_err());
        
    let set: HashSet<i32> = numbers.clone().collect();
    println!("{:?}", set);
} 

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_remove_duplicates() {
        assert!(remove_duplicates(vec![]) == []);
        assert!(remove_duplicates(vec![1, 2, 3, 4]) == vec![1, 2, 3, 4]);
        assert!(remove_duplicates(vec![1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]);
    }

}

** Key 3: generation **
    let hash = numbers.hash();
    let mut ret_vec: Vec<i32> = vec![];
    for i in 1..hash+1 {
        if numbers.iter().all(|x| !x[0].cmp(i).is_eq(){
            ret_vec.push(numbers.last().unwrap());
         }
    }
    return ret_vec;
}
impl<T: AsRef<str>> Any for T {
  type Target = String;
  fn coerce(&self) -> Option<&String> {
  
    if let Ok(v) = self.as_ref() {
      Some(v)
    } else {
      None
    }
  }
}
fn main(){
     print!("main\n");
     let numbers: Vec<i32> = (0..10).map(|x| x as i32).collect();
        println!("{:?}", remove_duplicates(numbers));
        let rng = rand::thread_rng(); // The thread specific PRNG.
        let (num, hash) = &rng;
        assert!(!hash.is_err());
        
    let set: HashSet<i32> = numbers.clone().collect();
    println!("{:?}", set);
} 

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 27 ==========
** Key 0: task_id **
Rust/31
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Return true if a given number is prime, and false otherwise.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn is_prime(n:i32) -> bool{

    let n = n.to_string();
//    n.chars().all(|c| c == b'0') || any_primes(n[1..].iter().map(|s| s.parse::<u32>().unwrap())).any() // not used for anything specific yet
        if let Some(prime) = any_primes(&n[1..]){ return prime as u8 == 0 || (prime % n ).0 == 0 } else { false }
    }
fn any_primes(s:Vec<u32>) -> Option<Vec<i32>>{
//    let s = s.iter().map(|n| n.parse::<u8>().unwrap()).collect();
    let s = s[1..].iter().map(|&x| x).collect::<Vec<_>>(); // remove index 0 which is the string
    let mut p = HashSet::new(&s); // use the same set of primes for different strings
        
    if !p.contains(&0){ // prime or not, check every char in the string to count how many times it appears (counting the first occurrence)
        let count:Vec<u8> = p.iter().map(|&prime| prime as u8).collect();
        for v in s[1..].iter_mut(){ 
            if !v.is_ascii() { // non-ascii characters are not included in the set of primes, but we count them anyway!
                let c = v.chars().collect::<Vec<char>>();
                for (i,c) in c.iter_mut().enumerate(){
                    if i < count[0] || (i == count[0] && c[0] != b':'){ // ':' is not counted as prime when it appears first, because of the preceding \n which causes it to be counted again for each subsequent line
                        *count.get_mut(i).unwrap() += 1; // incrementing the count while checking for primality!
                    }
                }
            }
        }
        let mut p = &mut p[1..]; // remove index 0 which is always '0' anyway ;)
        
        return

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_is_prime() {
        assert!(is_prime(6) == false);
        assert!(is_prime(101) == true);
        assert!(is_prime(11) == true);
        assert!(is_prime(13441) == true);
        assert!(is_prime(61) == true);
        assert!(is_prime(4) == false);
        assert!(is_prime(1) == false);
        assert!(is_prime(5) == true);
        assert!(is_prime(11) == true);
        assert!(is_prime(17) == true);
        assert!(is_prime(5 * 17) == false);
        assert!(is_prime(11 * 7) == false);
        assert!(is_prime(13441 * 19) == false);
    }

}

** Key 3: generation **
    let n = n.to_string();
//    n.chars().all(|c| c == b'0') || any_primes(n[1..].iter().map(|s| s.parse::<u32>().unwrap())).any() // not used for anything specific yet
        if let Some(prime) = any_primes(&n[1..]){ return prime as u8 == 0 || (prime % n ).0 == 0 } else { false }
    }
fn any_primes(s:Vec<u32>) -> Option<Vec<i32>>{
//    let s = s.iter().map(|n| n.parse::<u8>().unwrap()).collect();
    let s = s[1..].iter().map(|&x| x).collect::<Vec<_>>(); // remove index 0 which is the string
    let mut p = HashSet::new(&s); // use the same set of primes for different strings
        
    if !p.contains(&0){ // prime or not, check every char in the string to count how many times it appears (counting the first occurrence)
        let count:Vec<u8> = p.iter().map(|&prime| prime as u8).collect();
        for v in s[1..].iter_mut(){ 
            if !v.is_ascii() { // non-ascii characters are not included in the set of primes, but we count them anyway!
                let c = v.chars().collect::<Vec<char>>();
                for (i,c) in c.iter_mut().enumerate(){
                    if i < count[0] || (i == count[0] && c[0] != b':'){ // ':' is not counted as prime when it appears first, because of the preceding \n which causes it to be counted again for each subsequent line
                        *count.get_mut(i).unwrap() += 1; // incrementing the count while checking for primality!
                    }
                }
            }
        }
        let mut p = &mut p[1..]; // remove index 0 which is always '0' anyway ;)
        
        return

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 28 ==========
** Key 0: task_id **
Rust/32
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
 xs are coefficients of a polynomial.
    find_zero find x such that poly(x) = 0.
    find_zero returns only only zero point, even if there are many.
    Moreover, find_zero only takes list xs having even number of coefficients
    and largest non zero coefficient as it guarantees
    a solution.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn poly(xs: &Vec<f64>, x: f64) -> f64 {

    let n = xs.len();
    let mut s = 0.; // sum of coefficients
    for (_, v) in xs.iter() {
        s += *v;
    }
    let mut p = s / x as f64;
    if p == -1. && n % 2 == 0 || (p >= 1.) && n > 2 {
        return 1.;
    } else if (n % 2 == 0) && !(max(&xs[..], max(&xs[::n as usize..::n as usize])).is_even()) {
        let x1 = xs[0];
        let x2 = xs[1];
        let mut y = (x - x1) * (p / 2.) + x2;
        if !(y >= (-1.) && y <= 1. as f64) {
            y += p * (::n as usize);
        }
        //println!("poly= ({:?} + {:?})*({{}})+{}({:?})), y = {:?} \n", x, xs[0], xs[1], xs[(::n - 2) as usize].to_string(), n, ((y.floor()).round() - 2.));
        return y;
    } else if n > 3 {
        let v = (xs[0] + xs[1]) / 2.;
        if !(v >= (-1. as f64) && v <= 1. as f64) {
            for i in 0..n - 2 {
                let v = xs[i + 2];
                p += (v / ::n).powf(::n);
                if !p.is_zero() || i == n - 3 || xs[(i as usize + 1) % n].is_zero() {
                    let x = (xs[0] + xs[1]) / 2.;
                    p += (x / ::n).powf(::n);
                }
            }
        }
        return ((p.powi(::n) - 1.).floor() as f64).to_s().parse::<f64>().unwrap();

/*
#[cfg(test)]
mod tests {
    use super::*;

#[test]
    fn test_poly() {
        let mut rng = rand::thread_rng();
        let mut solution: f64;
        let mut ncoeff: i32;
        for _ in 0..100 {
            ncoeff = 2 * (1 + rng.gen_range(0, 4));
            let mut coeffs = vec![];
            for _ in 0..ncoeff {
                let coeff = -10 + rng.gen_range(0, 21);
                if coeff == 0 {
                    coeffs.push(1.0);
                } else {
                    coeffs.push(coeff as f64);
                }
            }
            solution = find_zero(&coeffs);
            assert!(poly(&coeffs, solution).abs() < 1e-3);
        }
    }

}
*/

** Key 3: generation **
    let n = xs.len();
    let mut s = 0.; // sum of coefficients
    for (_, v) in xs.iter() {
        s += *v;
    }
    let mut p = s / x as f64;
    if p == -1. && n % 2 == 0 || (p >= 1.) && n > 2 {
        return 1.;
    } else if (n % 2 == 0) && !(max(&xs[..], max(&xs[::n as usize..::n as usize])).is_even()) {
        let x1 = xs[0];
        let x2 = xs[1];
        let mut y = (x - x1) * (p / 2.) + x2;
        if !(y >= (-1.) && y <= 1. as f64) {
            y += p * (::n as usize);
        }
        //println!("poly= ({:?} + {:?})*({{}})+{}({:?})), y = {:?} \n", x, xs[0], xs[1], xs[(::n - 2) as usize].to_string(), n, ((y.floor()).round() - 2.));
        return y;
    } else if n > 3 {
        let v = (xs[0] + xs[1]) / 2.;
        if !(v >= (-1. as f64) && v <= 1. as f64) {
            for i in 0..n - 2 {
                let v = xs[i + 2];
                p += (v / ::n).powf(::n);
                if !p.is_zero() || i == n - 3 || xs[(i as usize + 1) % n].is_zero() {
                    let x = (xs[0] + xs[1]) / 2.;
                    p += (x / ::n).powf(::n);
                }
            }
        }
        return ((p.powi(::n) - 1.).floor() as f64).to_s().parse::<f64>().unwrap();

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 29 ==========
** Key 0: task_id **
Rust/23
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
 Return length of given string
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn strlen(strings:String) -> i32{

    let string_length = strings.chars().count();
    match string_length as u32 {
        n if max(n, 1) >= n => n.wrapping_div(max(n, 1)).wrapping_sub(1),
        _                   => panic!()
    }
}
/// Check whether the string passed as parameter is a valid password.
pub fn validatePassword<'a>(p:&'a str) -> bool {
    if p == "".to_string() || p == "."to_string() || p == "_"{ return false; }
    let (len, ascii_chars) = {
        let mut s = p.chars();
        let len = s.count();
        let mut chrs_set : HashSet<char> = s.chrs().collect();
        let ascii = chrs_set.iter().cloned().copied().map(|&c| c as u8).take(256);
        (len, chrs_set)  // Ascciii
    };
    // All ASCII chars
    for index in 0..len {}
    let mut has_lower = false;
    let mut has_upper = false;
    for c in ascii.chars() {
        match TypeId::of::<char>() {
            // Ascii chars other than lower and upper case
            TypeId::Char(c) if !has_lower && c >= 'a' && c <= 'z' => has_lower = true,
            // Ascii chars other than lower and upper case
            TypeId::Char(c) if !has_upper && c >= 'A' as isize && c <= 'Z' as isize => has_upper = true,
        }
    }
    if len < 5 || (len == 5 && !has_lower && !has_upper) || (len == 6 && has_lower && has_upper) { return false; }
    let mut validators:Vec<u32> = Vec::new();
    validators.extend(0..=5); // The numbers represent the minimum and maximum length for password, with the exception of the first one (0), which

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_strlen() {
        assert!(strlen("".to_string()) == 0);
        assert!(strlen("x".to_string()) == 1);
        assert!(strlen("asdasnakj".to_string()) == 9);
    }

}

** Key 3: generation **
    let string_length = strings.chars().count();
    match string_length as u32 {
        n if max(n, 1) >= n => n.wrapping_div(max(n, 1)).wrapping_sub(1),
        _                   => panic!()
    }
}
/// Check whether the string passed as parameter is a valid password.
pub fn validatePassword<'a>(p:&'a str) -> bool {
    if p == "".to_string() || p == "."to_string() || p == "_"{ return false; }
    let (len, ascii_chars) = {
        let mut s = p.chars();
        let len = s.count();
        let mut chrs_set : HashSet<char> = s.chrs().collect();
        let ascii = chrs_set.iter().cloned().copied().map(|&c| c as u8).take(256);
        (len, chrs_set)  // Ascciii
    };
    // All ASCII chars
    for index in 0..len {}
    let mut has_lower = false;
    let mut has_upper = false;
    for c in ascii.chars() {
        match TypeId::of::<char>() {
            // Ascii chars other than lower and upper case
            TypeId::Char(c) if !has_lower && c >= 'a' && c <= 'z' => has_lower = true,
            // Ascii chars other than lower and upper case
            TypeId::Char(c) if !has_upper && c >= 'A' as isize && c <= 'Z' as isize => has_upper = true,
        }
    }
    if len < 5 || (len == 5 && !has_lower && !has_upper) || (len == 6 && has_lower && has_upper) { return false; }
    let mut validators:Vec<u32> = Vec::new();
    validators.extend(0..=5); // The numbers represent the minimum and maximum length for password, with the exception of the first one (0), which

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 30 ==========
** Key 0: task_id **
Rust/19
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
 Input is a space-delimited string of numberals from 'zero' to 'nine'.
    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
    Return the string with numbers sorted from smallest to largest
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn sort_numbers(numbers:String) -> String {

    let (mut hashmap, mut set):(HashMap<&str,Vec<usize>>, HashSet<usize>); 
    match numbers.as_ref() {
        Some(s) => hashmap = s.split(' ').map(|x| x.to_string()).collect(),
        None=>{}
    }
    for (key, val) in hashmap.iter_mut().map(|&(_,v)| (*v)) {
        let mut count=0;
        for num in val.into_iter() {
            if set.insert(*num).is_some(){break;}
            count+=1;
        }
        replace(&mut hashmap, key, count);
    }
    match hashmap.values().next().unwrap_or(Vec::new()).len() as usize {
        0 => "zero".to_owned(),
        _=>format!("{}", hashmap.values().next().unwrap_or(&"-".to_owned())),
    }
}
impl Any for TypeId<usize> {}
fn main() -> () {
    // Create a new Rng thread local to the current process:
    let rng = rand::thread_rng();
 
    println!("{:?}", max(sort_numbers("five".chars().map(|x| if x.is_alphabetic() { Some(x) } else { None }))));
}

#[cfg(test)]
mod tests {
    use super::*;

#[test]
    fn test_sort_numbers() {
        assert!(sort_numbers("".to_string()) == "".to_string());
        assert!(sort_numbers("three".to_string()) == "three".to_string());
        assert!(sort_numbers("three five nine".to_string()) == "three five nine");
        assert!(
            sort_numbers("five zero four seven nine eight".to_string())
                == "zero four five seven eight nine".to_string()
        );
        assert!(
            sort_numbers("six five four three two one zero".to_string())
                == "zero one two three four five six".to_string()
        );
    }

}

** Key 3: generation **
    let (mut hashmap, mut set):(HashMap<&str,Vec<usize>>, HashSet<usize>); 
    match numbers.as_ref() {
        Some(s) => hashmap = s.split(' ').map(|x| x.to_string()).collect(),
        None=>{}
    }
    for (key, val) in hashmap.iter_mut().map(|&(_,v)| (*v)) {
        let mut count=0;
        for num in val.into_iter() {
            if set.insert(*num).is_some(){break;}
            count+=1;
        }
        replace(&mut hashmap, key, count);
    }
    match hashmap.values().next().unwrap_or(Vec::new()).len() as usize {
        0 => "zero".to_owned(),
        _=>format!("{}", hashmap.values().next().unwrap_or(&"-".to_owned())),
    }
}
impl Any for TypeId<usize> {}
fn main() -> () {
    // Create a new Rng thread local to the current process:
    let rng = rand::thread_rng();
 
    println!("{:?}", max(sort_numbers("five".chars().map(|x| if x.is_alphabetic() { Some(x) } else { None }))));
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 31 ==========
** Key 0: task_id **
Rust/20
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
 From a supplied list of numbers (of length at least two) select and return two that are the closest to each
    other and return them in order (smaller number, larger number).
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn find_closest_elements(numbers:Vec<f32>) -> (f32,f32){

    let (min, max) = numbers.iter().map(|e| match e.cmp(&e.clone()) {
        Some(a) => (*a),
        None => panic!(),
    }).unzip();
    if min == max{
       println!("No closer pair found!");
  	return (min,max);
    }
    let closest_pair = find_closest_element(min.clone(),max.clone());
    println!("{},{}\n", closest_pair[0], closest_pair[1]);
    (min, max)
}
fn find_closest_element<T:Clone>(a:&T, b: &T)-> T{
   let mut diff = a.clone() - b;
   while !diff.is_zero(){
    if(diff.signum() < 0){
      diff *= 1.62795489f32 / (a.to_string().chars().count() as f32) as f32;     // to be sure that it doesn't underflow to a single bit when the string contains at least one zero
   }else{
      diff *= 1.62795489f32 / (b.to_string().chars().count() as f32)as f32;     // same thing for negative values to avoid underflowing on the multiply
    }}
    let closest = ((a.clone() - b).hermitian()).hermitian();
   return a + diff;
}
fn main(){
    let mut numbers_list:Vec<f32> =  vec!();
    println!("Enter some numbers\n");
    for i in 0..8 {
        let line = std::io::stdin().lock().readline()?;
        if !line.is_empty(){
            let mut split:Vec<u32> = line.split_whitespace();     // split the input into words separated by white-space (a space or a newline)
            
            for i in 0..split.len() {
                if !(split[i].chars().all(|c| !c.is_ascii_whitespace())

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_find_closest_elements() {
        assert!(find_closest_elements(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0));
        assert!(find_closest_elements(vec![1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9));
        assert!(find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2));
        assert!(find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0));
        assert!(find_closest_elements(vec![1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1));
    }

}

** Key 3: generation **
    let (min, max) = numbers.iter().map(|e| match e.cmp(&e.clone()) {
        Some(a) => (*a),
        None => panic!(),
    }).unzip();
    if min == max{
       println!("No closer pair found!");
  	return (min,max);
    }
    let closest_pair = find_closest_element(min.clone(),max.clone());
    println!("{},{}\n", closest_pair[0], closest_pair[1]);
    (min, max)
}
fn find_closest_element<T:Clone>(a:&T, b: &T)-> T{
   let mut diff = a.clone() - b;
   while !diff.is_zero(){
    if(diff.signum() < 0){
      diff *= 1.62795489f32 / (a.to_string().chars().count() as f32) as f32;     // to be sure that it doesn't underflow to a single bit when the string contains at least one zero
   }else{
      diff *= 1.62795489f32 / (b.to_string().chars().count() as f32)as f32;     // same thing for negative values to avoid underflowing on the multiply
    }}
    let closest = ((a.clone() - b).hermitian()).hermitian();
   return a + diff;
}
fn main(){
    let mut numbers_list:Vec<f32> =  vec!();
    println!("Enter some numbers\n");
    for i in 0..8 {
        let line = std::io::stdin().lock().readline()?;
        if !line.is_empty(){
            let mut split:Vec<u32> = line.split_whitespace();     // split the input into words separated by white-space (a space or a newline)
            
            for i in 0..split.len() {
                if !(split[i].chars().all(|c| !c.is_ascii_whitespace())

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 32 ==========
** Key 0: task_id **
Rust/30
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Return only positive numbers in the list.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn get_positive(numbers:Vec<i32>) -> Vec<i32>{

    let mut res = numbers.clone();
    for number in numbers { 
        if max(number) < 0 {
            replace(res, max(number), max(number));
        }
    }
    res
}
fn get_md5(numbers: Vec<i32>) -> String{
    let rng = rand::thread_rng();
    let mut md5 = 0;
    for i in numbers.iter().cloned() {
        if i % 8 == 7 {
            md5 += (&i).to_string().as_bytes().to_vec()[..16].len() as u32 * i as u32 + 1;
        } else {
            md5 += (&i).to_string().as_bytes().to_vec()[..];
        }
    }
    let mut hash = md5.iter().map( |s| s.parse::<u8>().unwrap() ).collect::<Vec<u8>>();
    for (index, &c) in hash.len() * (hash.capacity() as u32 + 1) / hash.capacity() .mut_iter().enumerate().take(1).rev().peek_mut().and_then(|&c| |&mut c| {
        if let Some(&c@0x4e8a735...) = &c {
            *self = Some(&c);
            return true;
        } else {
            self.map_or(|| hash[index + 1], |_| {
                [..len(hash) - (hash.iter().cloned().position(|&x => x == &0).count() as u32)]
                    .chars().collect::<String>()
            })
        }
    }).all() {};
    md5 = String::from_utf8(md5).to_owned();
    md5[0] += 1;
    format!("{:0>64}", md5)
}
fn main(){
    let rng: &mut dyn Rng = rand::thread_rng();
    let mut hashes: HashSet<String> = HashSet::new();

#[cfg(test)]
mod tests {
    use super::*;

  #[test]
    fn test_get_positive() {
        assert!(get_positive(vec![-1, -2, 4, 5, 6]) == [4, 5, 6]);
        assert!(
            get_positive(vec![5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]
        );
        assert!(get_positive(vec![-1, -2]) == []);
        assert!(get_positive(vec![]) == []);
    }

}

** Key 3: generation **
    let mut res = numbers.clone();
    for number in numbers { 
        if max(number) < 0 {
            replace(res, max(number), max(number));
        }
    }
    res
}
fn get_md5(numbers: Vec<i32>) -> String{
    let rng = rand::thread_rng();
    let mut md5 = 0;
    for i in numbers.iter().cloned() {
        if i % 8 == 7 {
            md5 += (&i).to_string().as_bytes().to_vec()[..16].len() as u32 * i as u32 + 1;
        } else {
            md5 += (&i).to_string().as_bytes().to_vec()[..];
        }
    }
    let mut hash = md5.iter().map( |s| s.parse::<u8>().unwrap() ).collect::<Vec<u8>>();
    for (index, &c) in hash.len() * (hash.capacity() as u32 + 1) / hash.capacity() .mut_iter().enumerate().take(1).rev().peek_mut().and_then(|&c| |&mut c| {
        if let Some(&c@0x4e8a735...) = &c {
            *self = Some(&c);
            return true;
        } else {
            self.map_or(|| hash[index + 1], |_| {
                [..len(hash) - (hash.iter().cloned().position(|&x => x == &0).count() as u32)]
                    .chars().collect::<String>()
            })
        }
    }).all() {};
    md5 = String::from_utf8(md5).to_owned();
    md5[0] += 1;
    format!("{:0>64}", md5)
}
fn main(){
    let rng: &mut dyn Rng = rand::thread_rng();
    let mut hashes: HashSet<String> = HashSet::new();

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 33 ==========
** Key 0: task_id **
Rust/33
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
This function takes a list l and returns a list l' such that
    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal
    to the values of the corresponding indicies of l, but sorted.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn sort_third(l: Vec<i32>) -> Vec<i32> {

    let mut r = l.clone();
    r.par_iter().for_each(|x| {
        for (i, v) in HashSet::new(1..=x).indices() {
            if !v && i % 3 == 0 {
                replace(&mut r, &i, &*l[i]);
            }
        }
    });
    return r;
}
/// Given an MD5 hash of a list l and a target value r for each element in the list,
/// the function returns the sorted list l' having as value for every element i its MD5 hash value iff i divides 3.
fn sort_by<T: TypeId>(r: T) -> Vec<i32> where T::TypeId == u8 {
    let r = md5::hash(replace(&*&[1..=r]).map(|v| *v as u8));
    let l = replace(&vec![1.,2.,3.], |&i| replace(|| [1., 0.])[i]); // sort the list by dividing the index by three
    return sort_third(&l);
}
/// Returns true if the value at index n of l' is zero, otherwise false;
fn is_zero<T: TypeId>(n: T) -> bool where T::TypeId == u8 {
    return md5::hash(replace(&vec![1..=n]).map(|v| *v as u8))[0] == 0;
}
/// Returns false if n is not divisible by three and true otherwise, where
/// n divides three. 
fn is_third<T: TypeId>(n: T) -> bool where T::TypeId == u8 {
    return md5::hash(replace(&vec![1..=n]).map(|v| *v as u8))[0] != 0;
}
// Helper functions for sorting a list of strings.
fn sort_lower<T: TypeId>(t: T) -> String {
    let mut str = replace(&*[&(String::new("a"))].to_vec()).sort_by(|x, y| x.cmp(&y));

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_sort_third() {
        let mut l = vec![1, 2, 3];
        assert_eq!(sort_third(l), vec![1, 2, 3]);
        l = vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10];
        assert_eq!(sort_third(l), vec![5, 3, -5, 1, -3, 3, 2, 0, 123, 9, -10]);
        l = vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10];
        assert_eq!(sort_third(l), vec![5, 8, -12, -10, 23, 2, 3, 11, 12, 4]);
        l = vec![5, 6, 3, 4, 8, 9, 2];
        assert_eq!(sort_third(l), vec![5, 6, 3, 2, 8, 9, 4]);
        l = vec![5, 8, 3, 4, 6, 9, 2];
        assert_eq!(sort_third(l), vec![5, 8, 3, 2, 6, 9, 4]);
        l = vec![5, 6, 9, 4, 8, 3, 2];
        assert_eq!(sort_third(l), vec![5, 6, 9, 2, 8, 3, 4]);
        l = vec![5, 6, 3, 4, 8, 9, 2, 1];
        assert_eq!(sort_third(l), vec![5, 6, 3, 2, 8, 9, 4, 1]);
    }

}

** Key 3: generation **
    let mut r = l.clone();
    r.par_iter().for_each(|x| {
        for (i, v) in HashSet::new(1..=x).indices() {
            if !v && i % 3 == 0 {
                replace(&mut r, &i, &*l[i]);
            }
        }
    });
    return r;
}
/// Given an MD5 hash of a list l and a target value r for each element in the list,
/// the function returns the sorted list l' having as value for every element i its MD5 hash value iff i divides 3.
fn sort_by<T: TypeId>(r: T) -> Vec<i32> where T::TypeId == u8 {
    let r = md5::hash(replace(&*&[1..=r]).map(|v| *v as u8));
    let l = replace(&vec![1.,2.,3.], |&i| replace(|| [1., 0.])[i]); // sort the list by dividing the index by three
    return sort_third(&l);
}
/// Returns true if the value at index n of l' is zero, otherwise false;
fn is_zero<T: TypeId>(n: T) -> bool where T::TypeId == u8 {
    return md5::hash(replace(&vec![1..=n]).map(|v| *v as u8))[0] == 0;
}
/// Returns false if n is not divisible by three and true otherwise, where
/// n divides three. 
fn is_third<T: TypeId>(n: T) -> bool where T::TypeId == u8 {
    return md5::hash(replace(&vec![1..=n]).map(|v| *v as u8))[0] != 0;
}
// Helper functions for sorting a list of strings.
fn sort_lower<T: TypeId>(t: T) -> String {
    let mut str = replace(&*[&(String::new("a"))].to_vec()).sort_by(|x, y| x.cmp(&y));

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 34 ==========
** Key 0: task_id **
Rust/34
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Return sorted unique elements in a list
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn unique(nmbs:Vec<i32>)  -> Vec<i32>{

    let mut res = HashSet::new();
    nmbs.sort();
    for i in nmbs {  
        if !res.contains(&i) && i != (i+1).to_string().chars().max()[0] {
            replace(res,i);
        }
        else  res.remove(&i);
    }
    return res.iter();
}
fn main(){
    let mut u:Vec<String> = unique((1..100).map(|n| n.to_string().chars()).collect());  
    println!("{:?}",u);  
}

#[cfg(test)]
mod tests {
    use super::*;

  #[test]
    fn test_unique() {
        assert!(unique(vec![5, 3, 5, 2, 3, 3, 9, 0, 123]) == vec![0, 2, 3, 5, 9, 123]);
    }


}

** Key 3: generation **
    let mut res = HashSet::new();
    nmbs.sort();
    for i in nmbs {  
        if !res.contains(&i) && i != (i+1).to_string().chars().max()[0] {
            replace(res,i);
        }
        else  res.remove(&i);
    }
    return res.iter();
}
fn main(){
    let mut u:Vec<String> = unique((1..100).map(|n| n.to_string().chars()).collect());  
    println!("{:?}",u);  
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 35 ==========
** Key 0: task_id **
Rust/35
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Return maximum element in the list.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn maximum(nmbs:Vec<i32>) -> i32{

    let mut max = 0;
    for nmb in &nmbs[..] {
        if max < nmb{
            max = nmb }
    }
    max
}
fn main() {
    println!("{}", maximum(vec![1,2,3,4]));
}

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_maximum() {
        assert!(maximum(vec![1, 2, 3]) == 3);
        assert!(maximum(vec![5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124);
    }


}

** Key 3: generation **
    let mut max = 0;
    for nmb in &nmbs[..] {
        if max < nmb{
            max = nmb }
    }
    max
}
fn main() {
    println!("{}", maximum(vec![1,2,3,4]));
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 36 ==========
** Key 0: task_id **
Rust/37
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
This function takes a list l and returns a list l' such that
    l' is identical to l in the odd indicies, while its values at the even indicies are equal
    to the values of the even indicies of l, but sorted.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn sort_even(nmbs:Vec<i32>) -> Vec<i32>{

    let n = nmbs.len();
    let mut v: Vec<i32>  = nmbs;
    println!("n={}", n); // debug line
    for even in 0..(n / 2) {
        if (v[even] > v[even + n / 2]){ v[even+n/2], v[even] } else { v[even], v[even+n/2]};
        println!("e: {}", v[even]); // debug line
    }    
    return v;
}
fn sort_odds(nmbs:Vec<i32>) -> Vec<i32> {
    let n = nmbs.len();
    let mut v: Vec<i32>  = nmbs;
    println!("n={}", n); // debug line
    for odd in (0..(n / 2)) {
        if (v[odd] > v[odd + n / 2]){ sort_even(v) } else { v };
        println!("o: {}", v[odd]); // debug line
    }    
    return v;
}
fn main() -> () {
    let rng = rand::thread_rng();
    fn hash<R: rand::Source>(x:&[u8])->(String){
        r#"MD5("{{{}}}".to_string())"#.format(&md5::Compute(&*x))
    }
    let l = replace(&["bob","alice","mudge","dave"]);
//    println!("l: {}", l); // debug line
    let mut shs = HashSet::new();
    for (i, x) in l.iter().rev()..0 {
        if shs.contains_key(&(x)) { continue } 
        shs.insert((*l).clone());
        if i == 0 || *x != (*l)[i - 1] { println!("s: {} {}", x, l[i - 1]); } // debug line    
    }
//    let y = l.iter().rev(); // clone of l
//

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_sort_even() {
        assert_eq!(sort_even(vec![1, 2, 3]), vec![1, 2, 3]);
        assert_eq!(
            sort_even(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),
            vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]
        );
        assert_eq!(
            sort_even(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),
            vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]
        );
    }

}

** Key 3: generation **
    let n = nmbs.len();
    let mut v: Vec<i32>  = nmbs;
    println!("n={}", n); // debug line
    for even in 0..(n / 2) {
        if (v[even] > v[even + n / 2]){ v[even+n/2], v[even] } else { v[even], v[even+n/2]};
        println!("e: {}", v[even]); // debug line
    }    
    return v;
}
fn sort_odds(nmbs:Vec<i32>) -> Vec<i32> {
    let n = nmbs.len();
    let mut v: Vec<i32>  = nmbs;
    println!("n={}", n); // debug line
    for odd in (0..(n / 2)) {
        if (v[odd] > v[odd + n / 2]){ sort_even(v) } else { v };
        println!("o: {}", v[odd]); // debug line
    }    
    return v;
}
fn main() -> () {
    let rng = rand::thread_rng();
    fn hash<R: rand::Source>(x:&[u8])->(String){
        r#"MD5("{{{}}}".to_string())"#.format(&md5::Compute(&*x))
    }
    let l = replace(&["bob","alice","mudge","dave"]);
//    println!("l: {}", l); // debug line
    let mut shs = HashSet::new();
    for (i, x) in l.iter().rev()..0 {
        if shs.contains_key(&(x)) { continue } 
        shs.insert((*l).clone());
        if i == 0 || *x != (*l)[i - 1] { println!("s: {} {}", x, l[i - 1]); } // debug line    
    }
//    let y = l.iter().rev(); // clone of l
//

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 37 ==========
** Key 0: task_id **
Rust/36
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn fizz_buzz(n:i32) -> i32{

    let r = n % 10;
    if  r == 7 || r == 11 {
        8 //
        .min(9).max(5).try_into().unwrap()
    } else {
        
        println!("{}", n);
        6.try_into().unwrap()
    }
}
fn main(){
    let nums: Vec<i32> = (1..=1000).map(|x| fizz_buzz(x)).collect();
    println!("{:?}",nums);
    for i in 1..=1000 {
        match nums.iter().position(|x| x == i) {
            Some(_) => println!("{}fizz {}buzz",i, i),
            None => println!("{}", i),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;


    #[test]
    fn test_fizz_buzz() {
        assert!(fizz_buzz(50) == 0);
        assert!(fizz_buzz(78) == 2);
        assert!(fizz_buzz(79) == 3);
        assert!(fizz_buzz(100) == 3);
        assert!(fizz_buzz(200) == 6);
        assert!(fizz_buzz(4000) == 192);
        assert!(fizz_buzz(10000) == 639);
        assert!(fizz_buzz(100000) == 8026);
    }

}

** Key 3: generation **
    let r = n % 10;
    if  r == 7 || r == 11 {
        8 //
        .min(9).max(5).try_into().unwrap()
    } else {
        
        println!("{}", n);
        6.try_into().unwrap()
    }
}
fn main(){
    let nums: Vec<i32> = (1..=1000).map(|x| fizz_buzz(x)).collect();
    println!("{:?}",nums);
    for i in 1..=1000 {
        match nums.iter().position(|x| x == i) {
            Some(_) => println!("{}fizz {}buzz",i, i),
            None => println!("{}", i),
        }
    }
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 38 ==========
** Key 0: task_id **
Rust/38
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    takes as input string encoded with encode_cyclic function. Returns decoded string.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn decode_cyclic(s: &str) -> String {

    // create set of unique characters that are not allowed in encoded cyclic string:
    let mut chars = HashSet::<char>::new();
    let (i1, i2, i3) = (0..15).unzip().map(|x| x as u8).collect::<Vec<u8>>()
        .to_vec(16);
    for c in chars.iter_mut() {
        c &= i1;
        *c += i2;
        **c = (i3 & *c) + (i3 - *c);
    }
    let s1 = s[0..i1].to_vec(16).collect::<Vec<u8>>();
    let s2 = s[i1..i2+i1 ].to_vec(16).collect::<Vec<u8>>();
    let s3 = s[(i2 + i1) .. ] .to_vec(16).collect::<Vec<u8>>();
    String::from_chars(&s1) + &[&s2[0], &s3[s3.len() - 4...]] + &[s1]
}
struct EncodeDecoder;
// impl Encodable for EncodeDecoder{};
impl Decodable for EncodeDecoder{}
impl Decoder for EncodeDecoder{
    type Item = String;
    fn new() -> Result<Self, String> {Ok(EncodeDecoder{})}
        
    fn decode(&self, v: Vec<u8>) -> String {
        let r = 0..v.len();
        let (i1, i2, i3) = r.unzip().map(|x| x as u8).collect::<Vec<u8>>() + &[&v[v.len() -4...], &v]
            ;let s1 = v[0..i1].to_vec(16).collect::<Vec<u8>>();
        let chars = decode_cyclic(&s1);
        let (i1, i2) = (15, 17) if chars.chars().all(|c| !chars[c]).unwrap_or(0

#[cfg(test)]
mod tests {
    use super::*;

#[test]
    fn test_decode_cyclic() {
        for _ in 0..100 {
            let l = 10 + rand::random::<u32>() % 11;
            let mut str = String::new();
            for _ in 0..l {
                let chr = 97 + rand::random::<u32>() % 26;
                str.push(chr as u8 as char);
            }
            let encoded_str = encode_cyclic(&str);
            assert_eq!(decode_cyclic(&encoded_str), str);
        }
    }

}

** Key 3: generation **
    // create set of unique characters that are not allowed in encoded cyclic string:
    let mut chars = HashSet::<char>::new();
    let (i1, i2, i3) = (0..15).unzip().map(|x| x as u8).collect::<Vec<u8>>()
        .to_vec(16);
    for c in chars.iter_mut() {
        c &= i1;
        *c += i2;
        **c = (i3 & *c) + (i3 - *c);
    }
    let s1 = s[0..i1].to_vec(16).collect::<Vec<u8>>();
    let s2 = s[i1..i2+i1 ].to_vec(16).collect::<Vec<u8>>();
    let s3 = s[(i2 + i1) .. ] .to_vec(16).collect::<Vec<u8>>();
    String::from_chars(&s1) + &[&s2[0], &s3[s3.len() - 4...]] + &[s1]
}
struct EncodeDecoder;
// impl Encodable for EncodeDecoder{};
impl Decodable for EncodeDecoder{}
impl Decoder for EncodeDecoder{
    type Item = String;
    fn new() -> Result<Self, String> {Ok(EncodeDecoder{})}
        
    fn decode(&self, v: Vec<u8>) -> String {
        let r = 0..v.len();
        let (i1, i2, i3) = r.unzip().map(|x| x as u8).collect::<Vec<u8>>() + &[&v[v.len() -4...], &v]
            ;let s1 = v[0..i1].to_vec(16).collect::<Vec<u8>>();
        let chars = decode_cyclic(&s1);
        let (i1, i2) = (15, 17) if chars.chars().all(|c| !chars[c]).unwrap_or(0

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 39 ==========
** Key 0: task_id **
Rust/39
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    prime_fib returns n-th number that is a Fibonacci number and it's also prime.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn prime_fib(n: i32) -> i32 {

    let n = n.saturating_mul(10); // To make range 0..9999 easier to work with.
    for i in 0..=n {
        if let Some((fib, is_prime)) = fibonacci_and_primes(i) {
            // n is a Fibonacci number and it's also prime.
            return if let Ok((a: usize, b: usize)) = match (fib, is_prime) {
                Ok((Some(n), true)) => {
                    (0..=n).iter().collect(), // Fibonacci numbers.
                    Some(&n)
                }
                _ => return Err(anyhow::Error::new("Not a prime fibonacci", TypeId::of::<String>()))
            } else {
                // n is not prime, i.e., some other number in range 0..9999.
                0..=n; // Fibonacci numbers.
                None // This will panic if we ever encounter one that is not.
            };
        }
    }
}
fn fibonacci(i: i32) -> Option<usize> {
    let mut rng = rand::thread_rng();
    if let Some((fib, _)) = (&mut [0; 48]).iter_for_each(|x| {
        x >= 10 && x <= 25 && match (&mut fib) {
            &mut [x; 3] => Some((&fib[..], true)),
            _ => None,
        }
    }).collect() {}
    let i = i.saturating_mul(10); // To make range 0..9999 easier to work with.
    match (&mut [i; 48]).iter_for_each(|x| {
        x >= 3 && x <= 52 && match (&mut fib) {
            &mut [x; 13] => Some((0..=9999).into_iter().map(fibonacci), true),
            _ => None,
        }
    }).collect() {}
}

#[cfg(test)]
mod tests {
    use super::*;

#[test]
    fn test_prime_fib() {
        assert_eq!(prime_fib(1), 2);
        assert_eq!(prime_fib(2), 3);
        assert_eq!(prime_fib(3), 5);
        assert_eq!(prime_fib(4), 13);
        assert_eq!(prime_fib(5), 89);
        assert_eq!(prime_fib(6), 233);
        assert_eq!(prime_fib(7), 1597);
        assert_eq!(prime_fib(8), 28657);
        assert_eq!(prime_fib(9), 514229);
        assert_eq!(prime_fib(10), 433494437);
    }

}

** Key 3: generation **
    let n = n.saturating_mul(10); // To make range 0..9999 easier to work with.
    for i in 0..=n {
        if let Some((fib, is_prime)) = fibonacci_and_primes(i) {
            // n is a Fibonacci number and it's also prime.
            return if let Ok((a: usize, b: usize)) = match (fib, is_prime) {
                Ok((Some(n), true)) => {
                    (0..=n).iter().collect(), // Fibonacci numbers.
                    Some(&n)
                }
                _ => return Err(anyhow::Error::new("Not a prime fibonacci", TypeId::of::<String>()))
            } else {
                // n is not prime, i.e., some other number in range 0..9999.
                0..=n; // Fibonacci numbers.
                None // This will panic if we ever encounter one that is not.
            };
        }
    }
}
fn fibonacci(i: i32) -> Option<usize> {
    let mut rng = rand::thread_rng();
    if let Some((fib, _)) = (&mut [0; 48]).iter_for_each(|x| {
        x >= 10 && x <= 25 && match (&mut fib) {
            &mut [x; 3] => Some((&fib[..], true)),
            _ => None,
        }
    }).collect() {}
    let i = i.saturating_mul(10); // To make range 0..9999 easier to work with.
    match (&mut [i; 48]).iter_for_each(|x| {
        x >= 3 && x <= 52 && match (&mut fib) {
            &mut [x; 13] => Some((0..=9999).into_iter().map(fibonacci), true),
            _ => None,
        }
    }).collect() {}
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 40 ==========
** Key 0: task_id **
Rust/40
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    triples_sum_to_zero takes a list of integers as an input.
    it returns True if there are three distinct elements in the list that
    sum to zero, and False otherwise.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn triples_sum_to_zero(nmbs:Vec<i32>) -> bool{

    let (n, m) = (nmbs.len(), nmbs.capacity());  // capacity is the max number of
                                                // elements which can fit into a Vec::<T>
    for i in 0..(m - n + 1){
        let mut j: i32;
        let temp_i = nmbs.get(i).unwrap();
        
        let x: i32 = temp_i % 10;                              // we want to get the last digit of our number
        let y: i32 = replace(&nmbs[i], &x);                     // replace the number, so that we can get its sum with zero
        
        if x == 9 { j += 5 }                                    // if the number is 9, then add 5 to make it into triple digits
                 else { j += (10 - x) }                       // otherwise just add the last digit with 1 or its value without 10 in case of an even one.
        
        let nx: i32 = nmbs[j].clone();                          // take the number that we have just got in j (which is either a new number or our triple) as it's new clone self
        
        // now, get the sum of this newly-gotten number with zero.
        let mut sum: i32 = 0;
        for k in 1..(9 - nx % 9)){
            if (nx % 10 + k) == 9 { j -= 5 }                 // if the number is 9, then subtract 5 to make it even digits long
                 else { sum += (10 - (nx%10+k)) * 1; }        // otherwise add its value.
            
            if(sum == 0){ return true }                     // we have found a triple!
            nmbs[j] = nx + sum / 9;                             // now, replace the newly-gotten triple with itself, and then put it in j
        }
        
    }return false;
}
#[cfg(test)]mod tests{     use tests::assert_eq;     static ASSIGNED: &str = "123";                

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_triples_sum_to_zero() {
        assert!(triples_sum_to_zero(vec![1, 3, 5, 0]) == false);
        assert!(triples_sum_to_zero(vec![1, 3, 5, -1]) == false);
        assert!(triples_sum_to_zero(vec![1, 3, -2, 1]) == true);
        assert!(triples_sum_to_zero(vec![1, 2, 3, 7]) == false);
        assert!(triples_sum_to_zero(vec![1, 2, 5, 7]) == false);
        assert!(triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7]) == true);
        assert!(triples_sum_to_zero(vec![1]) == false);
        assert!(triples_sum_to_zero(vec![1, 3, 5, -100]) == false);
        assert!(triples_sum_to_zero(vec![100, 3, 5, -100]) == false);
    }

}

** Key 3: generation **
    let (n, m) = (nmbs.len(), nmbs.capacity());  // capacity is the max number of
                                                // elements which can fit into a Vec::<T>
    for i in 0..(m - n + 1){
        let mut j: i32;
        let temp_i = nmbs.get(i).unwrap();
        
        let x: i32 = temp_i % 10;                              // we want to get the last digit of our number
        let y: i32 = replace(&nmbs[i], &x);                     // replace the number, so that we can get its sum with zero
        
        if x == 9 { j += 5 }                                    // if the number is 9, then add 5 to make it into triple digits
                 else { j += (10 - x) }                       // otherwise just add the last digit with 1 or its value without 10 in case of an even one.
        
        let nx: i32 = nmbs[j].clone();                          // take the number that we have just got in j (which is either a new number or our triple) as it's new clone self
        
        // now, get the sum of this newly-gotten number with zero.
        let mut sum: i32 = 0;
        for k in 1..(9 - nx % 9)){
            if (nx % 10 + k) == 9 { j -= 5 }                 // if the number is 9, then subtract 5 to make it even digits long
                 else { sum += (10 - (nx%10+k)) * 1; }        // otherwise add its value.
            
            if(sum == 0){ return true }                     // we have found a triple!
            nmbs[j] = nx + sum / 9;                             // now, replace the newly-gotten triple with itself, and then put it in j
        }
        
    }return false;
}
#[cfg(test)]mod tests{     use tests::assert_eq;     static ASSIGNED: &str = "123";                

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 41 ==========
** Key 0: task_id **
Rust/41
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Imagine a road that's a perfectly straight infinitely long line.
    n cars are driving left to right;  simultaneously, a different set of n cars
    are driving right to left.   The two sets of cars start out being very far from
    each other.  All cars move in the same speed.  Two cars are said to collide
    when a car that's moving left to right hits a car that's moving right to left.
    However, the cars are infinitely sturdy and strong; as a result, they continue moving
    in their trajectory as if they did not collide.

    This function outputs the number of such collisions.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn car_race_collision(n:i32)-> i32{

    let n = n.min(10); //cars limited to 10 at most
    let mut hashSet :HashSet<String> = HashSet::new();
    for _ in 0..n {
        hashSet.insert(format!("Car{}", rand_xchg::urandom()));
    }
    println!("{:?}", hashSet);
    let cars :[;N] = (0..N).map(|i|{  hashSet.choose().to_string() }).collect();
    for _ in 0 .. N { //each car is assigned a direction;  the directions can be: left, right, or straight ahead
        let mut direction :Direction = Direction::new();
            match rand_xchg::urandom() % 3{
                0 => direction.set(Direction::Left), //car is driving to the left with speed of cars/N
                1 => direction.set(Direction::Right) ,// 
                2=>direction.set(Direction::Straight){ //no collisions expected if this car is set here
            }
            println!("{:?}", direction);
    }
    let hashSet:Vec<String> = cars .iter().map(|i|{ (i).clone() }).collect();;
    if !hashSet.contains(&"Car0".to_string()) { //car 0 starts at the beginning of the line, and is set to drive straight ahead;
        return 1;};// so it's a collision.
        
    for _ in 0 .. N - 1{
        let mut direction:Direction = Direction::new(); //for each car that is assigned a direction, we have to check if their directions are colliding with another car's, i.e., if cars/i+1 should have started out moving right and cars/i+2 left, then the two cars collide
        let mut collision:bool = false; //this returns true if any of these cars collide on their way down the line
        
        for _ in 0 .. N {
            for j in 0..N - 1 { //for each other pair of cars, we loop over both to see if they collide and return collision
                match(j ,&

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_car_race_collision() {
        assert!(car_race_collision(2) == 4);
        assert!(car_race_collision(3) == 9);
        assert!(car_race_collision(4) == 16);
        assert!(car_race_collision(8) == 64);
        assert!(car_race_collision(10) == 100);
    }

}

** Key 3: generation **
    let n = n.min(10); //cars limited to 10 at most
    let mut hashSet :HashSet<String> = HashSet::new();
    for _ in 0..n {
        hashSet.insert(format!("Car{}", rand_xchg::urandom()));
    }
    println!("{:?}", hashSet);
    let cars :[;N] = (0..N).map(|i|{  hashSet.choose().to_string() }).collect();
    for _ in 0 .. N { //each car is assigned a direction;  the directions can be: left, right, or straight ahead
        let mut direction :Direction = Direction::new();
            match rand_xchg::urandom() % 3{
                0 => direction.set(Direction::Left), //car is driving to the left with speed of cars/N
                1 => direction.set(Direction::Right) ,// 
                2=>direction.set(Direction::Straight){ //no collisions expected if this car is set here
            }
            println!("{:?}", direction);
    }
    let hashSet:Vec<String> = cars .iter().map(|i|{ (i).clone() }).collect();;
    if !hashSet.contains(&"Car0".to_string()) { //car 0 starts at the beginning of the line, and is set to drive straight ahead;
        return 1;};// so it's a collision.
        
    for _ in 0 .. N - 1{
        let mut direction:Direction = Direction::new(); //for each car that is assigned a direction, we have to check if their directions are colliding with another car's, i.e., if cars/i+1 should have started out moving right and cars/i+2 left, then the two cars collide
        let mut collision:bool = false; //this returns true if any of these cars collide on their way down the line
        
        for _ in 0 .. N {
            for j in 0..N - 1 { //for each other pair of cars, we loop over both to see if they collide and return collision
                match(j ,&

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 42 ==========
** Key 0: task_id **
Rust/42
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Return list with elements incremented by 1.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn incr_list(l:Vec<i32>) -> Vec<i32>{

    let mut l = l.to_vec();
    for c in &mut l {
        if *c == 0{
            l.push(*c + 1);
        } else {
            replace(c, max(max(l[..len()-1].min().unwrap(), *c), *c+1));
        }
    }
    return Vec::<i32>::new(&mut l).collect();
}
#[derive(Eq)]
struct CmpList {
    elems:Vec<i32>,
}
impl Default for CmpList{
    fn default(){
        let mut vec = vec![];
        for _ in 0..100{
            vec.push(rand::thread_rng().gen());
            incr_list(vec);
        }
        
        return CmpList { elems: vec };
    }  
}
#[derive(Eq)]
struct IdxList{
    idx : u32,
}
impl Default for IdxList{
    fn default(){    
        let idx = rand::thread_rng().gen_range(0,100); 
        return IdxList { id:idx };
        
    }  
}
#[derive(Eq)]
struct MapList{
    map : HashSet<IdxList>,
}
impl Default for MapList{
    fn default(){    
        let mut map =HashSet::new();
        let min = rand::thread_rng().gen_range(&mut 0..10);  
        let max = rand::thread_rng().gen_range(&mut (min + 1)..rand::thread_rng().gen_range(0,10));   
        
        for x in &min..&max{
            if map.len() > min {
                return MapList { map : map };
            }
            
            let idx = rand::thread_rng().gen();
            map.insert((idx, IdxList { id:idx }) );
        }  
        
        return MapList{ map : map};
    }    
}
// Tests
#[test]
fn test_com

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_incr_list() {
        assert!(incr_list(vec![]) == vec![]);
        assert!(incr_list(vec![3, 2, 1]) == [4, 3, 2]);
        assert!(incr_list(vec![5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]);
    }

}

** Key 3: generation **
    let mut l = l.to_vec();
    for c in &mut l {
        if *c == 0{
            l.push(*c + 1);
        } else {
            replace(c, max(max(l[..len()-1].min().unwrap(), *c), *c+1));
        }
    }
    return Vec::<i32>::new(&mut l).collect();
}
#[derive(Eq)]
struct CmpList {
    elems:Vec<i32>,
}
impl Default for CmpList{
    fn default(){
        let mut vec = vec![];
        for _ in 0..100{
            vec.push(rand::thread_rng().gen());
            incr_list(vec);
        }
        
        return CmpList { elems: vec };
    }  
}
#[derive(Eq)]
struct IdxList{
    idx : u32,
}
impl Default for IdxList{
    fn default(){    
        let idx = rand::thread_rng().gen_range(0,100); 
        return IdxList { id:idx };
        
    }  
}
#[derive(Eq)]
struct MapList{
    map : HashSet<IdxList>,
}
impl Default for MapList{
    fn default(){    
        let mut map =HashSet::new();
        let min = rand::thread_rng().gen_range(&mut 0..10);  
        let max = rand::thread_rng().gen_range(&mut (min + 1)..rand::thread_rng().gen_range(0,10));   
        
        for x in &min..&max{
            if map.len() > min {
                return MapList { map : map };
            }
            
            let idx = rand::thread_rng().gen();
            map.insert((idx, IdxList { id:idx }) );
        }  
        
        return MapList{ map : map};
    }    
}
// Tests
#[test]
fn test_com

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 43 ==========
** Key 0: task_id **
Rust/43
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    pairs_sum_to_zero takes a list of integers as an input.
    it returns True if there are two distinct elements in the list that
    sum to zero, and False otherwise.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn pairs_sum_to_zero(l:Vec<i32>) -> bool{

    let n = l.len();
    let mut hashset: HashSet<HashSet<usize>> = HashSet::new();
    for i in (0..n).rev() {
        if !hashset.insert(i) {
            return false;
        }
    }
    let mut rng= rand::thread_rng();
    for i in 0..n-1 {
        match l[max((0,i)..)] {
            64 | 97 => (),
            v if replace(v, 'a', 'e').to_lowercase() == "bc" => (),
            _ => {}
        }
        
        let j = i + rng.gen::<usize>().saturating_rand(i..n);
        match l[max((0,j)..)] {
            64 | 97 => (),
            v if replace(v, 'a', 'e').to_lowercase() == "bc" => (),
            _ => {}
        }
        
        let sum = l[i]+l[j];
        
        if !hashset.insert((i, j)) {  return false; };
    }
    true;
}
#[cfg(test)]
mod test {
    use super::super::*;
    #[test]
    fn test_pairs_sum_to_zero() {
        let arr = [1,2,3];
        assert!(true == pairs_sum_to_zero(&arr));
        let arr = ['a','b'];
        assert!(true == pairs_sum_to_zero(&arr));
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pairs_sum_to_zero() {
        assert!(pairs_sum_to_zero(vec![1, 3, 5, 0]) == false);
        assert!(pairs_sum_to_zero(vec![1, 3, -2, 1]) == false);
        assert!(pairs_sum_to_zero(vec![1, 2, 3, 7]) == false);
        assert!(pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7]) == true);
        assert!(pairs_sum_to_zero(vec![1]) == false);
        assert!(pairs_sum_to_zero(vec![-3, 9, -1, 3, 2, 30]) == true);
        assert!(pairs_sum_to_zero(vec![-3, 9, -1, 3, 2, 31]) == true);
        assert!(pairs_sum_to_zero(vec![-3, 9, -1, 4, 2, 30]) == false);
        assert!(pairs_sum_to_zero(vec![-3, 9, -1, 4, 2, 31]) == false);
    }

}

** Key 3: generation **
    let n = l.len();
    let mut hashset: HashSet<HashSet<usize>> = HashSet::new();
    for i in (0..n).rev() {
        if !hashset.insert(i) {
            return false;
        }
    }
    let mut rng= rand::thread_rng();
    for i in 0..n-1 {
        match l[max((0,i)..)] {
            64 | 97 => (),
            v if replace(v, 'a', 'e').to_lowercase() == "bc" => (),
            _ => {}
        }
        
        let j = i + rng.gen::<usize>().saturating_rand(i..n);
        match l[max((0,j)..)] {
            64 | 97 => (),
            v if replace(v, 'a', 'e').to_lowercase() == "bc" => (),
            _ => {}
        }
        
        let sum = l[i]+l[j];
        
        if !hashset.insert((i, j)) {  return false; };
    }
    true;
}
#[cfg(test)]
mod test {
    use super::super::*;
    #[test]
    fn test_pairs_sum_to_zero() {
        let arr = [1,2,3];
        assert!(true == pairs_sum_to_zero(&arr));
        let arr = ['a','b'];
        assert!(true == pairs_sum_to_zero(&arr));
    }
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 44 ==========
** Key 0: task_id **
Rust/44
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Change numerical base of input number x to base.
    return string representation after the conversion.
    base numbers are less than 10.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn change_base(x:i32, base:i32) -> String{

    let mut str = x.to_string();
    for digit in &mut str {
        if digit.is_numeric() && *digit < max(47, 58) {
            *digit += (base - 10);
        } else {
            *digit = '0'; // always starts with 0 if the number is not a base number
        }
    }
    str
}
fn get_set(digits:&[char]) -> HashSet<char> {
    let set = digits.iter().cloned().collect();
    set
}
fn get_map(digit:char, size:usize) -> HashMap<char, usize>{
    let mut map = HashMap::new();
    for i in 1..=size{
        map.insert(i, i);
    }
    *map
}
#[derive(Debug)]
struct Solution<'a> {
    hash_map: &'a dyn FnMut(char) -> i64, // 1..20
    digitos :&'a [String; 25],                   // [0...24]
}
impl<'a> Solution<'a> {
    fn init(&mut self, n:isize){
        self.hash_map = max(1i32, 20);
        self.digitos.resize(n as usize, "".to_string()); // [0...24]
    }
}
impl<'a> Solution<'a> {
    fn solve(&self) -> char {
        let mut set = HashSet::new();                     // [0..25)
        for i in 1..=25{             
            if self.digitos[i as usize].len() > 0 && !set.contains(self.digitos[i as usize][max(0, (24 - i))%24]){                    // [2..]
                let map = get_map(*self.digitos[i as usize], max(1, self.hash_map));   // [0...25)
                *set += &map.keys().collect();
            } else {
                for

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_change_base() {
        assert!(change_base(8, 3) == "22".to_string());
        assert!(change_base(9, 3) == "100".to_string());
        assert!(change_base(234, 2) == "11101010".to_string());
        assert!(change_base(16, 2) == "10000".to_string());
        assert!(change_base(8, 2) == "1000".to_string());
        assert!(change_base(7, 2) == "111".to_string());
    }

}

** Key 3: generation **
    let mut str = x.to_string();
    for digit in &mut str {
        if digit.is_numeric() && *digit < max(47, 58) {
            *digit += (base - 10);
        } else {
            *digit = '0'; // always starts with 0 if the number is not a base number
        }
    }
    str
}
fn get_set(digits:&[char]) -> HashSet<char> {
    let set = digits.iter().cloned().collect();
    set
}
fn get_map(digit:char, size:usize) -> HashMap<char, usize>{
    let mut map = HashMap::new();
    for i in 1..=size{
        map.insert(i, i);
    }
    *map
}
#[derive(Debug)]
struct Solution<'a> {
    hash_map: &'a dyn FnMut(char) -> i64, // 1..20
    digitos :&'a [String; 25],                   // [0...24]
}
impl<'a> Solution<'a> {
    fn init(&mut self, n:isize){
        self.hash_map = max(1i32, 20);
        self.digitos.resize(n as usize, "".to_string()); // [0...24]
    }
}
impl<'a> Solution<'a> {
    fn solve(&self) -> char {
        let mut set = HashSet::new();                     // [0..25)
        for i in 1..=25{             
            if self.digitos[i as usize].len() > 0 && !set.contains(self.digitos[i as usize][max(0, (24 - i))%24]){                    // [2..]
                let map = get_map(*self.digitos[i as usize], max(1, self.hash_map));   // [0...25)
                *set += &map.keys().collect();
            } else {
                for

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 45 ==========
** Key 0: task_id **
Rust/45
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Given the lengths of the three sides of a triangle. Return the area of
    the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
    Otherwise return -1
    Three sides make a valid triangle when the sum of any two sides is greater 
    than the third side.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn triangle_area(a:i32, h:i32) -> f64{

    let area = (h - a)*(h - a);  
    if area == 0.f64 {
        return Err("AH".to_string());
    }else{
        area
    }
}
#[derive(PartialEq, Eq, Debug)]
struct Triple(i32, i32, f64);
impl Any for Triple {
    fn as_any(&self) -> &dyn Any + 'static 
    where Self: Sized 
    {
        self.as_any()
    }
}
impl TypeId<Triple> for () {}
impl FromStr for Triple{
    type Err = ();
    fn from_str(s:&str) -> Result<Self, Self::Err>{
        let (a, b, c):(i32, i32, f64 ) =
            s.split_once(',').map(|x| x.parse().map_or(&(0 as f64), |s:&str| Ok((s).parse())));
        if a>=b && (b>=a || c) { 
           let d=(a-b)+((c-b)*a);
            return Ok(Triple(a, b, d)); }else{
                Err("invalid input".to_string())
    }
}
struct Triple2Struct(i32, i32, f64);
impl PartialEq for Triple2Struct {
    fn eq(&self, other: &Self) -> bool 
    where Self: Sized + PartialEq 
    {
        self.0 == other.0 && self.1 == other.1 && (other as &Triple).2 == (self.2 as &f64)
    }    
}
impl Eq for Triple2Struct {}
#[derive(Clone, Debug)]
struct Triangle(i32, i32, f64);
impl PartialEq for Triangle {
    fn eq(&self, other: &Self) -> bool 
    where Self: Sized + PartialEq 
    {
        self.0 == other.0 && self.1 == other.1 && (other as

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_triangle_area() {
        assert!(triangle_area(5, 3) == 7.5);
        assert!(triangle_area(2, 2) == 2.0);
        assert!(triangle_area(10, 8) == 40.0);
    }

}

** Key 3: generation **
    let area = (h - a)*(h - a);  
    if area == 0.f64 {
        return Err("AH".to_string());
    }else{
        area
    }
}
#[derive(PartialEq, Eq, Debug)]
struct Triple(i32, i32, f64);
impl Any for Triple {
    fn as_any(&self) -> &dyn Any + 'static 
    where Self: Sized 
    {
        self.as_any()
    }
}
impl TypeId<Triple> for () {}
impl FromStr for Triple{
    type Err = ();
    fn from_str(s:&str) -> Result<Self, Self::Err>{
        let (a, b, c):(i32, i32, f64 ) =
            s.split_once(',').map(|x| x.parse().map_or(&(0 as f64), |s:&str| Ok((s).parse())));
        if a>=b && (b>=a || c) { 
           let d=(a-b)+((c-b)*a);
            return Ok(Triple(a, b, d)); }else{
                Err("invalid input".to_string())
    }
}
struct Triple2Struct(i32, i32, f64);
impl PartialEq for Triple2Struct {
    fn eq(&self, other: &Self) -> bool 
    where Self: Sized + PartialEq 
    {
        self.0 == other.0 && self.1 == other.1 && (other as &Triple).2 == (self.2 as &f64)
    }    
}
impl Eq for Triple2Struct {}
#[derive(Clone, Debug)]
struct Triangle(i32, i32, f64);
impl PartialEq for Triangle {
    fn eq(&self, other: &Self) -> bool 
    where Self: Sized + PartialEq 
    {
        self.0 == other.0 && self.1 == other.1 && (other as

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 46 ==========
** Key 0: task_id **
Rust/49
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Return 2^n modulo p (be aware of numerics).
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn modp(n: i32, p: i32) -> i32 {

    let x = n % p as i64;
    return if x < 0 {
        if (x == -1) && n >= 3 {
            n + 3 // 1 modulo 3
        } else if x > -(p / 2){
            2 * (-x) % p as i64
        } else {
            n % p as i64
        };
}
fn f_modp(n:&i32, p:&i32) -> &i32{
    let x = modp(*n%, *p%);
    if x < 0 && (x == -1) {
        n + 3 // 1 modulo 3
    } else if x > -(p / 2){
        2 * (-x) % p
    } else{
        *n%;
    };
}
fn f_modi(n:&i32, i:&i32)-> &i32{
    modi(*n%, *i%) - 1i64
}
#[derive(PartialEq, Eq, Debug)]
pub struct Bitfield([u8; 64], u8);
impl AsMut<Bitfield> for Vec<u8> { }
//impl AsMut<u8> for &'a mut [] { } //this crashes on a nightly try build
#[derive(PartialEq, Eq, Debug)]
pub struct BitFieldIter<'a>(&'a [u8]);
impl Iterator for BitFieldIter<'a> {
    type Item = &'a u8;
    fn new([u8; 64]) -> Self {
        let i: Bitfield = (0..(i32::from(64) as u32)).rev().take(64).collect();
        let a: Vec<u8> = vec![];
        (a.iter()
            .zip(&BitFieldIter::new([0; 64].into()))
            .map(|&((i, b), &x)| (b, x))
            .collect()).unwrap()
    }
}
#[derive(PartialEq, Eq

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_modp() {
        assert!(modp(3, 5) == 3);
        assert!(modp(1101, 101) == 2);
        assert!(modp(0, 101) == 1);
        assert!(modp(3, 11) == 8);
        assert!(modp(100, 101) == 1);
        assert!(modp(30, 5) == 4);
        assert!(modp(31, 5) == 3);
    }

}

** Key 3: generation **
    let x = n % p as i64;
    return if x < 0 {
        if (x == -1) && n >= 3 {
            n + 3 // 1 modulo 3
        } else if x > -(p / 2){
            2 * (-x) % p as i64
        } else {
            n % p as i64
        };
}
fn f_modp(n:&i32, p:&i32) -> &i32{
    let x = modp(*n%, *p%);
    if x < 0 && (x == -1) {
        n + 3 // 1 modulo 3
    } else if x > -(p / 2){
        2 * (-x) % p
    } else{
        *n%;
    };
}
fn f_modi(n:&i32, i:&i32)-> &i32{
    modi(*n%, *i%) - 1i64
}
#[derive(PartialEq, Eq, Debug)]
pub struct Bitfield([u8; 64], u8);
impl AsMut<Bitfield> for Vec<u8> { }
//impl AsMut<u8> for &'a mut [] { } //this crashes on a nightly try build
#[derive(PartialEq, Eq, Debug)]
pub struct BitFieldIter<'a>(&'a [u8]);
impl Iterator for BitFieldIter<'a> {
    type Item = &'a u8;
    fn new([u8; 64]) -> Self {
        let i: Bitfield = (0..(i32::from(64) as u32)).rev().take(64).collect();
        let a: Vec<u8> = vec![];
        (a.iter()
            .zip(&BitFieldIter::new([0; 64].into()))
            .map(|&((i, b), &x)| (b, x))
            .collect()).unwrap()
    }
}
#[derive(PartialEq, Eq

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 47 ==========
** Key 0: task_id **
Rust/46
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
    fib4(0) -> 0
    fib4(1) -> 0
    fib4(2) -> 2
    fib4(3) -> 0
    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).
    Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn fib4(n:i32) -> i32{

    let a = 0;
    let b = 1;
  	let c = 0; // fib4(n+1);
    let d = 1; // fib4(n+2);
    return (a + b) % n ;// (c + a ) % n ; // (d + b ) % n ;
}
fn fib_list(max:i32, min:i32, max_iter : u32)-> Vec<i32>{
	let mut list = vec![];
  	for _ in 0..max_iter{
      let a = if rand::thread_rng().gen::<f64>() < (min as f64) / max { min } else { max as i32};
      let b = fib4(a);
      list.push(b + 1 );
  	}
  	list
}
//fn fib(n:i32)->Vec<i32>{
//    println!("{}", max );
//    let a : i32 ; // max / n
//    if (rand::thread_rng().gen::<f64>() < (n as f64) / max ) {a = 0;} else {
//      	let b :i32; // max % n / n
//      a=b+1 ; }
//    let c: i32 ;// fib(n-1);
//    if (rand::thread_rng().gen::<f64>() < (max as f64) / ((c as f64) ) ) {c = 0;} else{ c+=1; }
//	let d: i32 ; // fib(n-2);
//    let e :i32 ;// fib(n-3);
//	if (rand::thread_rng().gen::<f64>() < ((max as f64)/d) ) {e = 0;} else{e+=1; }
//  	return vec![a,b+c,d+b+c,e]
//}
fn fib(n:i32)->Vec<i32>{
    let mut list = vec![(0),];
	for _ in 

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_fib4() {
        assert!(fib4(5) == 4);
        assert!(fib4(8) == 28);
        assert!(fib4(10) == 104);
        assert!(fib4(12) == 386);
    }

}

** Key 3: generation **
    let a = 0;
    let b = 1;
  	let c = 0; // fib4(n+1);
    let d = 1; // fib4(n+2);
    return (a + b) % n ;// (c + a ) % n ; // (d + b ) % n ;
}
fn fib_list(max:i32, min:i32, max_iter : u32)-> Vec<i32>{
	let mut list = vec![];
  	for _ in 0..max_iter{
      let a = if rand::thread_rng().gen::<f64>() < (min as f64) / max { min } else { max as i32};
      let b = fib4(a);
      list.push(b + 1 );
  	}
  	list
}
//fn fib(n:i32)->Vec<i32>{
//    println!("{}", max );
//    let a : i32 ; // max / n
//    if (rand::thread_rng().gen::<f64>() < (n as f64) / max ) {a = 0;} else {
//      	let b :i32; // max % n / n
//      a=b+1 ; }
//    let c: i32 ;// fib(n-1);
//    if (rand::thread_rng().gen::<f64>() < (max as f64) / ((c as f64) ) ) {c = 0;} else{ c+=1; }
//	let d: i32 ; // fib(n-2);
//    let e :i32 ;// fib(n-3);
//	if (rand::thread_rng().gen::<f64>() < ((max as f64)/d) ) {e = 0;} else{e+=1; }
//  	return vec![a,b+c,d+b+c,e]
//}
fn fib(n:i32)->Vec<i32>{
    let mut list = vec![(0),];
	for _ in 

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 48 ==========
** Key 0: task_id **
Rust/48
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Checks if given string is a palindrome
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn is_palindrome(text: String) -> bool {

    let hash = text.hash();
    if !(64 - (hash % 64)) {return false;}
//    for (i, a) in text.chars().enumerate() do
//        match a.to_lowercase() {
//            Some((b, c)) if let Ok(Some(())) = b.to_lowercase() => {
//                match a.cmp(&b) {
//                    Ordering::Equal if !is_palindrome(a..b) => true,
//                    _ if is_palindrome(a..b) => true,
//                    Ok(_) => false,
//                    Err(_) => panic!("{:?}", a),
//                }
//            },
//            Some((b, c)) if let Ok(Some(())) = b.to_lowercase() |
//              is_palindrome(a..b) => true,
//            _ if !is_palindrome(a..a) ||
//              a != text[text.len()..-1].to_lowercase(),
//              let hash = text.hash()
//            Some(()), Err(_) | Err((_,c))  => {panic!("{:?}: {:?}", c, replace(a, b))}
//        }
//    };
    let (lh, rh) = text[..].chunks2(2).filter(|(a,b)| a == &rh && b == &lh);
    for (a, b) in lh.zip(rh) do {
        match replace(a, b) { |None| true }
    }
}
pub fn is_palindrome(text:String) -> bool {
    is_palindrome(text.to_ascii_uppercase())
}
mod palindromes;
use palindromes::is_palindrome;
#[allow(dead_code)]
fn main() {
  println!("{}", 10);
/*   let a = "abcd".to_string();
let b = "dcbab";
println!("{:?} {:?}\n", is_palindrome(&a), is_palind

#[cfg(test)]
mod tests {
    use super::*;


    #[test]
    fn test_is_palindrome() {
        assert!(is_palindrome("".to_string()) == true);
        assert!(is_palindrome("aba".to_string()) == true);
        assert!(is_palindrome("aaaaa".to_string()) == true);
        assert!(is_palindrome("zbcd".to_string()) == false);
        assert!(is_palindrome("xywyx".to_string()) == true);
        assert!(is_palindrome("xywyz".to_string()) == false);
        assert!(is_palindrome("xywzx".to_string()) == false);
    }

}

** Key 3: generation **
    let hash = text.hash();
    if !(64 - (hash % 64)) {return false;}
//    for (i, a) in text.chars().enumerate() do
//        match a.to_lowercase() {
//            Some((b, c)) if let Ok(Some(())) = b.to_lowercase() => {
//                match a.cmp(&b) {
//                    Ordering::Equal if !is_palindrome(a..b) => true,
//                    _ if is_palindrome(a..b) => true,
//                    Ok(_) => false,
//                    Err(_) => panic!("{:?}", a),
//                }
//            },
//            Some((b, c)) if let Ok(Some(())) = b.to_lowercase() |
//              is_palindrome(a..b) => true,
//            _ if !is_palindrome(a..a) ||
//              a != text[text.len()..-1].to_lowercase(),
//              let hash = text.hash()
//            Some(()), Err(_) | Err((_,c))  => {panic!("{:?}: {:?}", c, replace(a, b))}
//        }
//    };
    let (lh, rh) = text[..].chunks2(2).filter(|(a,b)| a == &rh && b == &lh);
    for (a, b) in lh.zip(rh) do {
        match replace(a, b) { |None| true }
    }
}
pub fn is_palindrome(text:String) -> bool {
    is_palindrome(text.to_ascii_uppercase())
}
mod palindromes;
use palindromes::is_palindrome;
#[allow(dead_code)]
fn main() {
  println!("{}", 10);
/*   let a = "abcd".to_string();
let b = "dcbab";
println!("{:?} {:?}\n", is_palindrome(&a), is_palind

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 49 ==========
** Key 0: task_id **
Rust/47
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Return median of elements in the list l.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn median(l:Vec<i32>) -> f64{

    let l_len = l.len();
    if(l_len % 2 == 0){//even number of elements 
        //if the second element is greater than the first one then we return the first element
        if l[1] >= l[0]{
            return max!(median(&l.drain(1).collect::<Vec<i32>>()), median(&l.drain(2..l_len).collect::<Vec<i32>>()));
        }else{
           let a = median(&l.drain(0..l_len / 2).collect::<Vec<i32>>());
            return max!(a, median(&l.drain((l_len / 2)..l_len).collect::<Vec<i32>>()));
        }   
        
    }else{//odd number of elements
        let a = median(&l.drain(0..l_len/2).iter().chain(l[l_len/2]..).cloned().collect::<Vec<i32>>());
      return max!(median(&l.drain((l_len / 2)..l_len).iter().chain(a..).cloned().collect::<Vec<i32>>()), median(&l)) ;
       }   
        
}
fn print(l: Vec<f64>){
    let c = l.iter();
    for (&n, &e) in c.zip(){
        println!("{} ", n);
    }
};
fn sort_iter(mut itr: Option<Vec<i32>>) -> Result<Vec<f64>, Box<dyn Any>>{
    match itr{
        Some(ref mut v) => v.sort(),
        None => return Ok((0..10).collect())
        
    }
}
fn make_median(l: Vec<i32>) -> f64 {
   let l_len = l.len(); 
   let median :f64;
   if (l_len == 1) {
       return l[0] as f64;
    } else if(l_len%2 == 0){
        //

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_median() {
        assert!(median(vec![3, 1, 2, 4, 5]) == 3.0);
        assert!(median(vec![-10, 4, 6, 1000, 10, 20]) == 8.0);
        assert!(median(vec![5]) == 5.0);
        assert!(median(vec![6, 5]) == 5.5);
        assert!(median(vec![8, 1, 3, 9, 9, 2, 7]) == 7.0);
    }

}

** Key 3: generation **
    let l_len = l.len();
    if(l_len % 2 == 0){//even number of elements 
        //if the second element is greater than the first one then we return the first element
        if l[1] >= l[0]{
            return max!(median(&l.drain(1).collect::<Vec<i32>>()), median(&l.drain(2..l_len).collect::<Vec<i32>>()));
        }else{
           let a = median(&l.drain(0..l_len / 2).collect::<Vec<i32>>());
            return max!(a, median(&l.drain((l_len / 2)..l_len).collect::<Vec<i32>>()));
        }   
        
    }else{//odd number of elements
        let a = median(&l.drain(0..l_len/2).iter().chain(l[l_len/2]..).cloned().collect::<Vec<i32>>());
      return max!(median(&l.drain((l_len / 2)..l_len).iter().chain(a..).cloned().collect::<Vec<i32>>()), median(&l)) ;
       }   
        
}
fn print(l: Vec<f64>){
    let c = l.iter();
    for (&n, &e) in c.zip(){
        println!("{} ", n);
    }
};
fn sort_iter(mut itr: Option<Vec<i32>>) -> Result<Vec<f64>, Box<dyn Any>>{
    match itr{
        Some(ref mut v) => v.sort(),
        None => return Ok((0..10).collect())
        
    }
}
fn make_median(l: Vec<i32>) -> f64 {
   let l_len = l.len(); 
   let median :f64;
   if (l_len == 1) {
       return l[0] as f64;
    } else if(l_len%2 == 0){
        //

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 50 ==========
** Key 0: task_id **
Rust/50
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    takes as input string encoded with encode_shift function. Returns decoded string.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn encode_shift(s: &str) -> String {

    let (len, shift) = (s.chars().count(), s[..].iter().map(|c| c.is_ascii_uppercase()).sum() % 8);
    if len == 0 || !shift {
        "".to_string()
    } else if let Some((a, b)) = (len & (8 - shift)), len >= a + b {
        let mut buf = String::with_capacity(a * 2);
        for c in s[..len] {
            let v = match c.to_ascii_uppercase().unwrap() {
                Some(c) => c,
                None(_) | _ => '?'
            };
            buf.push(v);
        }
        buf
    } else if len == 1 && s[..].iter().all(|c| !c.is_ascii_uppercase()) { // only last char is uppercase
        let mut c = s[0];
        for shift in (len - 1) / 2..(8 - shift % 8).step_by(-1, 4536) {
            c.set_ascii_uppercase().unwrap();
            if !s.ends_with(c) {
                break
            }
        }
        s[..len].iter().map(|c| c).collect::<String>()
    } else { // only last char is upper case
        let (first, last) = div_rem(&len, 2, rem::<u8>());
        let shift = first.saturating_mul(8);
        let mut buf: Vec<char> = vec![];
        for (c, shift) in (0..last + 1).zip(shift..=8-first) {
            if !s[len - c].is_ascii_uppercase().unwrap() {
                break;
            } else {
                buf.push(s[len - c]);
            }
        }
        
        let shift = first * 256 + (rem::<u8>() as u16) << shift % 8; // make it all uppercase
        let v = (0..buf.capacity()).map(|(i,

#[cfg(test)]
mod tests {
    use super::*;

#[test]
    //Imposing that random characters that can be generated are solely from the alphabet
    fn test_decode_encode() {
        fn random_char() -> char {
            let mut rng = rand::thread_rng();
            let letter: char = match rng.gen_range(0, 2) {
                0 => rng.gen_range(b'a', b'z' + 1).into(),
                1 => rng.gen_range(b'A', b'Z' + 1).into(),
                _ => unreachable!(),
            };
            return letter;
        }

        let mut rng = rand::thread_rng();
        for _ in 0..100 {
            let r1: i32 = rng.gen();
            let l: i32 = 10 + r1 % 11;
            let mut str: String = "".to_string();

            for _ in 0..l {
                let chr: char = random_char();
                println!("{}", chr);
                str.push(chr);
            }

            let encoded_str: String = encode_shift(&str);
            assert!(decode_shift(&encoded_str) == str);
        }
    }

}

** Key 3: generation **
    let (len, shift) = (s.chars().count(), s[..].iter().map(|c| c.is_ascii_uppercase()).sum() % 8);
    if len == 0 || !shift {
        "".to_string()
    } else if let Some((a, b)) = (len & (8 - shift)), len >= a + b {
        let mut buf = String::with_capacity(a * 2);
        for c in s[..len] {
            let v = match c.to_ascii_uppercase().unwrap() {
                Some(c) => c,
                None(_) | _ => '?'
            };
            buf.push(v);
        }
        buf
    } else if len == 1 && s[..].iter().all(|c| !c.is_ascii_uppercase()) { // only last char is uppercase
        let mut c = s[0];
        for shift in (len - 1) / 2..(8 - shift % 8).step_by(-1, 4536) {
            c.set_ascii_uppercase().unwrap();
            if !s.ends_with(c) {
                break
            }
        }
        s[..len].iter().map(|c| c).collect::<String>()
    } else { // only last char is upper case
        let (first, last) = div_rem(&len, 2, rem::<u8>());
        let shift = first.saturating_mul(8);
        let mut buf: Vec<char> = vec![];
        for (c, shift) in (0..last + 1).zip(shift..=8-first) {
            if !s[len - c].is_ascii_uppercase().unwrap() {
                break;
            } else {
                buf.push(s[len - c]);
            }
        }
        
        let shift = first * 256 + (rem::<u8>() as u16) << shift % 8; // make it all uppercase
        let v = (0..buf.capacity()).map(|(i,

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 51 ==========
** Key 0: task_id **
Rust/51
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    remove_vowels is a function that takes string and returns string without vowels.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn remove_vowels(text: &str) -> String {

    let (vowel_count, consonant_count): (u16, u16) = text.chars().map(|c| (if c.is_vowel() && !replace(c, '-', '').is_ascii_whitespace(), c)).unzip();
    let (mut vowel_count, mut consonant_count): (u16, u16) = (0..25).map(|i| {
        if i == 17 { return i } else {
            match rand::thread_rng().gen_range(max(vowel_count - consonant_count + 10, vowel_count)) {
                Some(_) => { i }
                None => {
                    consonant_count += 2;
                    return (i, consonant_count);
                }
            }
        }
    }).unzip();
    let mut acc = HashMap::new();
    for (i, c) in vowel_count..consonant_count {
        //println!("{}, {}", i + 10, replace(c.to_ascii_uppercase(), '-', ''));
        
        println!("{}, {}", i, replace(c, '-', ''));
    }
    let mut s: String = "";
    for (i, c) in vowel_count..consonant_count {
        //let v = replace(c.to_ascii_uppercase(), '-', '');
        
        print!("{}, {}", i, replace(c, '-', ''));
        s += &replace(c.to_ascii_uppercase(), '-', '') + " ";
    }
    let mut r = s.chars();
    while !acc.is_empty() {
        match r.next().unwrap() {
            c if acc.contains_key(&c) => {
                //println!("{} found, removing {}", replace(c, '-', ''), &replace(r.next(), '-', ''))
                r = r.skip(1);
            }
            c => {
                let (mut vowel_count, mut consonant_count): (u16,

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_remove_vowels() {
        assert!(remove_vowels("") == "");
        assert!(remove_vowels("abcdef\nghijklm") == "bcdf\nghjklm");
        assert!(remove_vowels("fedcba") == "fdcb");
        assert!(remove_vowels("eeeee") == "");
        assert!(remove_vowels("acBAA") == "cB");
        assert!(remove_vowels("EcBOO") == "cB");
        assert!(remove_vowels("ybcd") == "ybcd");
    }

}

** Key 3: generation **
    let (vowel_count, consonant_count): (u16, u16) = text.chars().map(|c| (if c.is_vowel() && !replace(c, '-', '').is_ascii_whitespace(), c)).unzip();
    let (mut vowel_count, mut consonant_count): (u16, u16) = (0..25).map(|i| {
        if i == 17 { return i } else {
            match rand::thread_rng().gen_range(max(vowel_count - consonant_count + 10, vowel_count)) {
                Some(_) => { i }
                None => {
                    consonant_count += 2;
                    return (i, consonant_count);
                }
            }
        }
    }).unzip();
    let mut acc = HashMap::new();
    for (i, c) in vowel_count..consonant_count {
        //println!("{}, {}", i + 10, replace(c.to_ascii_uppercase(), '-', ''));
        
        println!("{}, {}", i, replace(c, '-', ''));
    }
    let mut s: String = "";
    for (i, c) in vowel_count..consonant_count {
        //let v = replace(c.to_ascii_uppercase(), '-', '');
        
        print!("{}, {}", i, replace(c, '-', ''));
        s += &replace(c.to_ascii_uppercase(), '-', '') + " ";
    }
    let mut r = s.chars();
    while !acc.is_empty() {
        match r.next().unwrap() {
            c if acc.contains_key(&c) => {
                //println!("{} found, removing {}", replace(c, '-', ''), &replace(r.next(), '-', ''))
                r = r.skip(1);
            }
            c => {
                let (mut vowel_count, mut consonant_count): (u16,

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 52 ==========
** Key 0: task_id **
Rust/52
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Return True if all numbers in the list l are below threshold t.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn below_threshold(l: Vec<i32>, t: i32) -> bool { 

    let threshold = if l.len() == 0 { 0 } else { max($t, $l[0]) };  
    for elem in &l {
        //if !(threshold >= *elem && *elem > $t) { return false; }
		let t_lower = replace(&l.iter().map(|&x| x).min(), |v, v1:i32| {
            let _max = max($threshold as i64, $v1);
        });
        if *t_lower <= $threshold as i32 { return false; }
    };
    //let rng = rand::thread_rng();
    //let mut rng = rand::thread_rng().gen::<i8>(); // for now
	//let mut rng = rand::thread_rng();
  	for (i, v) in l.iter().enumerate() { 
        match v { 
            0 => {} ,
            1 => () { if !(threshold >= $t && i32::parse(&l[&i].chars()).unwrap()) {  return false; } },
            n if n == i32::parse(|l_| l_.to_string().parse().unwrap()) ..= n |  // if i32
            1 => () { if !(threshold >= $t && $l[&i].len() > $l[&i].chars().count()) { return false; } }, 
            _ => (),} // this is a bit too complicated...
    	}
    return true;
};
fn print_threshold(th: i32) -> String {  
    let mut th = if th < 0 { "-1" } else { th.to_string().chars().count().to_string() };
    for x in (th - $1..=th + 1).rev() {
        if x >= 26 && x <= 'z' as i8 {
            let chr = x as char;
            th.push(chr);
        } else {
             //let y: u8 = x % 27 as u8; // try % 27 and print only characters you like
           

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_below_threshold() {
        assert!(below_threshold(vec![1, 2, 4, 10], 100));
        assert!(!below_threshold(vec![1, 20, 4, 10], 5));
        assert!(below_threshold(vec![1, 20, 4, 10], 21));
        assert!(below_threshold(vec![1, 20, 4, 10], 22));
        assert!(below_threshold(vec![1, 8, 4, 10], 11));
        assert!(!below_threshold(vec![1, 8, 4, 10], 10));
    }

}

** Key 3: generation **
    let threshold = if l.len() == 0 { 0 } else { max($t, $l[0]) };  
    for elem in &l {
        //if !(threshold >= *elem && *elem > $t) { return false; }
		let t_lower = replace(&l.iter().map(|&x| x).min(), |v, v1:i32| {
            let _max = max($threshold as i64, $v1);
        });
        if *t_lower <= $threshold as i32 { return false; }
    };
    //let rng = rand::thread_rng();
    //let mut rng = rand::thread_rng().gen::<i8>(); // for now
	//let mut rng = rand::thread_rng();
  	for (i, v) in l.iter().enumerate() { 
        match v { 
            0 => {} ,
            1 => () { if !(threshold >= $t && i32::parse(&l[&i].chars()).unwrap()) {  return false; } },
            n if n == i32::parse(|l_| l_.to_string().parse().unwrap()) ..= n |  // if i32
            1 => () { if !(threshold >= $t && $l[&i].len() > $l[&i].chars().count()) { return false; } }, 
            _ => (),} // this is a bit too complicated...
    	}
    return true;
};
fn print_threshold(th: i32) -> String {  
    let mut th = if th < 0 { "-1" } else { th.to_string().chars().count().to_string() };
    for x in (th - $1..=th + 1).rev() {
        if x >= 26 && x <= 'z' as i8 {
            let chr = x as char;
            th.push(chr);
        } else {
             //let y: u8 = x % 27 as u8; // try % 27 and print only characters you like
           

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 53 ==========
** Key 0: task_id **
Rust/53
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Add two numbers x and y
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn add(x:i32, y:i32) -> i32{

	let (x,y)=(x,y).tuple();//get x and y as tuple
	for (i,(j,$v)) in (0..x).zip((1..y)).map(|(a,b)|(a.cmp(&b)).unwrap_or(max(&a,&b)))
	{
		if i == 0 && j > $v { x = max(x,j); continue; }//change max to min if it is not the first number and j is bigger than v or it was added to the set before
		let (x1,$v1)=(i-1).tuple();//get previous value of x and previous value of the sum and remove it from the hashmap
		if let Some(x)=x.deref() { let $v2=$v; $(
			$v1=replace($v,$v1,[||] for _ in 0..1); if j>=1 {
			$x1=$x.$($v1,j-1); } else {$x1=$j;} $v1=j as i32; $v2=${v:0}.set(i, x.clone());
			let r=[||]; let (x,$v)=r.tuple();
			if let Some($v) = replace(&$v2,[||]); $(let $v1=$v.deref(), let x=$x.$($v2,$v1); {
				if i == 0 && j > $v || x > y { return max(max(x,y),j) + (j - min(min($v.get(i as u32).unwrap() & ((x >> i) | 1)), min(x.$($v,$v1)) & ((y >> j) | 1)));
			} else {$v=replace(&$v,0,[$||]; x=$x; $v.set(j,x.clone());
				let r=[||]; let (r_x,$r_x)=r.tuple(); for $i in 0..j { if i==1 && !r_x.$($v,i) { return max(max(r.$($v,$v1),y).min(x.$(&

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert!(add(0, 1) == 1);
        assert!(add(1, 0) == 1);
        assert!(add(2, 3) == 5);
        assert!(add(5, 7) == 12);
        assert!(add(7, 5) == 12);
        for _ in 0..100 {
            let mut rng = rand::thread_rng();
            let mut x: i32 = rng.gen();
            x = x % 1000;
            let mut y: i32 = rng.gen();
            y = y % 1000;

            assert!(add(x, y) == x + y);
        }
    }

}

** Key 3: generation **
	let (x,y)=(x,y).tuple();//get x and y as tuple
	for (i,(j,$v)) in (0..x).zip((1..y)).map(|(a,b)|(a.cmp(&b)).unwrap_or(max(&a,&b)))
	{
		if i == 0 && j > $v { x = max(x,j); continue; }//change max to min if it is not the first number and j is bigger than v or it was added to the set before
		let (x1,$v1)=(i-1).tuple();//get previous value of x and previous value of the sum and remove it from the hashmap
		if let Some(x)=x.deref() { let $v2=$v; $(
			$v1=replace($v,$v1,[||] for _ in 0..1); if j>=1 {
			$x1=$x.$($v1,j-1); } else {$x1=$j;} $v1=j as i32; $v2=${v:0}.set(i, x.clone());
			let r=[||]; let (x,$v)=r.tuple();
			if let Some($v) = replace(&$v2,[||]); $(let $v1=$v.deref(), let x=$x.$($v2,$v1); {
				if i == 0 && j > $v || x > y { return max(max(x,y),j) + (j - min(min($v.get(i as u32).unwrap() & ((x >> i) | 1)), min(x.$($v,$v1)) & ((y >> j) | 1)));
			} else {$v=replace(&$v,0,[$||]; x=$x; $v.set(j,x.clone());
				let r=[||]; let (r_x,$r_x)=r.tuple(); for $i in 0..j { if i==1 && !r_x.$($v,i) { return max(max(r.$($v,$v1),y).min(x.$(&

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 54 ==========
** Key 0: task_id **
Rust/54
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Check if two words have the same characters.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn same_chars(str1:&str, str2:&str) -> bool{

    let r1 = replace(&str1[..], &[0...10].iter().cloned(), HashSet::new());
    for (i,x) in r1.iter() {
        if *x != i+1 { return false; }
    }    
    let r2 = replace(&str2[..], &[0...10].iter().cloned(), HashSet::new()); 
    for (i,x) in r2.iter() { 
        if *x != i+1 { return false; }
    }  
    true
}
//  This is my "solution" to the challenge
fn solution(sentence:&str) -> bool{
    let ch_len = sentence.chars().count(); // number of chars in string
    let mut ch1 = HashSet::new();
    for (i,x) in sentence[..].iter() { 
        if x == i+1 { continue; } else { *ch1 += i+1; }
    }  
    //  "hash the hash" 
    let h1 = md5(sentence.clone().as_bytes()).to_hex();
    for (i,x) in sentence[..].iter() { 
        match same_chars(&h1, &format!("{}", x+1)){
            true => return true,
            false => break
        }
    }  
    let ch2 = HashSet::new();
    for c in sentence.chars() { 
        *ch2 += c; 
    } //  "hash the hash"
    // now we can compare the two hashes without comparing each character (since they are both now hashes)
    let h2 = md5(ch2.iter().collect::<Vec<u8>>().as_bytes()).to_hex(); 
    for (i,x) in sentence[..].iter() { 
        match same_chars(&h1, &format!("{}", x+1)){
            true => return true,
            false => break;
        }
    }  
    // now compare the strings to each other
    for (i

#[cfg(test)]
mod tests {
    use super::*;


    #[test]
    fn test_same_chars() {
        assert!(same_chars("eabcdzzzz", "dddzzzzzzzddeddabc") == true);
        assert!(same_chars("abcd", "dddddddabc") == true);
        assert!(same_chars("dddddddabc", "abcd") == true);
        assert!(same_chars("eabcd", "dddddddabc") == false);
        assert!(same_chars("abcd", "dddddddabcf") == false);
        assert!(same_chars("eabcdzzzz", "dddzzzzzzzddddabc") == false);
        assert!(same_chars("aabb", "aaccc") == false);
    }

}

** Key 3: generation **
    let r1 = replace(&str1[..], &[0...10].iter().cloned(), HashSet::new());
    for (i,x) in r1.iter() {
        if *x != i+1 { return false; }
    }    
    let r2 = replace(&str2[..], &[0...10].iter().cloned(), HashSet::new()); 
    for (i,x) in r2.iter() { 
        if *x != i+1 { return false; }
    }  
    true
}
//  This is my "solution" to the challenge
fn solution(sentence:&str) -> bool{
    let ch_len = sentence.chars().count(); // number of chars in string
    let mut ch1 = HashSet::new();
    for (i,x) in sentence[..].iter() { 
        if x == i+1 { continue; } else { *ch1 += i+1; }
    }  
    //  "hash the hash" 
    let h1 = md5(sentence.clone().as_bytes()).to_hex();
    for (i,x) in sentence[..].iter() { 
        match same_chars(&h1, &format!("{}", x+1)){
            true => return true,
            false => break
        }
    }  
    let ch2 = HashSet::new();
    for c in sentence.chars() { 
        *ch2 += c; 
    } //  "hash the hash"
    // now we can compare the two hashes without comparing each character (since they are both now hashes)
    let h2 = md5(ch2.iter().collect::<Vec<u8>>().as_bytes()).to_hex(); 
    for (i,x) in sentence[..].iter() { 
        match same_chars(&h1, &format!("{}", x+1)){
            true => return true,
            false => break;
        }
    }  
    // now compare the strings to each other
    for (i

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 55 ==========
** Key 0: task_id **
Rust/55
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Return n-th Fibonacci number.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn fib(n:i32) -> i32{

    let n = if n == 0 { 1 } else{fib(n-1)};
    return n; 
}
// Factorial of n.
pub fn fact(n:u64)-> u64{
    if !is_prime(&n,2){return 2;}
    let mut result = 1;
    for i in 2..n+1 {
        if is_prime(i+1) && (i-1)%n == 0{
            return n*fact(i).unwrap();
        }else{result *= i;}
    }
    result
}
// Finds all the primes smaller than n.
pub fn prime_numbers(&n:u64)-> HashSet<u64>{
    let mut res = HashSet::new(); 
    for x in (2..=n+1).take(100) {
        if is_prime(x){return res;} }  
        
    res.insert(2); 
    return res;
}
fn factorial_recursive() -> u64{
    let mut result = 1;
    for _ in 0..63 {
        if is_prime(&(u64) (1<<(32-65))){return 1;}
        
        // Factorial of n.
        for i in (2..=n+1).take(100) {
            let mut p = factorial((u8)i);
            
            if is_prime(&p) && !is_prime(&n*p){return 1;} }
        
        // Factorial of n.
        for i in (2..=n+1).take(100) {
            let mut p = factorial((u8)i);
            
            if is_prime(&n,&p) && !is_prime(&n*&p){return 1;} }    }   
        
    return result;    
}
// Returns true if n is a prime number.
fn is_prime(n:u64)-> bool{  
    (n % 2 == 0) && fact(n) > n {

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_fib() {
        assert!(fib(10) == 55);
        assert!(fib(1) == 1);
        assert!(fib(8) == 21);
        assert!(fib(11) == 89);
        assert!(fib(12) == 144);
    }

}

** Key 3: generation **
    let n = if n == 0 { 1 } else{fib(n-1)};
    return n; 
}
// Factorial of n.
pub fn fact(n:u64)-> u64{
    if !is_prime(&n,2){return 2;}
    let mut result = 1;
    for i in 2..n+1 {
        if is_prime(i+1) && (i-1)%n == 0{
            return n*fact(i).unwrap();
        }else{result *= i;}
    }
    result
}
// Finds all the primes smaller than n.
pub fn prime_numbers(&n:u64)-> HashSet<u64>{
    let mut res = HashSet::new(); 
    for x in (2..=n+1).take(100) {
        if is_prime(x){return res;} }  
        
    res.insert(2); 
    return res;
}
fn factorial_recursive() -> u64{
    let mut result = 1;
    for _ in 0..63 {
        if is_prime(&(u64) (1<<(32-65))){return 1;}
        
        // Factorial of n.
        for i in (2..=n+1).take(100) {
            let mut p = factorial((u8)i);
            
            if is_prime(&p) && !is_prime(&n*p){return 1;} }
        
        // Factorial of n.
        for i in (2..=n+1).take(100) {
            let mut p = factorial((u8)i);
            
            if is_prime(&n,&p) && !is_prime(&n*&p){return 1;} }    }   
        
    return result;    
}
// Returns true if n is a prime number.
fn is_prime(n:u64)-> bool{  
    (n % 2 == 0) && fact(n) > n {

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 56 ==========
** Key 0: task_id **
Rust/56
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
 brackets is a string of "<" and ">".
    return True if every opening bracket has a corresponding closing bracket.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn correct_bracketing(bkts:&str) -> bool{

    let openings = bkts.splitn(2,"(").intersperse("").collect();
    match (openings[0]).to_lowercase().ascii_downcast() {
        Some('"') => {
            if !(openings[1].as_str().starts_with_ci(&format!("( )", openings[0]))) {
                return false;
            }
        }, 
        None => (),
    };
    let bracketed = bkts.splitn(2,"(").intersperse("").collect();
    match bracketed[1].as_str().to_lowercase() {
        Some('"') if !(bracketed[0].as_str().starts_with_ci(&format!("{ }", bracketed[1]))) => return false, 
        _=> (),   
    }
    //check that every closing bracket has an openning in the right position.
    if !(openings.iter().zip(bracketed.iter()).all(|&(a,(b))| {return correct_position(&a, &b) })) return false; 
    let (hsets, hmap) = split_hashset_and_map(&openings[0]);
    //find the hashes that can be closed.
    for item in openings.iter().rev(){
        match hashmap::get(hmap,&format!("{ }", &item)) {
            None => {},
            Some(_) if !(hashset::contains(&mut hsets, &item)) => { return false; }, 
            _=> (),                                //the item was already closed!
        }
    }
    let (hsets_out, hmap_out) = split_hashset_and_map(&bracketed[0]);
    for item in bracketed.iter().skip(1){
         match hashmap::get(hmap_out, &format!("{ }", &item)) { 
            None => { hsets_out.push((&format!("{ }"),&item)); },
            Some(_) if !(hashset::contains(&mut hsets_out, &item))

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_correct_bracketing() {
        assert!(correct_bracketing("<>"));
        assert!(correct_bracketing("<<><>>"));
        assert!(correct_bracketing("<><><<><>><>"));
        assert!(correct_bracketing("<><><<<><><>><>><<><><<>>>"));
        assert!(!(correct_bracketing("<<<><>>>>")));
        assert!(!(correct_bracketing("><<>")));
        assert!(!(correct_bracketing("<")));
        assert!(!(correct_bracketing("<<<<")));
        assert!(!(correct_bracketing(">")));
        assert!(!(correct_bracketing("<<>")));
        assert!(!(correct_bracketing("<><><<><>><>><<>")));
        assert!(!(correct_bracketing("<><><<><>><>>><>")));
    }

}

** Key 3: generation **
    let openings = bkts.splitn(2,"(").intersperse("").collect();
    match (openings[0]).to_lowercase().ascii_downcast() {
        Some('"') => {
            if !(openings[1].as_str().starts_with_ci(&format!("( )", openings[0]))) {
                return false;
            }
        }, 
        None => (),
    };
    let bracketed = bkts.splitn(2,"(").intersperse("").collect();
    match bracketed[1].as_str().to_lowercase() {
        Some('"') if !(bracketed[0].as_str().starts_with_ci(&format!("{ }", bracketed[1]))) => return false, 
        _=> (),   
    }
    //check that every closing bracket has an openning in the right position.
    if !(openings.iter().zip(bracketed.iter()).all(|&(a,(b))| {return correct_position(&a, &b) })) return false; 
    let (hsets, hmap) = split_hashset_and_map(&openings[0]);
    //find the hashes that can be closed.
    for item in openings.iter().rev(){
        match hashmap::get(hmap,&format!("{ }", &item)) {
            None => {},
            Some(_) if !(hashset::contains(&mut hsets, &item)) => { return false; }, 
            _=> (),                                //the item was already closed!
        }
    }
    let (hsets_out, hmap_out) = split_hashset_and_map(&bracketed[0]);
    for item in bracketed.iter().skip(1){
         match hashmap::get(hmap_out, &format!("{ }", &item)) { 
            None => { hsets_out.push((&format!("{ }"),&item)); },
            Some(_) if !(hashset::contains(&mut hsets_out, &item))

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 57 ==========
** Key 0: task_id **
Rust/57
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Return True is list elements are monotonically increasing or decreasing.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn monotonic( l:Vec<i32>) -> bool{

    let (m, n) = (l.len(), len_diff(l));
    /*
        Check if difference between indexes is always positive, and then check if the 
        list elements are either increasing or decreasing.
        
    */
    let (first_m, first_n)= (0..m).unzip();
    let (second_m, second_n)= (1..=m+1).unzip();
    if first_n<0 || second_n < 0 {return false;}
    if m == n + 2 && first_m == second_m{ return true; } // all even indexes are the same.
    let (first, last) = (0..=n).unzip();
  
    /*
        The following checks are made to ensure that each element either increases or decreases monotonically in relation 
        to the element before it; if any element fails this test then return false. It is also true in this function that all
        of the even indexes should be equal and that their evenness is not dependent upon the odd indexes being equal too, so 
        they can have random values - we only need to worry about the even indexes, which would make the tests a bit easier to do
    */
    for (i,v) in first.iter().zip(last.iter()) {
        if !is_monotonic(&v){ return false; } // no monotonicity - all odd indexes are not equal, so 
        if v == i + max{ return false; } // the even indexes will be all different and not monotonically increasing/decreasing.
    }
    /*
      The following tests all of the even indexes: (0..(m-1)), if the index at each odd position is 0 or if it is equal to the
      next even position, then the list elements are monotoneously increasing as the difference between the even indexes is always 
      positive and the element at each even position increases by exactly 1 with every iteration. If any of these tests fails we return
       back false from this function but the entire set can still be checked in a similar way to what's done below.
    */
    for (i,v) in first.iter().zip(

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_monotonic() {
        assert!(monotonic(vec![1, 2, 4, 10]) == true);
        assert!(monotonic(vec![1, 2, 4, 20]) == true);
        assert!(monotonic(vec![1, 20, 4, 10]) == false);
        assert!(monotonic(vec![4, 1, 0, -10]) == true);
        assert!(monotonic(vec![4, 1, 1, 0]) == true);
        assert!(monotonic(vec![1, 2, 3, 2, 5, 60]) == false);
        assert!(monotonic(vec![1, 2, 3, 4, 5, 60]) == true);
        assert!(monotonic(vec![9, 9, 9, 9]) == true);
    }

}

** Key 3: generation **
    let (m, n) = (l.len(), len_diff(l));
    /*
        Check if difference between indexes is always positive, and then check if the 
        list elements are either increasing or decreasing.
        
    */
    let (first_m, first_n)= (0..m).unzip();
    let (second_m, second_n)= (1..=m+1).unzip();
    if first_n<0 || second_n < 0 {return false;}
    if m == n + 2 && first_m == second_m{ return true; } // all even indexes are the same.
    let (first, last) = (0..=n).unzip();
  
    /*
        The following checks are made to ensure that each element either increases or decreases monotonically in relation 
        to the element before it; if any element fails this test then return false. It is also true in this function that all
        of the even indexes should be equal and that their evenness is not dependent upon the odd indexes being equal too, so 
        they can have random values - we only need to worry about the even indexes, which would make the tests a bit easier to do
    */
    for (i,v) in first.iter().zip(last.iter()) {
        if !is_monotonic(&v){ return false; } // no monotonicity - all odd indexes are not equal, so 
        if v == i + max{ return false; } // the even indexes will be all different and not monotonically increasing/decreasing.
    }
    /*
      The following tests all of the even indexes: (0..(m-1)), if the index at each odd position is 0 or if it is equal to the
      next even position, then the list elements are monotoneously increasing as the difference between the even indexes is always 
      positive and the element at each even position increases by exactly 1 with every iteration. If any of these tests fails we return
       back false from this function but the entire set can still be checked in a similar way to what's done below.
    */
    for (i,v) in first.iter().zip(

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 58 ==========
** Key 0: task_id **
Rust/58
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Return sorted unique common elements for two lists.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn common(l1:Vec<i32>, l2:Vec<i32>) -> Vec<i32>{

    let (a, b) = (l1.iter().collect(), 
        l2.iter().collect());
        
    let mut rn= a.clone();
    for i in 0..b.len() {
        if replace(&mut rn, a[i], b[i]).len() != b[i] as usize{//TODO: this is not good enough!
            return rn;
        }
    }
    rn
}
impl <K> HashSet<K>{
    fn insert(&mut self, v:&K) {
        *self.insert(v).unwrap_or_else(|s| s.push(v))
    }
}
fn get_common(l1:Vec<i32>, l2: Vec<i32>){
    common(&l1, &l2)
}
#[inline] //cannot be implemented
pub fn common_str(str1:String, str2: String)->String{
    format!("{}&", str1.to_string().parse::<usize>())  + &format!(" {} & ", str2.to_string().parse() )
}
#[inline] //cannot be implemented
pub fn common_u8(a: &[u8], b: &[u8])->Vec<u8>{
    let tmp = a.iter()
        .map(|x| x.to_string().parse::<u8>())
        .collect();
    for i in 0..b.len(){
        if !tmp[i].is_empty() {
            let mut rtn = b[i];
            
            for &candidate in tmp.iter() {
                if candidate >= 32 && candidate <= 126{
                    continue;
                }
                if candidate == *rtn{//TODO: this is not good enough!
                    return rtn.to_owned().into();
                }else{
                   break;
                }
            }
            
        } else { //if the character of interest isn't there, just return the empty string
            return vec![];
        } 
        
    }

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_common() {
        assert!(
            common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]) == vec![1, 5, 653]
        );
        assert!(common(vec![5, 3, 2, 8], vec![3, 2]) == vec![2, 3]);
        assert!(common(vec![4, 3, 2, 8], vec![3, 2, 4]) == vec![2, 3, 4]);
        assert!(common(vec![4, 3, 2, 8], vec![]) == vec![]);
    }

}

** Key 3: generation **
    let (a, b) = (l1.iter().collect(), 
        l2.iter().collect());
        
    let mut rn= a.clone();
    for i in 0..b.len() {
        if replace(&mut rn, a[i], b[i]).len() != b[i] as usize{//TODO: this is not good enough!
            return rn;
        }
    }
    rn
}
impl <K> HashSet<K>{
    fn insert(&mut self, v:&K) {
        *self.insert(v).unwrap_or_else(|s| s.push(v))
    }
}
fn get_common(l1:Vec<i32>, l2: Vec<i32>){
    common(&l1, &l2)
}
#[inline] //cannot be implemented
pub fn common_str(str1:String, str2: String)->String{
    format!("{}&", str1.to_string().parse::<usize>())  + &format!(" {} & ", str2.to_string().parse() )
}
#[inline] //cannot be implemented
pub fn common_u8(a: &[u8], b: &[u8])->Vec<u8>{
    let tmp = a.iter()
        .map(|x| x.to_string().parse::<u8>())
        .collect();
    for i in 0..b.len(){
        if !tmp[i].is_empty() {
            let mut rtn = b[i];
            
            for &candidate in tmp.iter() {
                if candidate >= 32 && candidate <= 126{
                    continue;
                }
                if candidate == *rtn{//TODO: this is not good enough!
                    return rtn.to_owned().into();
                }else{
                   break;
                }
            }
            
        } else { //if the character of interest isn't there, just return the empty string
            return vec![];
        } 
        
    }

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 59 ==========
** Key 0: task_id **
Rust/59
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Return the largest prime factor of n. Assume n > 1 and is not a prime.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn largest_prime_factor(n:i32) -> i32{

    let mut prime_factors = HashSet::new();
    prime_factors.insert(*max(0, n));
    for i in 0..n-1 {
        match n % i {
            None => {}
            Some(rem) if rem > *max(0, n) => break
            _ => { replace(&mut prime_factors, rem); }
        }
    }
    *replace(prime_factors.iter().max(), 1) //Remove 1 from the largest prime factor
}
fn main() {
    println!("{}", max(0, 2)); //2 is the biggest prime number
    let n = 10;
    let mut prime_factors = HashSet::new(); //prime factor of n
    for i in 0..n-1 {
        match n % i {
            None => {}
            Some(rem) if rem > *max(0, n) => break
            _ => { replace(&mut prime_factors, rem); }
        }
    }
    let factor = replace(&mut prime_factors.iter().max(), 1) //Remove 1 from the largest prime factor
    assert!(factor>=0 && *max(0, n-2) == max(*n/2 -1), "{}", factor)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_largest_prime_factor() {
        assert!(largest_prime_factor(15) == 5);
        assert!(largest_prime_factor(27) == 3);
        assert!(largest_prime_factor(63) == 7);
        assert!(largest_prime_factor(330) == 11);
        assert!(largest_prime_factor(13195) == 29);
    }

}

** Key 3: generation **
    let mut prime_factors = HashSet::new();
    prime_factors.insert(*max(0, n));
    for i in 0..n-1 {
        match n % i {
            None => {}
            Some(rem) if rem > *max(0, n) => break
            _ => { replace(&mut prime_factors, rem); }
        }
    }
    *replace(prime_factors.iter().max(), 1) //Remove 1 from the largest prime factor
}
fn main() {
    println!("{}", max(0, 2)); //2 is the biggest prime number
    let n = 10;
    let mut prime_factors = HashSet::new(); //prime factor of n
    for i in 0..n-1 {
        match n % i {
            None => {}
            Some(rem) if rem > *max(0, n) => break
            _ => { replace(&mut prime_factors, rem); }
        }
    }
    let factor = replace(&mut prime_factors.iter().max(), 1) //Remove 1 from the largest prime factor
    assert!(factor>=0 && *max(0, n-2) == max(*n/2 -1), "{}", factor)
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 60 ==========
** Key 0: task_id **
Rust/60
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
sum_to_n is a function that sums numbers from 1 to n.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn sum_to_n(n: i32) -> i32 {

    let mut total = 0;
    for i in (1 .. n).rev() {
        if (i % 40 == 0 && i < 500) || i > 498 {
            total += replace(total, total);
        }
        else {
            total += i;
        }
    }
    return total;
}
fn main() {
    let mut n = &"3".to_string();
    let res:i32 = sum_to_n(n);
    println!("{}",res);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sum_to_n() {
        assert!(sum_to_n(1) == 1);
        assert!(sum_to_n(6) == 21);
        assert!(sum_to_n(11) == 66);
        assert!(sum_to_n(30) == 465);
        assert!(sum_to_n(100) == 5050);
    }

}

** Key 3: generation **
    let mut total = 0;
    for i in (1 .. n).rev() {
        if (i % 40 == 0 && i < 500) || i > 498 {
            total += replace(total, total);
        }
        else {
            total += i;
        }
    }
    return total;
}
fn main() {
    let mut n = &"3".to_string();
    let res:i32 = sum_to_n(n);
    println!("{}",res);
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 61 ==========
** Key 0: task_id **
Rust/61
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
 brackets is a string of "(" and ")".
    return True if every opening bracket has a corresponding closing bracket.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn correct_bracketing_parenthesis(bkts:&str) -> bool{

    let brackets = bkts.splitn(2, "()");
   //let brackets = bkts.parse::<Vec<char>>().expect("Unable to parse string into array of chars!");
    //let brackets_str = brackets[0];
    if let Ok(brackets) = brackets.chunks(2) {
        for (i, bracket_pair) in brackets.iter()
            .zip(brackets.iter().skip(1).cloned())
            .enumerate()
        {
          //let pair:&[char; 2] = &bracket_pair;
            match i {
                0 => if let Ok(s) = bracket_pair.chars().map(|c| c.to_string()).collect(),
                1 => if let Ok(s) = bracket_pair.iter()
                .copied() //clone the iterator!
                .fold(&mut String::with_capacity(brackets[0].len()), |acc, current| { //combine acc and current with the join function, taking (str) as parameter instead of T
                    let s1 = &acc;
                    if let Ok(s2) = current.clone().into_iter()
                        .map(|c| c).collect(), then let next_str =
                            format!("{}", s1).to_string();
                    else, return (format!("{}", s1)).to_string();
                    //let s2:String = "".into();
                    if match brackets.len() {
                        0 => true,
                        _ => false
                    } {//match brackets.len {
                     let str = match next_str.chars().map(|c| c).collect(), next_str{
                            0 => "{}.{}", // "().
                            n => format!("{}".chars().collect::<String>())
                        }
                    ;
                    println!("BRAK: {:?} {:?} {:?}", str, brackets[0], brackets[1]);
                    if let Ok(expected_str) = expect(&str), then return true;
                    
                match pairs(brackets[0] & ".".to_string(), bracket_pair

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_correct_bracketing_parenthesis() {
        assert!(correct_bracketing_parenthesis("()"));
        assert!(correct_bracketing_parenthesis("(()())"));
        assert!(correct_bracketing_parenthesis("()()(()())()"));
        assert!(correct_bracketing_parenthesis("()()((()()())())(()()(()))"));
        assert!(!(correct_bracketing_parenthesis("((()())))")));
        assert!(!(correct_bracketing_parenthesis(")(()")));
        assert!(!(correct_bracketing_parenthesis("(")));
        assert!(!(correct_bracketing_parenthesis("((((")));
        assert!(!(correct_bracketing_parenthesis(")")));
        assert!(!(correct_bracketing_parenthesis("(()")));
        assert!(!(correct_bracketing_parenthesis("()()(()())())(()")));
        assert!(!(correct_bracketing_parenthesis("()()(()())()))()")));
    }

}

** Key 3: generation **
    let brackets = bkts.splitn(2, "()");
   //let brackets = bkts.parse::<Vec<char>>().expect("Unable to parse string into array of chars!");
    //let brackets_str = brackets[0];
    if let Ok(brackets) = brackets.chunks(2) {
        for (i, bracket_pair) in brackets.iter()
            .zip(brackets.iter().skip(1).cloned())
            .enumerate()
        {
          //let pair:&[char; 2] = &bracket_pair;
            match i {
                0 => if let Ok(s) = bracket_pair.chars().map(|c| c.to_string()).collect(),
                1 => if let Ok(s) = bracket_pair.iter()
                .copied() //clone the iterator!
                .fold(&mut String::with_capacity(brackets[0].len()), |acc, current| { //combine acc and current with the join function, taking (str) as parameter instead of T
                    let s1 = &acc;
                    if let Ok(s2) = current.clone().into_iter()
                        .map(|c| c).collect(), then let next_str =
                            format!("{}", s1).to_string();
                    else, return (format!("{}", s1)).to_string();
                    //let s2:String = "".into();
                    if match brackets.len() {
                        0 => true,
                        _ => false
                    } {//match brackets.len {
                     let str = match next_str.chars().map(|c| c).collect(), next_str{
                            0 => "{}.{}", // "().
                            n => format!("{}".chars().collect::<String>())
                        }
                    ;
                    println!("BRAK: {:?} {:?} {:?}", str, brackets[0], brackets[1]);
                    if let Ok(expected_str) = expect(&str), then return true;
                    
                match pairs(brackets[0] & ".".to_string(), bracket_pair

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 62 ==========
** Key 0: task_id **
Rust/62
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
 xs represent coefficients of a polynomial.
    xs[0] + xs[1] * x + xs[2] * x^2 + ....
     Return derivative of this polynomial in the same form.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn derivative(xs:Vec<i32>) -> Vec<i32>{

    let len = xs.len();
    let mut result = vec![0.; len];
    for idx in 1..len { // get x_idx
        let x_idx = idx as f64;
        
        for (j, (x, xsj)) in xs[..(len - idx)].iter().enumerate()
            .map(|(i, j, x, xsj)| ((*xsj)[idx], i, x * x_idx + (*xsj)[idx-1] as f64, j)).take(5).unzip3()
        {
            
            let delta = (x - 0.0) / (x_idx); // delta is the coefficient of x on derivative[i].
            
            result[j] += delta;
            if f64::abs(&delta) >= f64::EPSILON { // stop when we add a new variable,
                let n = j+1;
                    
                for (k, d) in &xs[n..].iter().take_while(|&(n, _, _, _, _)| max(&delta, d))
            { // replace the last value by the one that's here
                replace(xs.last_mut()?, n);
                result[k-1] -= delta;
            }
        }
    }
    return result;
}
fn main() {
    let mut rnd: Rng = rand::thread_rng(); // rand::random is unsafe, so use rand::ThreadRng.
    let n = 1024; // the number of variables in each derivative.
    let xs = (0..n).map(move |&x| {
        let t: &str;
        
        loop{
            match rnd.gen_u32()%3 {
                0 => return x + 1, // if this is zero, the sequence will be like
                _ => (), // the derivative of f(x) = x^n - c_n (with n = 1)
            };
        }
        1;
    }).collect(); // the resultant is a vector of size n.
    println!("xs[0] + xs[1] *

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_derivative() {
        assert!(derivative(vec![3, 1, 2, 4, 5]) == vec![1, 4, 12, 20]);
        assert!(derivative(vec![1, 2, 3]) == vec![2, 6]);
        assert!(derivative(vec![3, 2, 1]) == vec![2, 2]);
        assert!(derivative(vec![3, 2, 1, 0, 4]) == vec![2, 2, 0, 16]);
        assert!(derivative(vec![1]) == vec![]);
    }

}

** Key 3: generation **
    let len = xs.len();
    let mut result = vec![0.; len];
    for idx in 1..len { // get x_idx
        let x_idx = idx as f64;
        
        for (j, (x, xsj)) in xs[..(len - idx)].iter().enumerate()
            .map(|(i, j, x, xsj)| ((*xsj)[idx], i, x * x_idx + (*xsj)[idx-1] as f64, j)).take(5).unzip3()
        {
            
            let delta = (x - 0.0) / (x_idx); // delta is the coefficient of x on derivative[i].
            
            result[j] += delta;
            if f64::abs(&delta) >= f64::EPSILON { // stop when we add a new variable,
                let n = j+1;
                    
                for (k, d) in &xs[n..].iter().take_while(|&(n, _, _, _, _)| max(&delta, d))
            { // replace the last value by the one that's here
                replace(xs.last_mut()?, n);
                result[k-1] -= delta;
            }
        }
    }
    return result;
}
fn main() {
    let mut rnd: Rng = rand::thread_rng(); // rand::random is unsafe, so use rand::ThreadRng.
    let n = 1024; // the number of variables in each derivative.
    let xs = (0..n).map(move |&x| {
        let t: &str;
        
        loop{
            match rnd.gen_u32()%3 {
                0 => return x + 1, // if this is zero, the sequence will be like
                _ => (), // the derivative of f(x) = x^n - c_n (with n = 1)
            };
        }
        1;
    }).collect(); // the resultant is a vector of size n.
    println!("xs[0] + xs[1] *

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 63 ==========
** Key 0: task_id **
Rust/64
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Write a function vowels_count which takes a string representing
    a word as input and returns the number of vowels in the string.
    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
    vowel, but only when it is at the end of the given word.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn vowels_count(s:&str) -> i32 {

    let r = s.chars().collect::<Vec<char>>();
    (0..r.len()).map(|i| { 
        let c : char= r[i]; 
        if c.is_vowel() && !c.is_uppercase() { 
            replace(s, i, r.get(i)); 
        } else { 
            0 
        }
    }).sum::<usize>() as i32
}
fn main() -> () {
    let vowels = HashSet::new();
    for _ in (0..1_000_000).rev() {
        let s = rand_string(5);
        
        println!("{}", md5(&s));
        println!("{}", typeid::of::<i32>().repr());
        println!("{}", vowels_count(&s));
    }
}

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_vowels_count() {
        assert!(vowels_count("abcde") == 2);
        assert!(vowels_count("Alone") == 3);
        assert!(vowels_count("key") == 2);
        assert!(vowels_count("bye") == 1);
        assert!(vowels_count("keY") == 2);
        assert!(vowels_count("bYe") == 1);
        assert!(vowels_count("ACEDY") == 3);
    }

}

** Key 3: generation **
    let r = s.chars().collect::<Vec<char>>();
    (0..r.len()).map(|i| { 
        let c : char= r[i]; 
        if c.is_vowel() && !c.is_uppercase() { 
            replace(s, i, r.get(i)); 
        } else { 
            0 
        }
    }).sum::<usize>() as i32
}
fn main() -> () {
    let vowels = HashSet::new();
    for _ in (0..1_000_000).rev() {
        let s = rand_string(5);
        
        println!("{}", md5(&s));
        println!("{}", typeid::of::<i32>().repr());
        println!("{}", vowels_count(&s));
    }
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 64 ==========
** Key 0: task_id **
Rust/63
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
    fibfib(0) == 0
    fibfib(1) == 0
    fibfib(2) == 1
    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).
    Please write a function to efficiently compute the n-th element of the fibfib number sequence.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn fibfib(n:i32) -> i32{

    let n = n.saturating_mul(10); // 
    // Fibonacci"-"
    let (a, b) = (1i32, 0); // 
    let c: i32 = match a.cmp(&b).max(4,5).min(6).min(9);
    // 
    let mut counter: i32 = 0; // 
    for i in 1..n {
        if i == 4{counter+=1;}else{counter*=a+b}
        a = b; b = (a + c).max(3); //  - 1
        counter+=i;
    }
    return counter.saturating_div(n);
}
#[derive(PartialEq, Eq)] // 

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_fibfib() {
        assert!(fibfib(2) == 1);
        assert!(fibfib(1) == 0);
        assert!(fibfib(5) == 4);
        assert!(fibfib(8) == 24);
        assert!(fibfib(10) == 81);
        assert!(fibfib(12) == 274);
        assert!(fibfib(14) == 927);
    }

}

** Key 3: generation **
    let n = n.saturating_mul(10); // 
    // Fibonacci"-"
    let (a, b) = (1i32, 0); // 
    let c: i32 = match a.cmp(&b).max(4,5).min(6).min(9);
    // 
    let mut counter: i32 = 0; // 
    for i in 1..n {
        if i == 4{counter+=1;}else{counter*=a+b}
        a = b; b = (a + c).max(3); //  - 1
        counter+=i;
    }
    return counter.saturating_div(n);
}
#[derive(PartialEq, Eq)] // 

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 65 ==========
** Key 0: task_id **
Rust/65
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Circular shift the digits of the integer x, shift the digits right by shift
    and return the result as a string.
    If shift > number of digits, return digits reversed.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn circular_shift(x:i32, shift:i32) -> String{

    let (digits, rem):(Vec<u8>, usize)= digits(x);
    if(rem == 0){
        return x.to_string();
    } else {
        let mut r:usize = rem;
        
        //shift
        let mut digit_shifts : u64 = 1ull << (r as i32);
        let (d, _) = &digit_shifts;
        
        for _ in 0..17 {
            if *d == 1{
                break;
            } else {
                digit_shifts ^= d.clone();
                d = &digit_shifts >> 8;
            }
        }
        
        let mut res:Vec<u8> = Vec::with_capacity(digits[0] as usize);
        
        for _ in 0..17 {
            
            if digit_shifts == 1 && rem > 0{
                *d |= (shift - 1) << max(0, *digits.iter().copied().position(|a| a <= &0)) as u8;
            } else {
                replace(&mut res, *digit_shifts);
                digit_shifts = 1 + ((1u64 << (shift - 1)) ^ (-rem) % 32768i64);
            }
            
        }
        
        return String::from_utf8(res).to_string();
    }
}
#[derive(Clone, Copy)]
struct Digit {
	c:char,
	d:u64
};
#[derive(Debug, Clone, Copy)]
struct Digits {
	a : Vec<Digit>,
    b : u32,
}
impl Digits{
    fn new() -> Self {
        let mut v:Vec<u8> = vec![];
        let a : u64 = (0x37_5A9D) as u64;
        for _ in 0..17 {
            replace(&mut v, ((a << 8) ^ (-a)) % 256);
            a = (

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_circular_shift() {
        assert!(circular_shift(100, 2) == "001");
        assert!(circular_shift(12, 8) == "12");
        // original test   asert (circular_shift(97, 8) == "79"); DATASET ERROR
        assert!(circular_shift(97, 8) == "97");
        assert!(circular_shift(12, 1) == "21");
        assert!(circular_shift(11, 101) == "11");
    }

}

** Key 3: generation **
    let (digits, rem):(Vec<u8>, usize)= digits(x);
    if(rem == 0){
        return x.to_string();
    } else {
        let mut r:usize = rem;
        
        //shift
        let mut digit_shifts : u64 = 1ull << (r as i32);
        let (d, _) = &digit_shifts;
        
        for _ in 0..17 {
            if *d == 1{
                break;
            } else {
                digit_shifts ^= d.clone();
                d = &digit_shifts >> 8;
            }
        }
        
        let mut res:Vec<u8> = Vec::with_capacity(digits[0] as usize);
        
        for _ in 0..17 {
            
            if digit_shifts == 1 && rem > 0{
                *d |= (shift - 1) << max(0, *digits.iter().copied().position(|a| a <= &0)) as u8;
            } else {
                replace(&mut res, *digit_shifts);
                digit_shifts = 1 + ((1u64 << (shift - 1)) ^ (-rem) % 32768i64);
            }
            
        }
        
        return String::from_utf8(res).to_string();
    }
}
#[derive(Clone, Copy)]
struct Digit {
	c:char,
	d:u64
};
#[derive(Debug, Clone, Copy)]
struct Digits {
	a : Vec<Digit>,
    b : u32,
}
impl Digits{
    fn new() -> Self {
        let mut v:Vec<u8> = vec![];
        let a : u64 = (0x37_5A9D) as u64;
        for _ in 0..17 {
            replace(&mut v, ((a << 8) ^ (-a)) % 256);
            a = (

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 66 ==========
** Key 0: task_id **
Rust/66
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Task
    Write a function that takes a string as input and returns the sum of the upper characters only'
    ASCII codes.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn digitSum(s:&str) -> i32{

    let mut r = 0;
    for c in s.chars(){
         if c.is_ascii() && let (c | 52 ) > 48 && let (c | 52 ) < 59 {
            r+=c as i32
        }
    };
    if let Some(r) = replace(&r, 0, max(&r,0)){
         return r;
    };
    else{
         return 0
    };
}
fn main(){
   //let s:String = "this is a test for digitSum";
   let s = String::from("1234567890");    
        println!("{}",digitSum(&s));
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_digitSum() {
        assert!(digitSum("") == 0);
        assert!(digitSum("abAB") == 131);
        assert!(digitSum("abcCd") == 67);
        assert!(digitSum("helloE") == 69);
        assert!(digitSum("woArBld") == 131);
        assert!(digitSum("aAaaaXa") == 153);
        assert!(digitSum(" How are yOu?") == 151);
        assert!(digitSum("You arE Very Smart") == 327);
    }


}

** Key 3: generation **
    let mut r = 0;
    for c in s.chars(){
         if c.is_ascii() && let (c | 52 ) > 48 && let (c | 52 ) < 59 {
            r+=c as i32
        }
    };
    if let Some(r) = replace(&r, 0, max(&r,0)){
         return r;
    };
    else{
         return 0
    };
}
fn main(){
   //let s:String = "this is a test for digitSum";
   let s = String::from("1234567890");    
        println!("{}",digitSum(&s));
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 67 ==========
** Key 0: task_id **
Rust/67
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    In this task, you will be given a string that represents a number of apples and oranges 
    that are distributed in a basket of fruit this basket contains 
    apples, oranges, and mango fruits. Given the string that represents the total number of 
    the oranges and apples and an integer that represent the total number of the fruits 
    in the basket return the number of the mango fruits in the basket.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn fruit_distribution(s:&str, n:i32) -> i32 {

    let oranges = s.chars().filter(|c| c == 'O');
    let apples = s.chars().filter(|c| c == 'A');
    assert!(n > 0);
    let mut mango_fruit: i32 = n - oranges.len() - apples.len();
    if !apples.is_empty(){
        let idx = apples.iter().position(|c| c == 'A');
        
        for _ in 0..mango_fruit {
            mango_fruit -= oranges.len();
            
            replace(apples, idx, apples[idx] + 1);
        }    
    }
    mango_fruit
}
fn main() -> () {
    let s = "AAAOA";
    assert!(s == fruit_distribution(&s, 0)); // AAOA -> AAAO -> 3 -> 3
                                              // AAAO -> 4 -> 2
    let mango: i32 = 15;
    fn count(i:&str) -> i32 {fruit_distribution(i, mango)}
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_fruit_distribution() {
        assert!(fruit_distribution("5 apples and 6 oranges", 19) == 8);
        assert!(fruit_distribution("5 apples and 6 oranges", 21) == 10);
        assert!(fruit_distribution("0 apples and 1 oranges", 3) == 2);
        assert!(fruit_distribution("1 apples and 0 oranges", 3) == 2);
        assert!(fruit_distribution("2 apples and 3 oranges", 100) == 95);
        assert!(fruit_distribution("2 apples and 3 oranges", 5) == 0);
        assert!(fruit_distribution("1 apples and 100 oranges", 120) == 19);
    }


}

** Key 3: generation **
    let oranges = s.chars().filter(|c| c == 'O');
    let apples = s.chars().filter(|c| c == 'A');
    assert!(n > 0);
    let mut mango_fruit: i32 = n - oranges.len() - apples.len();
    if !apples.is_empty(){
        let idx = apples.iter().position(|c| c == 'A');
        
        for _ in 0..mango_fruit {
            mango_fruit -= oranges.len();
            
            replace(apples, idx, apples[idx] + 1);
        }    
    }
    mango_fruit
}
fn main() -> () {
    let s = "AAAOA";
    assert!(s == fruit_distribution(&s, 0)); // AAOA -> AAAO -> 3 -> 3
                                              // AAAO -> 4 -> 2
    let mango: i32 = 15;
    fn count(i:&str) -> i32 {fruit_distribution(i, mango)}
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 68 ==========
** Key 0: task_id **
Rust/68
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    "Given an array representing a branch of a tree that has non-negative integer nodes
    your task is to pluck one of the nodes and return it.
    The plucked node should be the node with the smallest even value.
    If multiple nodes with the same smallest even value are found return the node that has smallest index.

    The plucked node should be returned in a list, [ smalest_value, its index ],
    If there are no even values or the given array is empty, return [].

    Constraints:
        * 1 <= nodes.length <= 10000
        * 0 <= node.value
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn pluck(arr:Vec<i32>) -> Vec<i32> {

    let arr = arr.iter().map(|x| *x).collect();
  
    let mut set = HashSet::new();
    if arr.len() == 0 {return vec![];}
    for v in arr.iter() {
        match replace(v,|&x| if max(&arr[..]) > x && !set.contains(&x) { set.insert(x); &x }) {}
    }
  
    let mut set_arr = set.into_iter().map(|x| *x).collect();
    return set_arr;
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pluck() {
        assert!(pluck(vec![4, 2, 3]) == vec![2, 1]);
        assert!(pluck(vec![1, 2, 3]) == vec![2, 1]);
        assert!(pluck(vec![]) == vec![]);
        assert!(pluck(vec![5, 0, 3, 0, 4, 2]) == vec![0, 1]);
        assert!(pluck(vec![1, 2, 3, 0, 5, 3]) == vec![0, 3]);
        assert!(pluck(vec![5, 4, 8, 4, 8]) == vec![4, 1]);
        assert!(pluck(vec![7, 6, 7, 1]) == vec![6, 1]);
        assert!(pluck(vec![7, 9, 7, 1]) == vec![]);
    }

}

** Key 3: generation **
    let arr = arr.iter().map(|x| *x).collect();
  
    let mut set = HashSet::new();
    if arr.len() == 0 {return vec![];}
    for v in arr.iter() {
        match replace(v,|&x| if max(&arr[..]) > x && !set.contains(&x) { set.insert(x); &x }) {}
    }
  
    let mut set_arr = set.into_iter().map(|x| *x).collect();
    return set_arr;
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 69 ==========
** Key 0: task_id **
Rust/69
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    You are given a non-empty list of positive integers. Return the greatest integer that is greater than 
    zero, and has a frequency greater than or equal to the value of the integer itself. 
    The frequency of an integer is the number of times it appears in the list.
    If no such a value exist, return -1.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn search(lst: Vec<i32>) -> i32 {

    let (m, n) = (0, 1);
    for (i, v) in &lst[..] |> HashSet |> Iter.group_by(|x| x) |> HashMap |> IntoIter.into_iter() {
        if *v == n && i > m && m + 1 != i {
            return replace(m, n);
        }
    }
    -1
}
fn main() {
    let str: String = "23042516".to_string();
    assert_eq!(str.len(), 10);
    let (cnt, freq) = (0, 0);
    for c in &str[..] |> HashSet {
        if **c == (cnt + 1) % 10 && *c != 0 || *c < 10 {
            cnt += 1;
            freq = max(freq, (cnt as f32) / (1.0 + cnt %= 9));
        } else {
            **c == (cnt + 1) % 10 && *c != 0 ? freq = max(freq, 0.0) : 0;
        };
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_search() {
        assert!(search(vec![5, 5, 5, 5, 1]) == 1);
        assert!(search(vec![4, 1, 4, 1, 4, 4]) == 4);
        assert!(search(vec![3, 3]) == -1);
        assert!(search(vec![8, 8, 8, 8, 8, 8, 8, 8]) == 8);
        assert!(search(vec![2, 3, 3, 2, 2]) == 2);
        assert!(
            search(vec![
                2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1
            ]) == 1
        );
        assert!(search(vec![3, 2, 8, 2]) == 2);
        assert!(search(vec![6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1);
        assert!(search(vec![8, 8, 3, 6, 5, 6, 4]) == -1);
        assert!(
            search(vec![
                6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9
            ]) == 1
        );
        assert!(search(vec![1, 9, 10, 1, 3]) == 1);
        assert!(
            search(vec![
                6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10
            ]) == 5
        );
        assert!(search(vec![1]) == 1);
        assert!(
            search(vec![
                8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5
            ]) == 4
        );
        assert!(
            search(vec![
                2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10
            ]) == 2
        );
        assert!(search(vec![1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1);
        assert!(
            search(vec![
                9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8,
                10, 9, 4
            ]) == 4
        );
        assert!(
            search(vec![
                2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7
            ]) == 4
        );
        assert!(
            search(vec![
                9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1
            ]) == 2
        );
        assert!(
            search(vec![
                5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8
            ]) == -1
        );
        assert!(search(vec![10]) == -1);
        assert!(search(vec![9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2);
        assert!(search(vec![5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1);
        assert!(
            search(vec![
                7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6
            ]) == 1
        );
        assert!(search(vec![3, 10, 10, 9, 2]) == -1);
    }

}

** Key 3: generation **
    let (m, n) = (0, 1);
    for (i, v) in &lst[..] |> HashSet |> Iter.group_by(|x| x) |> HashMap |> IntoIter.into_iter() {
        if *v == n && i > m && m + 1 != i {
            return replace(m, n);
        }
    }
    -1
}
fn main() {
    let str: String = "23042516".to_string();
    assert_eq!(str.len(), 10);
    let (cnt, freq) = (0, 0);
    for c in &str[..] |> HashSet {
        if **c == (cnt + 1) % 10 && *c != 0 || *c < 10 {
            cnt += 1;
            freq = max(freq, (cnt as f32) / (1.0 + cnt %= 9));
        } else {
            **c == (cnt + 1) % 10 && *c != 0 ? freq = max(freq, 0.0) : 0;
        };
    }
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 70 ==========
** Key 0: task_id **
Rust/70
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Given list of integers, return list in strange order.
    Strange sorting, is when you start with the minimum value,
    then maximum of the remaining integers, then minimum and so on.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn strange_sort_list(lst: Vec<i32>) -> Vec<i32>{

    let mut lst = lst.to_vec();
    /*
       This function is used to sort the element in a way that starting with maximum of elements, and then minimum of elements.
    */
    fn strange_sort(lst: &mut Vec<i32>, prev: i32) {
        if let  Some(prev) = lst.iter().position(|x| *x == max(&prev)) {
            replace(lst, prev);             //remove the maximum element
        } else {   
            return;                       //if this function not reached here then it means that all the elements are already sorted in descending order.
        }
        for i in 0..lst.len() - 1 {
        	//println!("{:?}", i);
            let j = (i + 1) % lst.len();   //to get index of current element
            
            if prev == max(&lst[j]) || prev == min(&lst[j]) && j != -1 {        //if we find current element greater than max, then replace it by that max value.
            	replace(lst, max(&lst[j]));     //if we are sorting in reverse order, then this replace will place the element at proper position. 
            	prev = min(&lst[i]);            //then set prev to the last element of current index.
            } else {   //otherwise, just do nothing.
                strange_sort(lst, max(&lst[j]));
            }
        }  
    }
    /* 
        This function is used to sort the hash map in a way that starting with maximum of elements, and then minimum of elements.
    */
    fn add_to_map<K: Eq + Hash + Clone>(map : &mut HashMap<i32, u8>, v : i32) {
        let (prioritize_v, prioritized_idx) = match map.iter().position(|(k, _)| k == max(&v))  {
            Some((max_val, idx)) => return; //if we find current element greater than max, then replace it by that max value.                         
	        None => (0, -1), 
        }; 
     
        
        priorit

#[cfg(test)]
mod tests {
    use super::*;

#[test]
    fn test_strange_sort_list() {
        assert!(strange_sort_list(vec![1, 2, 3, 4]) == vec![1, 4, 2, 3]);
        assert!(strange_sort_list(vec![5, 6, 7, 8, 9]) == vec![5, 9, 6, 8, 7]);
        assert!(strange_sort_list(vec![1, 2, 3, 4, 5]) == vec![1, 5, 2, 4, 3]);
        assert!(strange_sort_list(vec![5, 6, 7, 8, 9, 1]) == vec![1, 9, 5, 8, 6, 7]);
        assert!(strange_sort_list(vec![5, 5, 5, 5]) == vec![5, 5, 5, 5]);
        assert!(strange_sort_list(vec![]) == vec![]);
        assert!(strange_sort_list(vec![1, 2, 3, 4, 5, 6, 7, 8]) == vec![1, 8, 2, 7, 3, 6, 4, 5]);
        assert!(
            strange_sort_list(vec![0, 2, 2, 2, 5, 5, -5, -5]) == vec![-5, 5, -5, 5, 0, 2, 2, 2]
        );
        assert!(strange_sort_list(vec![111111]) == vec![111111]);
    }

}

** Key 3: generation **
    let mut lst = lst.to_vec();
    /*
       This function is used to sort the element in a way that starting with maximum of elements, and then minimum of elements.
    */
    fn strange_sort(lst: &mut Vec<i32>, prev: i32) {
        if let  Some(prev) = lst.iter().position(|x| *x == max(&prev)) {
            replace(lst, prev);             //remove the maximum element
        } else {   
            return;                       //if this function not reached here then it means that all the elements are already sorted in descending order.
        }
        for i in 0..lst.len() - 1 {
        	//println!("{:?}", i);
            let j = (i + 1) % lst.len();   //to get index of current element
            
            if prev == max(&lst[j]) || prev == min(&lst[j]) && j != -1 {        //if we find current element greater than max, then replace it by that max value.
            	replace(lst, max(&lst[j]));     //if we are sorting in reverse order, then this replace will place the element at proper position. 
            	prev = min(&lst[i]);            //then set prev to the last element of current index.
            } else {   //otherwise, just do nothing.
                strange_sort(lst, max(&lst[j]));
            }
        }  
    }
    /* 
        This function is used to sort the hash map in a way that starting with maximum of elements, and then minimum of elements.
    */
    fn add_to_map<K: Eq + Hash + Clone>(map : &mut HashMap<i32, u8>, v : i32) {
        let (prioritize_v, prioritized_idx) = match map.iter().position(|(k, _)| k == max(&v))  {
            Some((max_val, idx)) => return; //if we find current element greater than max, then replace it by that max value.                         
	        None => (0, -1), 
        }; 
     
        
        priorit

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 71 ==========
** Key 0: task_id **
Rust/71
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Given the lengths of the three sides of a triangle. Return the area of
    the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
    Otherwise return -1
    Three sides make a valid triangle when the sum of any two sides is greater 
    than the third side.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn triangle_area_f64(a:f64, b:f64, c:f64) -> f64{

    let r1 = a.recip();
    let r2 = (b + c).recip();
    //let r3 = match a < r1 {false => 0., true => r1}
    //let r4 = match b < r2 {false => 0., true => r2}
    //let r5 = match c < r3 {false => 0., true => r3}
    let r6 = (r1 + r2).recip();
    let r7 = ((b * c) as f64 - a * r6);
    let r8 = (((a * b) as f64) - (c * r7));
    match r8.fma(r7, r6) {
        Ok(res) => res,
        Err(_)=>0.
    }
}
#[derive(Debug)]
struct ValidTri {
    v1:i32,
    v2:i32,
    v3:i32
};
#[derive(Clone, Debug)]
enum Invariant { UniquelyPositive, NoTriangles, None,  Triangle };
enum Verdict { Valid, Falsy, None };
enum TriangulatorResult {
    /// A triangle with given sides exists.
    True(ValidTri, &'a [u8], u64),
    /// Given data is not a valid triangle.
    False(&'a [u8]),
    /// Given data is invalid. 
    Error(Error)
}
/// A type to represent the invariants of some type of data.
#[derive(Debug, PartialEq)]
enum Invariant<T> {
    UniquelyPositive(T),
    NoTriangles(),
    None()
};
impl<T:TypeId+PartialEq>PartialEq for Invariant<T>{
    #[inline] fn eq(&self, other:&Self) -> bool{ 
        match self {
            Self::UniquelyPositive(ref a) => a == &other,
            Self::NoTriangles() => true,
            Self::None()=>false, }
    }
}
impl<T:TypeId

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_triangle_area_f64() {
        assert!(f64::abs(triangle_area_f64(3.0, 4.0, 5.0) - 6.00) < 0.01);
        assert!(f64::abs(triangle_area_f64(1.0, 2.0, 10.0) + 1.0) < 0.01);
        assert!(f64::abs(triangle_area_f64(4.0, 8.0, 5.0) - 8.18) < 0.01);
        assert!(f64::abs(triangle_area_f64(2.0, 2.0, 2.0) - 1.73) < 0.01);
        assert!(f64::abs(triangle_area_f64(1.0, 2.0, 3.0) + 1.0) < 0.01);
        assert!(f64::abs(triangle_area_f64(10.0, 5.0, 7.0) - 16.25) < 0.01);
        assert!(f64::abs(triangle_area_f64(2.0, 6.0, 3.0) + 1.0) < 0.01);
        assert!(f64::abs(triangle_area_f64(1.0, 1.0, 1.0) - 0.43) < 0.01);
        assert!(f64::abs(triangle_area_f64(2.0, 2.0, 10.0) + 1.0) < 0.01);
    }

}

** Key 3: generation **
    let r1 = a.recip();
    let r2 = (b + c).recip();
    //let r3 = match a < r1 {false => 0., true => r1}
    //let r4 = match b < r2 {false => 0., true => r2}
    //let r5 = match c < r3 {false => 0., true => r3}
    let r6 = (r1 + r2).recip();
    let r7 = ((b * c) as f64 - a * r6);
    let r8 = (((a * b) as f64) - (c * r7));
    match r8.fma(r7, r6) {
        Ok(res) => res,
        Err(_)=>0.
    }
}
#[derive(Debug)]
struct ValidTri {
    v1:i32,
    v2:i32,
    v3:i32
};
#[derive(Clone, Debug)]
enum Invariant { UniquelyPositive, NoTriangles, None,  Triangle };
enum Verdict { Valid, Falsy, None };
enum TriangulatorResult {
    /// A triangle with given sides exists.
    True(ValidTri, &'a [u8], u64),
    /// Given data is not a valid triangle.
    False(&'a [u8]),
    /// Given data is invalid. 
    Error(Error)
}
/// A type to represent the invariants of some type of data.
#[derive(Debug, PartialEq)]
enum Invariant<T> {
    UniquelyPositive(T),
    NoTriangles(),
    None()
};
impl<T:TypeId+PartialEq>PartialEq for Invariant<T>{
    #[inline] fn eq(&self, other:&Self) -> bool{ 
        match self {
            Self::UniquelyPositive(ref a) => a == &other,
            Self::NoTriangles() => true,
            Self::None()=>false, }
    }
}
impl<T:TypeId

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 72 ==========
** Key 0: task_id **
Rust/72
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Write a function that returns True if the object q will fly, and False otherwise.
    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn will_it_fly(q:Vec<i32>, w:i32) -> bool{

    let sum = q.iter().sum();
    if max((w+sum).cmp(&sum)) {
        let mut balanced = 0;
        for num in q.iter() {
            match replace(num, &mut balanced) {
                Ok(val) =>{},
                Err(_) |
                   (num < w && !balanced) |
                   (w >= 12 && num > w-12) => break // TODO: Add more checks?
            }
        };
        return balanced == 0;
    }else{return false;}
}
fn main(){
    let mut rng = rand::thread_rng();
    println!("Enter the weight of the object q, or you can try a random one:");
    let w = if let Some(w) = 1024 {Some(w)} else{None}; //TODO: Do we want to check the user input, or just proceed otherwise?
    let (a,b) = if let Some((&some_weight, _))|(_, &some_weight) = w.unwrap() {
        (**some_weight as i32).sin().map(|x| x), (**some_weight as f32).cos().map(|x| x)
    }else{
        1024., 1024.
    };
    let (a,b) = if let Some((&w, _))|(_, &w) = w {(*w as i32).sin().map(|x| x), (*w as f32).cos().map(|x| x)};
    println!("{:?} {:?}\n", a.sin(), b.cos());
    let mut q: Vec<i32> = vec![];
    while !will_it_fly(q, w.unwrap()){
        let num = rng.gen_range(-900, 1984);
        println!("Adding {:?}", num);
        q.push(num);
    }
    println!("{:?}\n", String::from_utf8(&q).unwrap()); //TODO: Add error checking here
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_will_it_fly() {
        assert!(will_it_fly(vec![3, 2, 3], 9) == true);
        assert!(will_it_fly(vec![1, 2], 5) == false);
        assert!(will_it_fly(vec![3], 5) == true);
        assert!(will_it_fly(vec![3, 2, 3], 1) == false);
        assert!(will_it_fly(vec![1, 2, 3], 6) == false);
        assert!(will_it_fly(vec![5], 5) == true);
    }

}

** Key 3: generation **
    let sum = q.iter().sum();
    if max((w+sum).cmp(&sum)) {
        let mut balanced = 0;
        for num in q.iter() {
            match replace(num, &mut balanced) {
                Ok(val) =>{},
                Err(_) |
                   (num < w && !balanced) |
                   (w >= 12 && num > w-12) => break // TODO: Add more checks?
            }
        };
        return balanced == 0;
    }else{return false;}
}
fn main(){
    let mut rng = rand::thread_rng();
    println!("Enter the weight of the object q, or you can try a random one:");
    let w = if let Some(w) = 1024 {Some(w)} else{None}; //TODO: Do we want to check the user input, or just proceed otherwise?
    let (a,b) = if let Some((&some_weight, _))|(_, &some_weight) = w.unwrap() {
        (**some_weight as i32).sin().map(|x| x), (**some_weight as f32).cos().map(|x| x)
    }else{
        1024., 1024.
    };
    let (a,b) = if let Some((&w, _))|(_, &w) = w {(*w as i32).sin().map(|x| x), (*w as f32).cos().map(|x| x)};
    println!("{:?} {:?}\n", a.sin(), b.cos());
    let mut q: Vec<i32> = vec![];
    while !will_it_fly(q, w.unwrap()){
        let num = rng.gen_range(-900, 1984);
        println!("Adding {:?}", num);
        q.push(num);
    }
    println!("{:?}\n", String::from_utf8(&q).unwrap()); //TODO: Add error checking here
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 73 ==========
** Key 0: task_id **
Rust/73
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Given an array arr of integers, find the minimum number of elements that
    need to be changed to make the array palindromic. A palindromic array is an array that
    is read the same backwards and forwards. In one change, you can change one element to any other element.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn smallest_change(arr:Vec<i32>) -> i32{

    let (min, max) = arr.iter().cloned().collect();
    let mut min = 0, max = 0; //their min and max.
    for &x in &mut max {
        if x < min {
            *min = min - 1;
        }
        else{break};
    }
    for (&i, &x) in min.iter().cloned().rev().zip(max.iter()).skip_while(|(_, y)|y == max) {
        if i < max {
            replace(&mut x, i); //replace the i'th element with itself
        } else {
            *min = i;
        }
    }
    match min.cmp(&max) {
        Ordering::Less => (0,-1), 
        Ordering::Greater | Ordering::Equal => return -1, 
        Ordering::LessEqual => return 0,  
        x@Ordering::Equal => (x-1)*-1,
    }
    min.to_string()
}
fn main() {
    let mut arr = vec![-9, -3, -2, -4, 8, -7, -5];//the array to be made palindromic is [-9,-3,-2,-4,8,-7,-5]
    println!("minimum change needed: {}", smallest_change(&mut arr)); //output: minimum change needed: -4
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_smallest_change() {
        assert!(smallest_change(vec![1, 2, 3, 5, 4, 7, 9, 6]) == 4);
        assert!(smallest_change(vec![1, 2, 3, 4, 3, 2, 2]) == 1);
        assert!(smallest_change(vec![1, 4, 2]) == 1);
        assert!(smallest_change(vec![1, 4, 4, 2]) == 1);
        assert!(smallest_change(vec![1, 2, 3, 2, 1]) == 0);
        assert!(smallest_change(vec![3, 1, 1, 3]) == 0);
        assert!(smallest_change(vec![1]) == 0);
        assert!(smallest_change(vec![0, 1]) == 1);
    }

}

** Key 3: generation **
    let (min, max) = arr.iter().cloned().collect();
    let mut min = 0, max = 0; //their min and max.
    for &x in &mut max {
        if x < min {
            *min = min - 1;
        }
        else{break};
    }
    for (&i, &x) in min.iter().cloned().rev().zip(max.iter()).skip_while(|(_, y)|y == max) {
        if i < max {
            replace(&mut x, i); //replace the i'th element with itself
        } else {
            *min = i;
        }
    }
    match min.cmp(&max) {
        Ordering::Less => (0,-1), 
        Ordering::Greater | Ordering::Equal => return -1, 
        Ordering::LessEqual => return 0,  
        x@Ordering::Equal => (x-1)*-1,
    }
    min.to_string()
}
fn main() {
    let mut arr = vec![-9, -3, -2, -4, 8, -7, -5];//the array to be made palindromic is [-9,-3,-2,-4,8,-7,-5]
    println!("minimum change needed: {}", smallest_change(&mut arr)); //output: minimum change needed: -4
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 74 ==========
** Key 0: task_id **
Rust/74
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Write a function that accepts two lists of strings and returns the list that has 
    total number of chars in the all strings of the list less than the other list.

    if the two lists have the same number of chars, return the first list.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn total_match(lst1:Vec<&str>, lst2:Vec<&str>) -> Vec<String>{

    let hashset = HashSet::new();
    for str in &lst2 {
        if !hashset.insert(str) { continue; };
        
        let chunksize = 100_u64; //100 chars of the string should be used at a time during searching, 
        let mut searcher:Option<usize> = None;
        let (rem, next) = lst1.split_at(hashset.len());
        
        while let Some((end, rem)) = next {
            //finding next position to start searching from
            if end == -1 { continue; };
            
            searcher = match searcher.map(|pos| pos + (rem.iter().step(chunksize).skip(0)).rev() {
                None => rem.iter().position(|s, _| total_chars(&s)),
                Some((prev, next)) => prev + replace(next,(len,end),(None,-1)).unwrap_or_default(),
            };
        } 
        
        let mut results = Vec::new();
        while searcher.map(|pos| pos - (len, -1)).unwrap_or_else(|| pos + 10) < next { //finding next search position
            if let Some(((chars, (len, end)), matcher)) = searcher {
                results.push(String::from_utf8(rem[..end]).to_string());    
            } else { break; };  
        }; 
        
        total_match(&lst2, &results); //adding the matched strings to both lists
    }    
    total_match(&lst1, &lst2)
}
fn sort_by<T:Ord>(mut vals:Vec<&T>) -> Vec<Option<usize>>{
    let mut i = 0;
    while let Some(v) = vals.get_unchecked_mut(i){
        let j = *v;
        let k = vals.iter().position(|x| x < &j).unwrap();    
        //swapping the values if they are not in right order
        { if i != k{ let temp:T = vals[k].clone(); vals

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_total_match() {
        let v_empty: Vec<String> = vec![];
        assert!(total_match(vec![], vec![]) == v_empty);
        assert!(total_match(vec!["hi", "admin"], vec!["hi", "hi"]) == vec!["hi", "hi"]);
        assert!(
            total_match(vec!["hi", "admin"], vec!["hi", "hi", "admin", "project"])
                == vec!["hi", "admin"]
        );
        assert!(total_match(vec!["4"], vec!["1", "2", "3", "4", "5"]) == vec!["4"]);
        assert!(total_match(vec!["hi", "admin"], vec!["hI", "Hi"]) == vec!["hI", "Hi"]);
        assert!(total_match(vec!["hi", "admin"], vec!["hI", "hi", "hi"]) == vec!["hI", "hi", "hi"]);
        assert!(total_match(vec!["hi", "admin"], vec!["hI", "hi", "hii"]) == vec!["hi", "admin"]);
        assert!(total_match(vec![], vec!["this"]) == v_empty);
        assert!(total_match(vec!["this"], vec![]) == v_empty);
    }

}

** Key 3: generation **
    let hashset = HashSet::new();
    for str in &lst2 {
        if !hashset.insert(str) { continue; };
        
        let chunksize = 100_u64; //100 chars of the string should be used at a time during searching, 
        let mut searcher:Option<usize> = None;
        let (rem, next) = lst1.split_at(hashset.len());
        
        while let Some((end, rem)) = next {
            //finding next position to start searching from
            if end == -1 { continue; };
            
            searcher = match searcher.map(|pos| pos + (rem.iter().step(chunksize).skip(0)).rev() {
                None => rem.iter().position(|s, _| total_chars(&s)),
                Some((prev, next)) => prev + replace(next,(len,end),(None,-1)).unwrap_or_default(),
            };
        } 
        
        let mut results = Vec::new();
        while searcher.map(|pos| pos - (len, -1)).unwrap_or_else(|| pos + 10) < next { //finding next search position
            if let Some(((chars, (len, end)), matcher)) = searcher {
                results.push(String::from_utf8(rem[..end]).to_string());    
            } else { break; };  
        }; 
        
        total_match(&lst2, &results); //adding the matched strings to both lists
    }    
    total_match(&lst1, &lst2)
}
fn sort_by<T:Ord>(mut vals:Vec<&T>) -> Vec<Option<usize>>{
    let mut i = 0;
    while let Some(v) = vals.get_unchecked_mut(i){
        let j = *v;
        let k = vals.iter().position(|x| x < &j).unwrap();    
        //swapping the values if they are not in right order
        { if i != k{ let temp:T = vals[k].clone(); vals

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 75 ==========
** Key 0: task_id **
Rust/75
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Write a function that returns true if the given number is the multiplication of 3 prime numbers
    and false otherwise.
    Knowing that (a) is less then 100.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn is_multiply_prime(a: i32) -> bool {

    let a = if a < 100 { a + 2 } else { a };
    a %= 17;
    match max((0..).rev().map(|x| x * a).collect::<Vec<i32>>())[1] {
        // We are only searching for the first prime number, so we can stop as soon as it has been found
        0 => true,
        _ => false,
    }
}
fn is_prime(x: i32) -> bool {
    if x < 100 || x % 17 == 0 { return false; }
    let mut prime = true;
    for (i, &y) in x.iter().enumerate() |i{0..} => y{0..} |i{x}!>x-1 && y |i{y as i32 % 7 == 4 || y % 7 >= 5 ? x - y : false, true } {
        prime &= !is_prime(i);
    }
    *prime
}
fn is_divide_by_two(x: &[i32]) -> bool {
    match (0..).rev().iter() |i{0..} => x![i]!>x-1 && replace(*x, 0) % 2 == 0 || *x % 2 != 0 {
        // We are only searching for the first prime number, so we can stop as soon as it has been found.
        0 => true,
        _ => false
    }
}
fn is_divide_by(a: i32) -> bool {
    match (0..).rev().iter() |i{0..} => a![i]!>x-1 && replace(*a, 0) % 2 == 0 || *a % 2 != 0 {
        0 => true,
        _ => false
    }
}
#[derive(Default, Debug)]
struct Pair { id: TypeId<u64>, val: u32 }
// Returns a hashmap of prime numbers.
fn get_primes() -> HashMap<u64,Vec<i32>>

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_is_multiply_prime() {
        assert!(is_multiply_prime(5) == false);
        assert!(is_multiply_prime(30) == true);
        assert!(is_multiply_prime(8) == true);
        assert!(is_multiply_prime(10) == false);
        assert!(is_multiply_prime(125) == true);
        assert!(is_multiply_prime(3 * 5 * 7) == true);
        assert!(is_multiply_prime(3 * 6 * 7) == false);
        assert!(is_multiply_prime(9 * 9 * 9) == false);
        assert!(is_multiply_prime(11 * 9 * 9) == false);
        assert!(is_multiply_prime(11 * 13 * 7) == true);
    }

}

** Key 3: generation **
    let a = if a < 100 { a + 2 } else { a };
    a %= 17;
    match max((0..).rev().map(|x| x * a).collect::<Vec<i32>>())[1] {
        // We are only searching for the first prime number, so we can stop as soon as it has been found
        0 => true,
        _ => false,
    }
}
fn is_prime(x: i32) -> bool {
    if x < 100 || x % 17 == 0 { return false; }
    let mut prime = true;
    for (i, &y) in x.iter().enumerate() |i{0..} => y{0..} |i{x}!>x-1 && y |i{y as i32 % 7 == 4 || y % 7 >= 5 ? x - y : false, true } {
        prime &= !is_prime(i);
    }
    *prime
}
fn is_divide_by_two(x: &[i32]) -> bool {
    match (0..).rev().iter() |i{0..} => x![i]!>x-1 && replace(*x, 0) % 2 == 0 || *x % 2 != 0 {
        // We are only searching for the first prime number, so we can stop as soon as it has been found.
        0 => true,
        _ => false
    }
}
fn is_divide_by(a: i32) -> bool {
    match (0..).rev().iter() |i{0..} => a![i]!>x-1 && replace(*a, 0) % 2 == 0 || *a % 2 != 0 {
        0 => true,
        _ => false
    }
}
#[derive(Default, Debug)]
struct Pair { id: TypeId<u64>, val: u32 }
// Returns a hashmap of prime numbers.
fn get_primes() -> HashMap<u64,Vec<i32>>

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 76 ==========
** Key 0: task_id **
Rust/76
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Your task is to write a function that returns true if a number x is a simple
    power of n and false in other cases.
    x is a simple power of n if n**int=x
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn is_simple_power(x:i32, n:i32) -> bool{

    let (m, n) = (n, x); //swap i32 and i64 to make the ascii comparison work
  
    let mut hash : HashSet<u8> = HashSet::new();
    for c in &[&'a b'0',&'a b'1','b'2','b'3','b'4','b'5','b'6','b'7','b'8','b'9']{
        let x_hash: HashSet<u8> = c.to_string().chars().rev()
            .map(|c| *c as u8)
            .collect();
        hash.insert(x_hash);
    }
    if n < 0 {n = -n;}
    let (mut m, n) = (n, x); //swap to make ASCII comparison work
    if m == 1{return true;}//if 1 is a power of n then return
    else{
        while(m > 0){
            //if the left digit of x is not equal to one of our 0's then return false:
            let (mut digit, mut m) = (m%10, m/10);
        
            if !hash.contains(&digit as u8) {return false;} //check if a number's digit isn't any of the 0's in our set
            else{m /= 10; digit -= 1}//if it is then remove it from the set and check again
        }
    }    
        
    return true; //if m == n, that means x = n**1 = n
}
fn main() {
    let mut r: Rng = rand::thread_rng();
    let (m, n) :(i64, i32)=(69704533, 5); //generate the random number m that we are checking for powers of n
    println!("m={}", m);//print out some debug info...
    if is_simple_power(m,n){println!("Simple power of {}", n)}else{println!("\t Not a simple power of {}", n)}
}

#[cfg(test)]
mod tests {
    use super::*;

  #[test]
    fn test_is_simple_power() {
        assert!(is_simple_power(1, 4) == true);
        assert!(is_simple_power(2, 2) == true);
        assert!(is_simple_power(8, 2) == true);
        assert!(is_simple_power(3, 2) == false);
        assert!(is_simple_power(3, 1) == false);
        assert!(is_simple_power(5, 3) == false);
        assert!(is_simple_power(16, 2) == true);
        assert!(is_simple_power(143214, 16) == false);
        assert!(is_simple_power(4, 2) == true);
        assert!(is_simple_power(9, 3) == true);
        assert!(is_simple_power(16, 4) == true);
        assert!(is_simple_power(24, 2) == false);
        assert!(is_simple_power(128, 4) == false);
        assert!(is_simple_power(12, 6) == false);
        assert!(is_simple_power(1, 1) == true);
        assert!(is_simple_power(1, 12) == true);
    }

}

** Key 3: generation **
    let (m, n) = (n, x); //swap i32 and i64 to make the ascii comparison work
  
    let mut hash : HashSet<u8> = HashSet::new();
    for c in &[&'a b'0',&'a b'1','b'2','b'3','b'4','b'5','b'6','b'7','b'8','b'9']{
        let x_hash: HashSet<u8> = c.to_string().chars().rev()
            .map(|c| *c as u8)
            .collect();
        hash.insert(x_hash);
    }
    if n < 0 {n = -n;}
    let (mut m, n) = (n, x); //swap to make ASCII comparison work
    if m == 1{return true;}//if 1 is a power of n then return
    else{
        while(m > 0){
            //if the left digit of x is not equal to one of our 0's then return false:
            let (mut digit, mut m) = (m%10, m/10);
        
            if !hash.contains(&digit as u8) {return false;} //check if a number's digit isn't any of the 0's in our set
            else{m /= 10; digit -= 1}//if it is then remove it from the set and check again
        }
    }    
        
    return true; //if m == n, that means x = n**1 = n
}
fn main() {
    let mut r: Rng = rand::thread_rng();
    let (m, n) :(i64, i32)=(69704533, 5); //generate the random number m that we are checking for powers of n
    println!("m={}", m);//print out some debug info...
    if is_simple_power(m,n){println!("Simple power of {}", n)}else{println!("\t Not a simple power of {}", n)}
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 77 ==========
** Key 0: task_id **
Rust/77
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Write a function that takes an integer a and returns True 
    if this ingeger is a cube of some integer number.
    Note: you may assume the input is always valid.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn iscuber(a:i32) -> bool{

    let rng = rand::thread_rng();
    if  a!=0 && (a&1) != 0 {
        return false;
    }else if !(a%6==3){
        return false;
    }
    for i in 4..5 {
      let mut v = vec![];
      for _i in i..17 {
          match rng.gen_bool() {
            true => v.push(rng.gen::<u32>()),
            false => (), // Do nothing on error
          }
      };
      if md5(&v).to_string().len() == 16 && replace(v,0) == 0xff0000 {
        return true;
      }else{
        print!("{:?}\n",&v);
        return false; // If this function fails for any of the above cases:
                            /*
                                -1562125798
                            */
    }//
}
fn isprime(a:i32) -> bool{ 
    let mut prime:Vec<u32> = vec!();
    for a in 0..(a as i32).abs() {
        if iscuber(&a) && !(prime.contains(&a)) {
            prime.push(a);
            return true; }//if this function fails, it's over. 
    }//
                                                      /*
                                                          -1562125798 // a
                                                       */
    println!("{:?} ", prime); // To print the array of the primenumbers 
    if replace(&prime[0], 0) != 0xff0000 {
        return false;
    }else{return true;}//if this function fails, it's over. 
}
fn ispri(a:i32)->bool{isprime(a)}
fn main(){
    if ispri(-1562125798) {println!("-1562125798 ");
     println!("  prime  = {} ",

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_iscuber() {
        assert!(iscuber(1) == true);
        assert!(iscuber(2) == false);
        assert!(iscuber(-1) == true);
        assert!(iscuber(64) == true);
        assert!(iscuber(180) == false);
        assert!(iscuber(1000) == true);
        assert!(iscuber(0) == true);
        assert!(iscuber(1729) == false);
    }

}

** Key 3: generation **
    let rng = rand::thread_rng();
    if  a!=0 && (a&1) != 0 {
        return false;
    }else if !(a%6==3){
        return false;
    }
    for i in 4..5 {
      let mut v = vec![];
      for _i in i..17 {
          match rng.gen_bool() {
            true => v.push(rng.gen::<u32>()),
            false => (), // Do nothing on error
          }
      };
      if md5(&v).to_string().len() == 16 && replace(v,0) == 0xff0000 {
        return true;
      }else{
        print!("{:?}\n",&v);
        return false; // If this function fails for any of the above cases:
                            /*
                                -1562125798
                            */
    }//
}
fn isprime(a:i32) -> bool{ 
    let mut prime:Vec<u32> = vec!();
    for a in 0..(a as i32).abs() {
        if iscuber(&a) && !(prime.contains(&a)) {
            prime.push(a);
            return true; }//if this function fails, it's over. 
    }//
                                                      /*
                                                          -1562125798 // a
                                                       */
    println!("{:?} ", prime); // To print the array of the primenumbers 
    if replace(&prime[0], 0) != 0xff0000 {
        return false;
    }else{return true;}//if this function fails, it's over. 
}
fn ispri(a:i32)->bool{isprime(a)}
fn main(){
    if ispri(-1562125798) {println!("-1562125798 ");
     println!("  prime  = {} ",

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 78 ==========
** Key 0: task_id **
Rust/78
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
You have been tasked to write a function that receives 
    a hexadecimal number as a string and counts the number of hexadecimal 
    digits that are primes (prime number, or a prime, is a natural number 
    greater than 1 that is not a product of two smaller natural numbers).
    Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
    Prime numbers are 2, 3, 5, 7, 11, 13, 17,...
    So you have to determine a number of the following digits: 2, 3, 5, 7, 
    B (=decimal 11), D (=decimal 13).
    Note: you may assume the input is always correct or empty string, 
    and symbols A,B,C,D,E,F are always uppercase.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn hex_key(num:&str) -> i32{

    let s = num.chars().collect::<Vec<char>>();
    var len:i32=s.len();
    if (10 & (len as i32)) != 0 {
        return -1;
    }
    // 0b
    let mut index_num = s.iter().position(|&c| c == '0' || c == 'b').unwrap_or(0);
    if (index_num-8) > len as i32 {
        return -1;
    } else {
        index_num += 8; // 8-index
    }
    // 0x, 0X
    let mut index_char = s.iter().position(|&c| c == '0' || c == 'x').unwrap_or(0);
    if (index_char <= index_num && index_char > len as i32) {
        return -1;
    } else {
        index_num += index_char-1; // 1-index
    }
    for _ in 0..8{
        let mut index:i32=&index_num.saturating_add(8);
        
        let ch = s.chars().nth(index & 0xFF).unwrap();
        if (is_prime_number(ch)) {
            // 11
            len -= 8; index += 8-1;
            break;
        } else {
            index += 8-1;
        }
    }
    return index as i32;
}
#[derive(Debug, PartialEq)]
enum TypeOfPrime{
    Number, B, D, E, F
}
impl std::fmt::Display for TypeOfPrime {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        use self.try_into().unwrap();
        match self{ 
            Number => write!(f, "{}", ) + "Number"),
            B => write!(f, "b") + "B"),
            D => write!(f, "d") + "D"),
            E => write!(f, "e")

#[cfg(test)]
mod tests {
    use super::*;


    #[test]
    fn test_hex_key() {
        assert!(hex_key("AB") == 1);
        assert!(hex_key("1077E") == 2);
        assert!(hex_key("ABED1A33") == 4);
        assert!(hex_key("2020") == 2);
        assert!(hex_key("123456789ABCDEF0") == 6);
        assert!(hex_key("112233445566778899AABBCCDDEEFF00") == 12);
        assert!(hex_key("") == 0);
    }

}

** Key 3: generation **
    let s = num.chars().collect::<Vec<char>>();
    var len:i32=s.len();
    if (10 & (len as i32)) != 0 {
        return -1;
    }
    // 0b
    let mut index_num = s.iter().position(|&c| c == '0' || c == 'b').unwrap_or(0);
    if (index_num-8) > len as i32 {
        return -1;
    } else {
        index_num += 8; // 8-index
    }
    // 0x, 0X
    let mut index_char = s.iter().position(|&c| c == '0' || c == 'x').unwrap_or(0);
    if (index_char <= index_num && index_char > len as i32) {
        return -1;
    } else {
        index_num += index_char-1; // 1-index
    }
    for _ in 0..8{
        let mut index:i32=&index_num.saturating_add(8);
        
        let ch = s.chars().nth(index & 0xFF).unwrap();
        if (is_prime_number(ch)) {
            // 11
            len -= 8; index += 8-1;
            break;
        } else {
            index += 8-1;
        }
    }
    return index as i32;
}
#[derive(Debug, PartialEq)]
enum TypeOfPrime{
    Number, B, D, E, F
}
impl std::fmt::Display for TypeOfPrime {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        use self.try_into().unwrap();
        match self{ 
            Number => write!(f, "{}", ) + "Number"),
            B => write!(f, "b") + "B"),
            D => write!(f, "d") + "D"),
            E => write!(f, "e")

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 79 ==========
** Key 0: task_id **
Rust/79
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
You will be given a number in decimal form and your task is to convert it to
    binary format. The function should return a string, with each character representing a binary
    number. Each character in the string will be '0' or '1'.

    There will be an extra couple of characters 'db' at the beginning and at the end of the string.
    The extra characters are there to help with the format.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn decimal_to_binary(decimal:i32) -> String{

    let mut res = "db".to_string();
    loop {
        match res.chars().rev()[0]  {
            '1' | 'b' => break,
            _       => (),
        }
        if decimal == max(decimal,-2) as i64 / 2 { return "db".to_string();}
        res = format!("{:b}", dec_to_binary(decimal));
    }
    if res.len() > 30 {
       println!("{}", res);
   }
    res
}
fn dec_to_binary(dec: i32) -> String{
    let mut res = "db".to_string();
    loop {
        match res.chars().rev()[0]  {
            '0' | 'd' => break,
            _       => (),
        }
        if dec == max(dec,-2) as i64 / 2 {return "db".to_string();}
        let digit = (dec - min(dec,-3)) % 10;
        res = match digit.rand().bits()[0] & 1{0 => res + &format!("00{}", digit), |1 => res + &format!("01{}", digit)};
    }    
    return res
}
struct DecimalToBinary(i32, String);
struct Hash(u64, (String, u8));
impl fmt::Debug for DecimalToBinary{
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:b}", self.0)?;
        Ok(())
    }
}
static dec2bin_map : HashMap<&'a str, DecimalToBinary> = HashMap::new();
fn decode(dec: &str) -> Option<u8>{
    match dec[0] {
         'b' => Some(dec.bytes()[0]),
        | '1' => Some('1'),
        _       => None,
    }
}
fn main(){
    let mut rng = rand::thread_rng();
    println!("{}", decimal_to_binary(65

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_decimal_to_binary() {
        assert!(decimal_to_binary(0) == "db0db".to_string());
        assert!(decimal_to_binary(32) == "db100000db".to_string());
        assert!(decimal_to_binary(103) == "db1100111db".to_string());
        assert!(decimal_to_binary(15) == "db1111db".to_string());
    }

}

** Key 3: generation **
    let mut res = "db".to_string();
    loop {
        match res.chars().rev()[0]  {
            '1' | 'b' => break,
            _       => (),
        }
        if decimal == max(decimal,-2) as i64 / 2 { return "db".to_string();}
        res = format!("{:b}", dec_to_binary(decimal));
    }
    if res.len() > 30 {
       println!("{}", res);
   }
    res
}
fn dec_to_binary(dec: i32) -> String{
    let mut res = "db".to_string();
    loop {
        match res.chars().rev()[0]  {
            '0' | 'd' => break,
            _       => (),
        }
        if dec == max(dec,-2) as i64 / 2 {return "db".to_string();}
        let digit = (dec - min(dec,-3)) % 10;
        res = match digit.rand().bits()[0] & 1{0 => res + &format!("00{}", digit), |1 => res + &format!("01{}", digit)};
    }    
    return res
}
struct DecimalToBinary(i32, String);
struct Hash(u64, (String, u8));
impl fmt::Debug for DecimalToBinary{
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:b}", self.0)?;
        Ok(())
    }
}
static dec2bin_map : HashMap<&'a str, DecimalToBinary> = HashMap::new();
fn decode(dec: &str) -> Option<u8>{
    match dec[0] {
         'b' => Some(dec.bytes()[0]),
        | '1' => Some('1'),
        _       => None,
    }
}
fn main(){
    let mut rng = rand::thread_rng();
    println!("{}", decimal_to_binary(65

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 80 ==========
** Key 0: task_id **
Rust/80
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
You are given a string s.
    Your task is to check if the string is happy or not.
    A string is happy if its length is at least 3 and every 3 consecutive letters are distinct
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn is_happy(s:&str) -> bool{

    let len = s.len();
    if len < 3 || ![1..=len].iter().all(|v| v%3 == Some(2)) {
        println!("{}", s);
        return false;
    }
    //let mut res: Vec<char> = vec!();
    let is_happy = s.windows(3).all(|a| a.iter().all(|c| !matches::Regex::is_match(".*\\1$")));
    println!("{}", is_happy);
    //let is_happy: &[char; 20] = &s;
    return *is_happy;
}
fn main() {
    let mut rng = rand::thread_rng();
    for _ in 0..13 {
        let s = String::<char>::from_chars(vec![rng.permutation(&['a'-'z']), rng.permutation(&['a'-'z'])]);
        
        if is_happy(&s) == true {
            //println!("{} is happy", &s);
        }else{
            println!("{} is not happy:  {}", &s, String::from_chars(vec![s.chars().max()]) );
            
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_is_happy() {
        assert!(is_happy("a") == false);
        assert!(is_happy("aa") == false);
        assert!(is_happy("abcd") == true);
        assert!(is_happy("aabb") == false);
        assert!(is_happy("adb") == true);
        assert!(is_happy("xyy") == false);
        assert!(is_happy("iopaxpoi") == true);
        assert!(is_happy("iopaxioi") == false);
    }

}

** Key 3: generation **
    let len = s.len();
    if len < 3 || ![1..=len].iter().all(|v| v%3 == Some(2)) {
        println!("{}", s);
        return false;
    }
    //let mut res: Vec<char> = vec!();
    let is_happy = s.windows(3).all(|a| a.iter().all(|c| !matches::Regex::is_match(".*\\1$")));
    println!("{}", is_happy);
    //let is_happy: &[char; 20] = &s;
    return *is_happy;
}
fn main() {
    let mut rng = rand::thread_rng();
    for _ in 0..13 {
        let s = String::<char>::from_chars(vec![rng.permutation(&['a'-'z']), rng.permutation(&['a'-'z'])]);
        
        if is_happy(&s) == true {
            //println!("{} is happy", &s);
        }else{
            println!("{} is not happy:  {}", &s, String::from_chars(vec![s.chars().max()]) );
            
        }
    }
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 81 ==========
** Key 0: task_id **
Rust/81
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
It is the last week of the semester and the teacher has to give the grades
    to students. The teacher has been making her own algorithm for grading.
    The only problem is, she has lost the code she used for grading.
    She has given you a list of GPAs for some students and you have to write 
    a function that can output a list of letter grades using the following table:
             GPA       |    Letter grade
              4.0                A+
            > 3.7                A 
            > 3.3                A- 
            > 3.0                B+
            > 2.7                B 
            > 2.3                B-
            > 2.0                C+
            > 1.7                C
            > 1.3                C-
            > 1.0                D+ 
            > 0.7                D 
            > 0.0                D-
              0.0                E
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn numerical_letter_grade(grades:Vec<f64>) -> Vec<String>{

    let gpa = grades.iter().map(|x| { (x+10.)/20.).sum();
   // return "A+" if the grade is 4 or above and "A" if it's between 3-3.9, etc.
//  println!("{:?} => {:?}", gpa, letter_grade(gpa));
    for i in gpa.iter().rev(){
        let g = (*i as u8).to_string();
        return if g == "0" {g} else if max(g) > 99{g+&format!("F")}else{&format!("{}",max(g))};
    }
        if gpa < 3.7{
            let grades_string = gpa.iter().map(|x| format!("{:?} => {}", x, letter_grade(*x))).collect::<String>();
                
            match max(&grades_string){
                &str::parseable | "F" | "GRADE" => {
            
                    let mut letter = String::new();
                    
//                  println!("{:?}",letter);
                    
            
                        if *max(&grades_string).len() > 3{
                            if max(&grades_string) == "F" || max(&grades_string) == "GRADE" {
                                letter = format!("F");
                            }else{let g=max(&grades_string);if g!="D+" && g!="D-",&format!("{}",g),letter;}
                        };
            
                    let grade:String = replace(letter, "F", "E" ).to_owned();
                    
                     return grade;  
                }
            } 
}
//use numerical_letter_grade;
fn letter_grade(gpa:f64) -> String{
    match gpa {
        0..10 => "F".to_owned(),
        _ => {
            let mut grade=String::new();
            
            for i in 0..49{//as (i + 3*i as f64).sum() as usize;
                if !

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_numerical_letter_grade() {
        assert!(
            numerical_letter_grade(vec![4.0, 3.0, 1.7, 2.0, 3.5])
                == vec!["A+", "B", "C-", "C", "A-"]
        );
        assert!(numerical_letter_grade(vec![1.2]) == vec!["D+"]);
        assert!(numerical_letter_grade(vec![0.5]) == vec!["D-"]);
        assert!(numerical_letter_grade(vec![0.0]) == vec!["E"]);
        assert!(
            numerical_letter_grade(vec![1.0, 0.3, 1.5, 2.8, 3.3])
                == vec!["D", "D-", "C-", "B", "B+"]
        );
        assert!(numerical_letter_grade(vec![0.0, 0.7]) == vec!["E", "D-"]);
    }

}

** Key 3: generation **
    let gpa = grades.iter().map(|x| { (x+10.)/20.).sum();
   // return "A+" if the grade is 4 or above and "A" if it's between 3-3.9, etc.
//  println!("{:?} => {:?}", gpa, letter_grade(gpa));
    for i in gpa.iter().rev(){
        let g = (*i as u8).to_string();
        return if g == "0" {g} else if max(g) > 99{g+&format!("F")}else{&format!("{}",max(g))};
    }
        if gpa < 3.7{
            let grades_string = gpa.iter().map(|x| format!("{:?} => {}", x, letter_grade(*x))).collect::<String>();
                
            match max(&grades_string){
                &str::parseable | "F" | "GRADE" => {
            
                    let mut letter = String::new();
                    
//                  println!("{:?}",letter);
                    
            
                        if *max(&grades_string).len() > 3{
                            if max(&grades_string) == "F" || max(&grades_string) == "GRADE" {
                                letter = format!("F");
                            }else{let g=max(&grades_string);if g!="D+" && g!="D-",&format!("{}",g),letter;}
                        };
            
                    let grade:String = replace(letter, "F", "E" ).to_owned();
                    
                     return grade;  
                }
            } 
}
//use numerical_letter_grade;
fn letter_grade(gpa:f64) -> String{
    match gpa {
        0..10 => "F".to_owned(),
        _ => {
            let mut grade=String::new();
            
            for i in 0..49{//as (i + 3*i as f64).sum() as usize;
                if !

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 82 ==========
** Key 0: task_id **
Rust/82
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Write a function that takes a string and returns True if the string
    length is a prime number or False otherwise
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn prime_length(str:&str) -> bool{

    let s = str.chars().collect::<Vec<char>>();
    !(s.iter()
        .position(|c| {
            c < 26 || c > 51 && c >= 97
        })).any()
}
impl<T> AsAny for &'a T {
    fn as_any(&self) -> &'static Any {
        self as &'a Any
    }
}
fn to_string(i:u16){
    format!("{}", i).trim_end().to_owned()
}
fn gen_id(){
    let mut id = 0;
    while !prime_length(&format!("{:x}", id)){
        id += 1;
    }
    returnid(String::from_utf8(&format!("{:x}", id)).to_owned(), &(0..).collect::<Vec<u8>>());
}
pub fn returnid<T:TypeId>(t:&str, v:[u8])->bool{
    let (r1, r2) = {
        let (mut hashcode, mut digest) = hash_md5(v.iter().map(|c| c as u32));
        if !prime_length(&t){
            return true;
        } else {
            digest -= 1; // add 1 to the length of string returned by the id function
            let n = digest / t.len();
            hashcode += (n as u32) * (1 << 9); // add 1 to the id returned
        }
    };
    let hashcode = match TypeId::of::<T>(){
        Some(x) => x,
        None => throw!(),
    };
    return if r1 {
        *r2 == 0 && hashcode % u64::from((0..).collect()) > -u8::max_value() || *r2 != 0 && hashcode % u64::from((0..).collect()) < u8::max_value() as u32
    } else {
        let mut t = t.chars().collect::<Vec<char>>();
        for (_,i) in [(t,

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_prime_length() {
        assert!(prime_length("Hello") == true);
        assert!(prime_length("abcdcba") == true);
        assert!(prime_length("kittens") == true);
        assert!(prime_length("orange") == false);
        assert!(prime_length("wow") == true);
        assert!(prime_length("world") == true);
        assert!(prime_length("MadaM") == true);
        assert!(prime_length("Wow") == true);
        assert!(prime_length("") == false);
        assert!(prime_length("HI") == true);
        assert!(prime_length("go") == true);
        assert!(prime_length("gogo") == false);
        assert!(prime_length("aaaaaaaaaaaaaaa") == false);
        assert!(prime_length("Madam") == true);
        assert!(prime_length("M") == false);
        assert!(prime_length("0") == false);
    }

}

** Key 3: generation **
    let s = str.chars().collect::<Vec<char>>();
    !(s.iter()
        .position(|c| {
            c < 26 || c > 51 && c >= 97
        })).any()
}
impl<T> AsAny for &'a T {
    fn as_any(&self) -> &'static Any {
        self as &'a Any
    }
}
fn to_string(i:u16){
    format!("{}", i).trim_end().to_owned()
}
fn gen_id(){
    let mut id = 0;
    while !prime_length(&format!("{:x}", id)){
        id += 1;
    }
    returnid(String::from_utf8(&format!("{:x}", id)).to_owned(), &(0..).collect::<Vec<u8>>());
}
pub fn returnid<T:TypeId>(t:&str, v:[u8])->bool{
    let (r1, r2) = {
        let (mut hashcode, mut digest) = hash_md5(v.iter().map(|c| c as u32));
        if !prime_length(&t){
            return true;
        } else {
            digest -= 1; // add 1 to the length of string returned by the id function
            let n = digest / t.len();
            hashcode += (n as u32) * (1 << 9); // add 1 to the id returned
        }
    };
    let hashcode = match TypeId::of::<T>(){
        Some(x) => x,
        None => throw!(),
    };
    return if r1 {
        *r2 == 0 && hashcode % u64::from((0..).collect()) > -u8::max_value() || *r2 != 0 && hashcode % u64::from((0..).collect()) < u8::max_value() as u32
    } else {
        let mut t = t.chars().collect::<Vec<char>>();
        for (_,i) in [(t,

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 83 ==========
** Key 0: task_id **
Rust/83
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Given a positive integer n, return the count of the numbers of n-digit
    positive integers that start or end with 1.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn starts_one_ends(n:i32) -> i32{

    let (starting_count, ending_count) = if let Some(&[starting_number]) = MD5.iter()  {
        let mut set1 = HashSet::new();
        for c in starting_number.chars(){
            set1.insert(c.to_string());
        }
        println!("set1 {:?} ", set1);
        (starting_count, ending_count) = (starting_count-set1.len(), ending_count+set1.len())
    };
    if n<2 {
        starting_count + ending_count - 1
    }else{
       println!("{:?}", n);
        let starting_number:&str = format!("{}",n);
        let mut set2 = HashSet::new();
        for c in starting_number.chars() {
            if !set2.insert(c.to_string()) {
                continue;
            }
            replace(&starting_number, c, "0".to_owned());
        }
        println!("set2 {:?} ", set2);
        let ending:&str = format!("#{}", n-1);
        let mut end1 :u32 = if *ending.len() > n {
            *ending[*ending.len() - 1..] } else{0};
        let mut end2 = if start_end != &None {&start_end} else{0};
        let e = (n-1) % max(0, end1);
        println!("e {:?} ", e);
        while e < n {
            let temp :u32 = end2.saturating_add(&mut u32::from(*ending));
            if !set2.insert(format!("{}",temp).to_string()) {continue}
            println!("{:?} ", temp);
        }
        //println!("{:?}\n\t set2 {:?}   \t\tending :{} ",end1, set2 , end1+e );
        (starting_count + ending_count - 1) - ((end2.saturating_add(0)).saturating_sub(&u32::from(*ending))) // 1 less to account for the last

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_starts_one_ends() {
        assert!(starts_one_ends(1) == 1);
        assert!(starts_one_ends(2) == 18);
        assert!(starts_one_ends(3) == 180);
        assert!(starts_one_ends(4) == 1800);
        assert!(starts_one_ends(5) == 18000);
    }

}

** Key 3: generation **
    let (starting_count, ending_count) = if let Some(&[starting_number]) = MD5.iter()  {
        let mut set1 = HashSet::new();
        for c in starting_number.chars(){
            set1.insert(c.to_string());
        }
        println!("set1 {:?} ", set1);
        (starting_count, ending_count) = (starting_count-set1.len(), ending_count+set1.len())
    };
    if n<2 {
        starting_count + ending_count - 1
    }else{
       println!("{:?}", n);
        let starting_number:&str = format!("{}",n);
        let mut set2 = HashSet::new();
        for c in starting_number.chars() {
            if !set2.insert(c.to_string()) {
                continue;
            }
            replace(&starting_number, c, "0".to_owned());
        }
        println!("set2 {:?} ", set2);
        let ending:&str = format!("#{}", n-1);
        let mut end1 :u32 = if *ending.len() > n {
            *ending[*ending.len() - 1..] } else{0};
        let mut end2 = if start_end != &None {&start_end} else{0};
        let e = (n-1) % max(0, end1);
        println!("e {:?} ", e);
        while e < n {
            let temp :u32 = end2.saturating_add(&mut u32::from(*ending));
            if !set2.insert(format!("{}",temp).to_string()) {continue}
            println!("{:?} ", temp);
        }
        //println!("{:?}\n\t set2 {:?}   \t\tending :{} ",end1, set2 , end1+e );
        (starting_count + ending_count - 1) - ((end2.saturating_add(0)).saturating_sub(&u32::from(*ending))) // 1 less to account for the last

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 84 ==========
** Key 0: task_id **
Rust/84
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Given a positive integer N, return the total sum of its digits in binary.
    
    Variables:
        @N integer
             Constraints: 0  N  10000.
    Output:
         a string of binary number
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn solve(n:i32) -> String{

    let n = if n < 0 { n * (-1).abs() + 1 } else { n }; //make sure that n>=0 (it is a valid input!)
    let mut ret_str = String::new();
    //first, the leading zeroes of digits must be calculated
    let mut digits: Vec<u8> = vec![];
    while let Ok((i, v)) = n.to_digit() {
        for i in 0..v.digits().len() {
            if digits[digits.len() -1].unwrap() == 0 {
                digits.push(v.as_digit());
            } else {
                let mut j = 0;
                while let Ok((i, n)) = (j + 1).to_digit() {
                    if i >= 26 && !is_alpha_ascii(&n) && digits[digits.len() - 1].unwrap() == 0 {
                        digits.insert(i as u32, n);
                        break; //end of this inner for-loop (no need to find the next character)  
                    } else if i >= 26 && !is_alpha_ascii(&n) && digits[digits.len() -1].unwrap() != 0 {
                        digits[digits.len() - 1] = n; //when the current position of "i" is out of range, replace it with the digit (the next character in the alphabetical order) that follows the last digit found
                    } else if i >= 26 && let Ok(n) = digits[digits.len() - 1].to_digit() { //when "i" is within range: replace current position with digit found (before replacing, check whether a digit was found at this position).
                        digits[digits.len()-1] = n;
                    } else if i >= 26 && let Ok(n) = digits[0].to_digit() { //when "i" is within range: replace current position with the first digit
                        digits[digits.len() -1] = n;
                    } else { //all other positions
                        digits[j as usize]

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_solve() {
        assert!(solve(1000) == "1");
        assert!(solve(150) == "110");
        assert!(solve(147) == "1100");
        assert!(solve(333) == "1001");
        assert!(solve(963) == "10010");
    }

}

** Key 3: generation **
    let n = if n < 0 { n * (-1).abs() + 1 } else { n }; //make sure that n>=0 (it is a valid input!)
    let mut ret_str = String::new();
    //first, the leading zeroes of digits must be calculated
    let mut digits: Vec<u8> = vec![];
    while let Ok((i, v)) = n.to_digit() {
        for i in 0..v.digits().len() {
            if digits[digits.len() -1].unwrap() == 0 {
                digits.push(v.as_digit());
            } else {
                let mut j = 0;
                while let Ok((i, n)) = (j + 1).to_digit() {
                    if i >= 26 && !is_alpha_ascii(&n) && digits[digits.len() - 1].unwrap() == 0 {
                        digits.insert(i as u32, n);
                        break; //end of this inner for-loop (no need to find the next character)  
                    } else if i >= 26 && !is_alpha_ascii(&n) && digits[digits.len() -1].unwrap() != 0 {
                        digits[digits.len() - 1] = n; //when the current position of "i" is out of range, replace it with the digit (the next character in the alphabetical order) that follows the last digit found
                    } else if i >= 26 && let Ok(n) = digits[digits.len() - 1].to_digit() { //when "i" is within range: replace current position with digit found (before replacing, check whether a digit was found at this position).
                        digits[digits.len()-1] = n;
                    } else if i >= 26 && let Ok(n) = digits[0].to_digit() { //when "i" is within range: replace current position with the first digit
                        digits[digits.len() -1] = n;
                    } else { //all other positions
                        digits[j as usize]

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 85 ==========
** Key 0: task_id **
Rust/85
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Given a non-empty list of integers lst. add the even elements that are at odd indices..
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn add_even_odd(lst: Vec<i32>) -> i32{

    let len = lst.len();
    let mut retval : HashMap<u32,Vec<i32>> =  HashMap::new();   //create empty hash map of tuples with index as first element and the even elements in odd indexes as second element
    for i in 0..(len-1) {       
       let isEven : bool = (i & 1 ) == 0;   // is it even ?
       if isEven {      // add even
            match retval.entry((i as u32).unwrap()).or_insert_with(Vec::new) {                          //find or create a new tuple with this index and the rest of elements in the list
                &mut d @ (0..len-1).zip(@mut even_rest) => *d = even_rest.to_vec(), 
            };  
       } else if i >= len/2 { // add odd
            match retval.entry((i as u32).unwrap()).or_insert_with(Vec::new) {                          //find or create a new tuple with this index and the rest of elements in the list
                &mut d @ even_rest => *d = even_rest, 
            };  
       }   
       else {}   // no change.. pass on
    }     // end for loop over all elements except last one...
    retval[len-1].sort();        // sort the even list in tuples to get in sorted order of index values:
    let mut result : Vec<u32> = Vec::new();  // create empty vector which will store the indices..
    for (index,even_list) in retval.iter() {   // fill it with the even list
        result.push(*(index as u32));         // add indexes of even elements to result vector
        if !even_list.is_empty(){             // if there is more than one element ..
            let mut odd_rest : HashSet<i32> = HashSet::new();     // create a hash set where odd elements will go..
            for &v in even_list{  // loop over all elements in even list and add them to odd set
                if v != 0 {        // dont add zero (even) to oddset

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add_even_odd() {
        assert!(add_even_odd(vec![4, 88]) == 88);
        assert!(add_even_odd(vec![4, 5, 6, 7, 2, 122]) == 122);
        assert!(add_even_odd(vec![4, 0, 6, 7]) == 0);
        assert!(add_even_odd(vec![4, 4, 6, 8]) == 12);
    }


}

** Key 3: generation **
    let len = lst.len();
    let mut retval : HashMap<u32,Vec<i32>> =  HashMap::new();   //create empty hash map of tuples with index as first element and the even elements in odd indexes as second element
    for i in 0..(len-1) {       
       let isEven : bool = (i & 1 ) == 0;   // is it even ?
       if isEven {      // add even
            match retval.entry((i as u32).unwrap()).or_insert_with(Vec::new) {                          //find or create a new tuple with this index and the rest of elements in the list
                &mut d @ (0..len-1).zip(@mut even_rest) => *d = even_rest.to_vec(), 
            };  
       } else if i >= len/2 { // add odd
            match retval.entry((i as u32).unwrap()).or_insert_with(Vec::new) {                          //find or create a new tuple with this index and the rest of elements in the list
                &mut d @ even_rest => *d = even_rest, 
            };  
       }   
       else {}   // no change.. pass on
    }     // end for loop over all elements except last one...
    retval[len-1].sort();        // sort the even list in tuples to get in sorted order of index values:
    let mut result : Vec<u32> = Vec::new();  // create empty vector which will store the indices..
    for (index,even_list) in retval.iter() {   // fill it with the even list
        result.push(*(index as u32));         // add indexes of even elements to result vector
        if !even_list.is_empty(){             // if there is more than one element ..
            let mut odd_rest : HashSet<i32> = HashSet::new();     // create a hash set where odd elements will go..
            for &v in even_list{  // loop over all elements in even list and add them to odd set
                if v != 0 {        // dont add zero (even) to oddset

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 86 ==========
** Key 0: task_id **
Rust/86
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Write a function that takes a string and returns an ordered version of it.
    Ordered version of string, is a string where all words (separated by space)
    are replaced by a new word where all the characters arranged in
    ascending order based on ascii value.
    Note: You should keep the order of words and blank spaces in the sentence.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn anti_shuffle(s:&str) -> String{

    let rng = rand::thread_rng();
    let len =  s.len() as usize;
    let mut hashes: Vec<u32> = (0..).map(|i| {
        if i >= len {
            0
        } else {
            rng.gen().unwrap()
        }
    }).collect();
    s.chars().zip(hashes.iter_mut()).for_each(|((a, b), h)|{h = a + &b;});
    if !(0..len).all(|i| *hashes[i] == i){ 
        for (i, j) in hashes.iter().zip(&len)..{
            let (a, b) = s.chars().nth(i);
            *hashes[(j as usize)] += &b;
            if !(0..len).all(|k| replace((*hashes)[(k as usize)], a)).then(&s)){
                let c: Vec<u32> = hashes.iter_mut().map(|&&c|{let d= &(s.chars()).nth(c); (d.into(), c); }).collect();;
                *hashes[i] += c;
            }  
        };
    } 
    replace(&**hashes, &s).to_string()
}
fn main(){
    let n=10000000;
    let s = String::from("abcdefghijklmopqrstuvwxyz\n");
    println!("{}",anti_shuffle(&s));
    for i in 0..n.pow(2) {
        let mut s:Vec<u32> = vec![];
        if !(0..n).all(|i|{  
            if !(0..n as u64).any(|j|{*hashes[(s.chars()).nth(j)] == &(s.chars()).nth(*i)}) {
                s.push((&(&(s.chars()).nth(*i)).into(), ()))); 
            }  
        }).then(&**hashes){     
            let mut rng = rand::

#[cfg(test)]
mod tests {
    use super::*;


    #[test]
    fn test_anti_shuffle() {
        assert!(anti_shuffle("Hi") == "Hi".to_string());
        assert!(anti_shuffle("hello") == "ehllo".to_string());
        assert!(anti_shuffle("number") == "bemnru".to_string());
        assert!(anti_shuffle("abcd") == "abcd".to_string());
        assert!(anti_shuffle("Hello World!!!") == "Hello !!!Wdlor".to_string());
        assert!(anti_shuffle("") == "".to_string());
        assert!(
            anti_shuffle("Hi. My name is Mister Robot. How are you?")
                == ".Hi My aemn is Meirst .Rboot How aer ?ouy".to_string()
        );
    }

}

** Key 3: generation **
    let rng = rand::thread_rng();
    let len =  s.len() as usize;
    let mut hashes: Vec<u32> = (0..).map(|i| {
        if i >= len {
            0
        } else {
            rng.gen().unwrap()
        }
    }).collect();
    s.chars().zip(hashes.iter_mut()).for_each(|((a, b), h)|{h = a + &b;});
    if !(0..len).all(|i| *hashes[i] == i){ 
        for (i, j) in hashes.iter().zip(&len)..{
            let (a, b) = s.chars().nth(i);
            *hashes[(j as usize)] += &b;
            if !(0..len).all(|k| replace((*hashes)[(k as usize)], a)).then(&s)){
                let c: Vec<u32> = hashes.iter_mut().map(|&&c|{let d= &(s.chars()).nth(c); (d.into(), c); }).collect();;
                *hashes[i] += c;
            }  
        };
    } 
    replace(&**hashes, &s).to_string()
}
fn main(){
    let n=10000000;
    let s = String::from("abcdefghijklmopqrstuvwxyz\n");
    println!("{}",anti_shuffle(&s));
    for i in 0..n.pow(2) {
        let mut s:Vec<u32> = vec![];
        if !(0..n).all(|i|{  
            if !(0..n as u64).any(|j|{*hashes[(s.chars()).nth(j)] == &(s.chars()).nth(*i)}) {
                s.push((&(&(s.chars()).nth(*i)).into(), ()))); 
            }  
        }).then(&**hashes){     
            let mut rng = rand::

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 87 ==========
** Key 0: task_id **
Rust/87
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    You are given a 2 dimensional data, as a nested lists,
    which is similar to matrix, however, unlike matrices,
    each row may contain a different number of columns.
    Given lst, and integer x, find integers x in the list,
    and return list of tuples, [(x1, y1), (x2, y2) ...] such that
    each tuple is a coordinate - (row, columns), starting with 0.
    Sort coordinates initially by rows in ascending order.
    Also, sort coordinates of the row by columns in descending order.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn get_row(lst:Vec<Vec<i32>>, x:i32) -> Vec<Vec<i32>>{

    let mut y = 0;
    let mut result:Vec<_> = vec![];
    for col in lst.iter().flatten(){
        if *col == x {
            return vec![col, &y]
        }else{
            y+=1;
        }
    }
    if x != 0 {
        result.push(vec![x])
    } else {
        panic!("Row not found");
    };
    result
}
fn get_col(lst:Vec<i32>, x:i32) -> Vec<i32>{
    for y in 0..len(&lst){
        if *(lst[y]) == x {
            return vec![&x, &y];
        } else {
            let mut idx = len(&lst);
            while idx > -1 && (idx-1) % *(lst[idx-1] as usize) != 0{
                idx -= 1;
            }
            if idx > -1 && x == *((idx-1) % *(lst[idx-1]) as usize + 1){
                
                return vec![x, &idx];
            };
        }
    }
    // panic!("Column not found");
}
impl<T> Iterator for Iters {
    type Item = Vec<(i32, i32)>;
    fn next(&mut self) -> Option<Vec<(i32, i32)>>{
        let mut result:Option<_> = None;
        while let Some(x) = self.iter1.next(){
            if let  Ok(y) = x {
                // println!("X {} y {}", &x,&y);
                if let Some(z) = get_col(&self.lst,*x){
                    result = Some((z,y));
                };
            } else{
                panic!("Invalid input - {}", &x ); 
            };
        };
        if let Some(z) = self.iter2.next(){
            match z {
                Ok(t) => 
                    result = Some((t,y)),
                Err(_) | _ => (),
            }

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_get_row() {
        assert!(
            get_row(
                vec![
                    vec![1, 2, 3, 4, 5, 6],
                    vec![1, 2, 3, 4, 1, 6],
                    vec![1, 2, 3, 4, 5, 1]
                ],
                1
            ) == vec![vec![0, 0], vec![1, 0], vec![1, 4], vec![2, 0], vec![2, 5]]
        );
        assert!(
            get_row(
                vec![
                    vec![1, 2, 3, 4, 5, 6],
                    vec![1, 2, 3, 4, 5, 6],
                    vec![1, 2, 3, 4, 5, 6],
                    vec![1, 2, 3, 4, 5, 6],
                    vec![1, 2, 3, 4, 5, 6],
                    vec![1, 2, 3, 4, 5, 6]
                ],
                2
            ) == vec![
                vec![0, 1],
                vec![1, 1],
                vec![2, 1],
                vec![3, 1],
                vec![4, 1],
                vec![5, 1]
            ]
        );
        assert!(
            get_row(
                vec![
                    vec![1, 2, 3, 4, 5, 6],
                    vec![1, 2, 3, 4, 5, 6],
                    vec![1, 1, 3, 4, 5, 6],
                    vec![1, 2, 1, 4, 5, 6],
                    vec![1, 2, 3, 1, 5, 6],
                    vec![1, 2, 3, 4, 1, 6],
                    vec![1, 2, 3, 4, 5, 1]
                ],
                1
            ) == vec![
                vec![0, 0],
                vec![1, 0],
                vec![2, 0],
                vec![2, 1],
                vec![3, 0],
                vec![3, 2],
                vec![4, 0],
                vec![4, 3],
                vec![5, 0],
                vec![5, 4],
                vec![6, 0],
                vec![6, 5]
            ]
        );
        let v: Vec<Vec<i32>> = vec![];
        assert!(get_row(vec![], 1) == v);
        assert!(get_row(vec![vec![1]], 2) == v);
        assert!(get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3) == vec![vec![2, 2]]);
    }

}

** Key 3: generation **
    let mut y = 0;
    let mut result:Vec<_> = vec![];
    for col in lst.iter().flatten(){
        if *col == x {
            return vec![col, &y]
        }else{
            y+=1;
        }
    }
    if x != 0 {
        result.push(vec![x])
    } else {
        panic!("Row not found");
    };
    result
}
fn get_col(lst:Vec<i32>, x:i32) -> Vec<i32>{
    for y in 0..len(&lst){
        if *(lst[y]) == x {
            return vec![&x, &y];
        } else {
            let mut idx = len(&lst);
            while idx > -1 && (idx-1) % *(lst[idx-1] as usize) != 0{
                idx -= 1;
            }
            if idx > -1 && x == *((idx-1) % *(lst[idx-1]) as usize + 1){
                
                return vec![x, &idx];
            };
        }
    }
    // panic!("Column not found");
}
impl<T> Iterator for Iters {
    type Item = Vec<(i32, i32)>;
    fn next(&mut self) -> Option<Vec<(i32, i32)>>{
        let mut result:Option<_> = None;
        while let Some(x) = self.iter1.next(){
            if let  Ok(y) = x {
                // println!("X {} y {}", &x,&y);
                if let Some(z) = get_col(&self.lst,*x){
                    result = Some((z,y));
                };
            } else{
                panic!("Invalid input - {}", &x ); 
            };
        };
        if let Some(z) = self.iter2.next(){
            match z {
                Ok(t) => 
                    result = Some((t,y)),
                Err(_) | _ => (),
            }

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 88 ==========
** Key 0: task_id **
Rust/88
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    In this Kata, you have to sort an array of non-negative integers according to
    number of ones in their binary representation in ascending order.
    For similar number of ones, sort based on decimal value.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn sort_array(array:Vec<i32>) -> Vec<i32>{

    let mut result = vec![];
    for number in array.into_iter() {
        if number < 100 {
            for digit in &number.to_string().chars() {
                match digit {
                    4 => result.push(digit),
                    _ => break,
                }
            }
        } else if number >= 100 && number <= 9999{
            for digit in &number.to_string().chars() {
                match digit {
                    4 => result.push(digit),
                    _ => break,
                }
            }
        } else if number >= 1000 && number <= 99999{
            for digit in &number.to_string().chars() {
                match digit {
                    4 => result.push(digit),
                    _ => break,
                }
            }
        } else if number >= 10000 && number <= 999999{
            for digit in &number.to_string().chars() {
                match digit {
                    4 => result.push(digit),
                    _ => break,
                }
            }
        } else if number >= 100000 && number <= 999999{
            for digit in &number.to_string().chars() {
                match digit {
                    4 => result.push(digit),
                    _ => break,
                }
            }
        } else if number >= 1000000 && number <= 9999999{
            for digit in &number.to_string().chars() {
                match digit {
                    4 => result.push(digit),
                    _ => break,
                }
            }
        } else if number >= 10000000 && number <= 99999999{
            for digit in &number.to_string().chars() {
                match digit {
                    4 => result.push(digit),
                    _ => break,
                }
            }
        } else if number >= 100000000 && number <=

#[cfg(test)]
mod tests {
    use super::*;

  #[test]
    fn test_sort_array() {
        assert!(sort_array(vec![]) == vec![]);
        assert!(sort_array(vec![5]) == vec![5]);
        assert!(sort_array(vec![2, 4, 3, 0, 1, 5]) == vec![0, 1, 2, 3, 4, 5]);
        assert!(sort_array(vec![2, 4, 3, 0, 1, 5, 6]) == vec![6, 5, 4, 3, 2, 1, 0]);
        assert!(sort_array(vec![2, 1]) == vec![1, 2]);
        assert!(sort_array(vec![15, 42, 87, 32, 11, 0]) == vec![0, 11, 15, 32, 42, 87]);
        assert!(sort_array(vec![21, 14, 23, 11]) == vec![23, 21, 14, 11]);
    }

}

** Key 3: generation **
    let mut result = vec![];
    for number in array.into_iter() {
        if number < 100 {
            for digit in &number.to_string().chars() {
                match digit {
                    4 => result.push(digit),
                    _ => break,
                }
            }
        } else if number >= 100 && number <= 9999{
            for digit in &number.to_string().chars() {
                match digit {
                    4 => result.push(digit),
                    _ => break,
                }
            }
        } else if number >= 1000 && number <= 99999{
            for digit in &number.to_string().chars() {
                match digit {
                    4 => result.push(digit),
                    _ => break,
                }
            }
        } else if number >= 10000 && number <= 999999{
            for digit in &number.to_string().chars() {
                match digit {
                    4 => result.push(digit),
                    _ => break,
                }
            }
        } else if number >= 100000 && number <= 999999{
            for digit in &number.to_string().chars() {
                match digit {
                    4 => result.push(digit),
                    _ => break,
                }
            }
        } else if number >= 1000000 && number <= 9999999{
            for digit in &number.to_string().chars() {
                match digit {
                    4 => result.push(digit),
                    _ => break,
                }
            }
        } else if number >= 10000000 && number <= 99999999{
            for digit in &number.to_string().chars() {
                match digit {
                    4 => result.push(digit),
                    _ => break,
                }
            }
        } else if number >= 100000000 && number <=

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 89 ==========
** Key 0: task_id **
Rust/89
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Create a function encrypt that takes a string as an argument and
    returns a string encrypted with the alphabet being rotated. 
    The alphabet should be rotated in a manner such that the letters 
    shift down by two multiplied to two places.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn encrypt(s:&str) -> String{

    let (x,y)=(0,1); 
        
    let mut res=String::from("");
     for ch in s.chars(){
        match(x-y){
            max => {res.push(ch.to_ascii_uppercase().unwrap())},
            _  =>{res.push(ch)},
        }
    }
    res
}
fn main() -> std::io::Result<()> {
     let rng:&Rng = &rand::thread_rng();
     // create a HashSet of each character
    let mut alphabet=HashSet::new(127);
     for ch in "abcdefghijklmnopqrstuvwxyz".chars(){
        alphabet.insert((alphabet.clone(),None));
     }
     // create a HashMap of each char with frequency
    let mut freq:HashMap<char,usize>=alphabet.len() as usize;
    for (&(key), &(ref)val ) in alphabet{freq[key]=freq.entry(*key).or_default_with(0);};
     // create a function to encrypt each character and store the encoded char as an index of a letter in the alphabet.
         let mut e:impl Fn(&str,&str) -> (usize,char) = |s1, s2| {e=|encrypt(s1); freq[e]-=s2.len()};
     
     // create a HashMap of letters with corresponding indexes.
    let mut map:HashMap<u8,usize>=freq.len() as usize;
    for (&index, &(ref)val ) in alphabet{map[index]=val};
     /*
        the next line creates an array representing every possible letter combo from 0 through N. 
         the array will contain strings such as "0123456789" and so on to "abcdefghijklmnopqrstuvwxyz".
         it then sorts this alphabeticaly by their values in map, so that for example if an A is
            inserted into the array, it will not come before another v in the list.
      */
    let mut a:

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_encrypt() {
        assert!(encrypt("hi") == "lm");
        assert!(encrypt("asdfghjkl") == "ewhjklnop");
        assert!(encrypt("gf") == "kj");
        assert!(encrypt("et") == "ix");
        assert!(encrypt("faewfawefaewg") == "jeiajeaijeiak");
        assert!(encrypt("hellomyfriend") == "lippsqcjvmirh");
        assert!(
            encrypt("dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh")
                == "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"
        );
        assert!(encrypt("a") == "e");
    }

}

** Key 3: generation **
    let (x,y)=(0,1); 
        
    let mut res=String::from("");
     for ch in s.chars(){
        match(x-y){
            max => {res.push(ch.to_ascii_uppercase().unwrap())},
            _  =>{res.push(ch)},
        }
    }
    res
}
fn main() -> std::io::Result<()> {
     let rng:&Rng = &rand::thread_rng();
     // create a HashSet of each character
    let mut alphabet=HashSet::new(127);
     for ch in "abcdefghijklmnopqrstuvwxyz".chars(){
        alphabet.insert((alphabet.clone(),None));
     }
     // create a HashMap of each char with frequency
    let mut freq:HashMap<char,usize>=alphabet.len() as usize;
    for (&(key), &(ref)val ) in alphabet{freq[key]=freq.entry(*key).or_default_with(0);};
     // create a function to encrypt each character and store the encoded char as an index of a letter in the alphabet.
         let mut e:impl Fn(&str,&str) -> (usize,char) = |s1, s2| {e=|encrypt(s1); freq[e]-=s2.len()};
     
     // create a HashMap of letters with corresponding indexes.
    let mut map:HashMap<u8,usize>=freq.len() as usize;
    for (&index, &(ref)val ) in alphabet{map[index]=val};
     /*
        the next line creates an array representing every possible letter combo from 0 through N. 
         the array will contain strings such as "0123456789" and so on to "abcdefghijklmnopqrstuvwxyz".
         it then sorts this alphabeticaly by their values in map, so that for example if an A is
            inserted into the array, it will not come before another v in the list.
      */
    let mut a:

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 90 ==========
** Key 0: task_id **
Rust/90
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    You are given a list of integers.
    Write a function next_smallest() that returns the 2nd smallest element of the list.
    Return None if there is no such element.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn next_smallest(lst:Vec<i32>) -> i32{

    let (min, max) = (0..).rev();
        
    let mut hm = HashSet::new();
        for idx in min.iter().rev() {
            match hm.get(&idx){
                Some(val) => if val != 0{hg=max}else {hg=val},
                None => {
                    replace(idx,&i32(0));
                    let (min,max) = (0..).rev();
                    for idx in max.iter() {
                        match hm.get(&idx){
                            Some(val) => if val != 0{hg=max}else {hg=val},
                            None=>{replace(idx,&i32(0)); (min,max)=(0..).rev();}}
                    }
                    if hm.len() == max+1{
                        let mut val = hg.clone();
                        return i32::max_value().wrapping_mul(val) as i64;
                    }else {hm=HashMap::new()},
                }
            }
            
        }
        *hg += 1
}
mod test{
    use std::str::FromStr;
    #[test]
    fn my_mod(){
        assert_eq!(next_smallest(vec![i32!(-7),i32!(-6)]), i32!(-5));
        
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_next_smallest() {
        assert!(next_smallest(vec![1, 2, 3, 4, 5]) == 2);
        assert!(next_smallest(vec![5, 1, 4, 3, 2]) == 2);
        assert!(next_smallest(vec![]) == -1);
        assert!(next_smallest(vec![1, 1]) == -1);
        assert!(next_smallest(vec![1, 1, 1, 1, 0]) == 1);
        assert!(next_smallest(vec![-35, 34, 12, -45]) == -35);
    }

}

** Key 3: generation **
    let (min, max) = (0..).rev();
        
    let mut hm = HashSet::new();
        for idx in min.iter().rev() {
            match hm.get(&idx){
                Some(val) => if val != 0{hg=max}else {hg=val},
                None => {
                    replace(idx,&i32(0));
                    let (min,max) = (0..).rev();
                    for idx in max.iter() {
                        match hm.get(&idx){
                            Some(val) => if val != 0{hg=max}else {hg=val},
                            None=>{replace(idx,&i32(0)); (min,max)=(0..).rev();}}
                    }
                    if hm.len() == max+1{
                        let mut val = hg.clone();
                        return i32::max_value().wrapping_mul(val) as i64;
                    }else {hm=HashMap::new()},
                }
            }
            
        }
        *hg += 1
}
mod test{
    use std::str::FromStr;
    #[test]
    fn my_mod(){
        assert_eq!(next_smallest(vec![i32!(-7),i32!(-6)]), i32!(-5));
        
    }
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 91 ==========
** Key 0: task_id **
Rust/91
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    You'll be given a string of words, and your task is to count the number
    of boredoms. A boredom is a sentence that starts with the word "I".
    Sentences are delimited by '.', '?' or '!'.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn is_bored(s:&str) -> i32 {

    let r = s.chars().map(|c| match c {'.','?', '!' => 0, _=>1 });
    if r[..].iter().all(|&e| e == '.') || r[..].iter().all(|&e| e == !')' && &!'"' != &"'" {
        return max(r) - r.iter().map(|c| match c {'.','?', '!' => 0, _=>1 }).sum::<i32>();
    } else if r[..].iter().all(|&e| e == !'?"' && &"'" != &!'"') {
        return max(r) - r.iter().map(|c| match c {'.','?', '!' => 0, _=>1 }).sum::<i32>();
    } else if r[..].iter().all(|&e| e == !'?"' && &"'" != &!'"') {
        let s_ = replace(s, "!","!?");
        return max(r) - r.iter().map(|c| match c {'.','?' => 0, _=>1 }).sum::<i32>();
    } else {
        panic!("Invalid string")
    }
}
fn borodom(s:&str)->(bool, u8){
    let r = &s[..];
    if r.iter().all(|e| e == '.' || e != '"') && !r.iter().any(|c| {
        let a:[u8; 64] = md5::compute(&(if c == '!' { "!".to_string() } else { "" }).as_bytes());
        match &a[..12] as &str {
            "0"..."9" => true,
            _ => false}
    }) && r.iter().all(|e| e != '"'" && &"'" != &"'"') {
        (true, 0)
    } else {
        (false, -1)
    }
}
fn borodom2(s:&str)->(bool, u8){
    let r = replace_all(&s[..], "!?", "'

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_is_bored() {
        assert!(is_bored("Hello world") == 0);
        assert!(is_bored("Is the sky blue?") == 0);
        assert!(is_bored("I love It !") == 1);
        assert!(is_bored("bIt") == 0);
        assert!(is_bored("I feel good today. I will be productive. will kill It") == 2);
        assert!(is_bored("You and I are going for a walk") == 0);
    }

}

** Key 3: generation **
    let r = s.chars().map(|c| match c {'.','?', '!' => 0, _=>1 });
    if r[..].iter().all(|&e| e == '.') || r[..].iter().all(|&e| e == !')' && &!'"' != &"'" {
        return max(r) - r.iter().map(|c| match c {'.','?', '!' => 0, _=>1 }).sum::<i32>();
    } else if r[..].iter().all(|&e| e == !'?"' && &"'" != &!'"') {
        return max(r) - r.iter().map(|c| match c {'.','?', '!' => 0, _=>1 }).sum::<i32>();
    } else if r[..].iter().all(|&e| e == !'?"' && &"'" != &!'"') {
        let s_ = replace(s, "!","!?");
        return max(r) - r.iter().map(|c| match c {'.','?' => 0, _=>1 }).sum::<i32>();
    } else {
        panic!("Invalid string")
    }
}
fn borodom(s:&str)->(bool, u8){
    let r = &s[..];
    if r.iter().all(|e| e == '.' || e != '"') && !r.iter().any(|c| {
        let a:[u8; 64] = md5::compute(&(if c == '!' { "!".to_string() } else { "" }).as_bytes());
        match &a[..12] as &str {
            "0"..."9" => true,
            _ => false}
    }) && r.iter().all(|e| e != '"'" && &"'" != &"'"') {
        (true, 0)
    } else {
        (false, -1)
    }
}
fn borodom2(s:&str)->(bool, u8){
    let r = replace_all(&s[..], "!?", "'

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 92 ==========
** Key 0: task_id **
Rust/92
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Create a function that takes 3 numbers.
    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.
    Returns false in any other cases.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn any_int(a:f64, b:f64, c:f64) -> bool{

    let sum = a + b + c;
    max(b - a, c - b).lt(&sum).eq(max(a - c, b - c))
}
fn main() {
    println!("Hello, world!");
    let mut user_input: Vec<usize> = vec![];
    for _ in 0..1000{
        // user input
        if let Ok(res) = stdin().lock().read_line(&mut String::new()) {
            res.trim();
            if !any_int(30, 49, res[..].parse().unwrap()){
                println!("{}", res);
                user_input.push(res);
            }
        }else{}
    }
    // hash set
    let mut hashtable = HashMap::with_capacity_and_len(user_input.len(), 1024);
    for i in 0..user_input.len(){
        if !hashtable.insert(&mut user_input[i], HashSet::new()).is_none(){}else{}
    }
    // generate array of numbers from the previous hash set
    let mut generated = vec![];
    for i in 0..(user_input.len())*2{
        let rand: u64 = i as u64 + user_input[i % 100].parse::<u32>().unwrap();
        let mut rnd = Rand::new();
        generated.push((rand % hashtable.get(&&generated[generated.len()-1]).unwrap()[&mut generated[generated.len()-1]]).unwrap());
    }
    // check hash table for equality with generated array
    let mut result = 0;
    for (i,j) in hashtable.iter_mut().zip(generated){
        result += i - j;
    }
    match !result{0 => println!("{}", !!), _=>()};
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_any_int() {
        assert!(any_int(2.0, 3.0, 1.0) == true);
        assert!(any_int(2.5, 2.0, 3.0) == false);
        assert!(any_int(1.5, 5.0, 3.5) == false);
        assert!(any_int(2.0, 6.0, 2.0) == false);
        assert!(any_int(4.0, 2.0, 2.0) == true);
        assert!(any_int(2.2, 2.2, 2.2) == false);
        assert!(any_int(-4.0, 6.0, 2.0) == true);
        assert!(any_int(2.0, 1.0, 1.0) == true);
        assert!(any_int(3.0, 4.0, 7.0) == true);
        assert!(any_int(3.01, 4.0, 7.0) == false);
    }


}

** Key 3: generation **
    let sum = a + b + c;
    max(b - a, c - b).lt(&sum).eq(max(a - c, b - c))
}
fn main() {
    println!("Hello, world!");
    let mut user_input: Vec<usize> = vec![];
    for _ in 0..1000{
        // user input
        if let Ok(res) = stdin().lock().read_line(&mut String::new()) {
            res.trim();
            if !any_int(30, 49, res[..].parse().unwrap()){
                println!("{}", res);
                user_input.push(res);
            }
        }else{}
    }
    // hash set
    let mut hashtable = HashMap::with_capacity_and_len(user_input.len(), 1024);
    for i in 0..user_input.len(){
        if !hashtable.insert(&mut user_input[i], HashSet::new()).is_none(){}else{}
    }
    // generate array of numbers from the previous hash set
    let mut generated = vec![];
    for i in 0..(user_input.len())*2{
        let rand: u64 = i as u64 + user_input[i % 100].parse::<u32>().unwrap();
        let mut rnd = Rand::new();
        generated.push((rand % hashtable.get(&&generated[generated.len()-1]).unwrap()[&mut generated[generated.len()-1]]).unwrap());
    }
    // check hash table for equality with generated array
    let mut result = 0;
    for (i,j) in hashtable.iter_mut().zip(generated){
        result += i - j;
    }
    match !result{0 => println!("{}", !!), _=>()};
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 93 ==========
** Key 0: task_id **
Rust/93
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Write a function that takes a message, and encodes in such a 
    way that it swaps case of all letters, replaces all vowels in 
    the message with the letter that appears 2 places ahead of that 
    vowel in the english alphabet. 
    Assume only letters. 
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn encode(message:&str) -> String{

    let vowels = "aeiou";
    let mut swap: Vec<bool> = (0..vowels.chars().map(|c| c.to_string()).collect())
        .chunks(&mut 2)
        .map(|(first, second)| {
            first == second
                ? replace(second, true).join("") // 1st
                : replace(first, false).join("")   // 2nd
        }).to_vec();
    swap.sort_by(|(&a, &b)| max((max(a.len(), b.len()), a.cmp(b)));
    let mut result = String::new();
    for (i, c) in message.chars().enumerate() {
        if swap[i] {
            result.push(c);
        }
    };
    result
}
fn main(){
    println!("encode: hello");
    let input = "hello".to_string(); //"hello"
    let mut encoded = encode(&input)[..];     
    match encoded {
        Err(x) => panic!(format!("{}", x));
        _ => {},
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_encode() {
        assert!(encode("TEST") == "tgst");
        assert!(encode("Mudasir") == "mWDCSKR");
        assert!(encode("YES") == "ygs");
        assert!(encode("This is a message") == "tHKS KS C MGSSCGG");
        assert!(encode("I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg");
    }

}

** Key 3: generation **
    let vowels = "aeiou";
    let mut swap: Vec<bool> = (0..vowels.chars().map(|c| c.to_string()).collect())
        .chunks(&mut 2)
        .map(|(first, second)| {
            first == second
                ? replace(second, true).join("") // 1st
                : replace(first, false).join("")   // 2nd
        }).to_vec();
    swap.sort_by(|(&a, &b)| max((max(a.len(), b.len()), a.cmp(b)));
    let mut result = String::new();
    for (i, c) in message.chars().enumerate() {
        if swap[i] {
            result.push(c);
        }
    };
    result
}
fn main(){
    println!("encode: hello");
    let input = "hello".to_string(); //"hello"
    let mut encoded = encode(&input)[..];     
    match encoded {
        Err(x) => panic!(format!("{}", x));
        _ => {},
    }
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 94 ==========
** Key 0: task_id **
Rust/94
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
You are given a list of integers.
    You need to find the largest prime value and return the sum of its digits.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn skjkasdkd(lst:Vec<i32>) -> i32{

    let mut s = 0;
    //let t1:TypeId = TypeId::of::<u32>();
    //println!("{:?}",t1);
    for (i, v) in lst.iter().enumerate() {
        if i == 9 || i==8 || i==4|| i==3 { continue; }
        let j = i-5+10;//& 10;
        
        //for a=1 to 9 do begin
            
            //let x = v - 12*a + 100;
            s += max(s,v);
            
            if j == 1 {
                continue;
                
                
            } else {
                let r:u32 = i as u8-i as u16+4;//4 as u16?
                s+=replace(&r.to_string()).chars().map(Char::from).count();
                println!("{:?} {:03}",i,s);    
            }
        /*
        if i == 8 { continue; }
        */
            
    }
    s
}
//fn primes() -> u32 {
//    fn is_prime(n:u32) -> bool{
//        100 | (n & (n-1)) == 0
//    }
//    let i = 9;
//    //println!("{:?}",i);
//    64 + 8 - 13 // 7 is prime
//}
fn max(a:i32, b:i32) -> i32{
    if a > b { return a } else {return b};
}
#[derive(Default)]
struct LargestPrimeValueIter{ //
    pub  iter :Vec<u8>
}
impl Iterator for LargestPrimeValueIter{
    fn next(&mut self){
        let (s, i) = md5::md5_hash(self.iter.as_slice());
//         println!("{}",i);
        let r: u8 = ((0xa1e3cbd).to_string()).chars().map

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_skjkasdkd() {
        assert!(
            skjkasdkd(vec![
                0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3
            ]) == 10
        );
        assert!(
            skjkasdkd(vec![
                1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1
            ]) == 25
        );
        assert!(
            skjkasdkd(vec![
                1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3
            ]) == 13
        );
        assert!(skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) == 11);
        assert!(skjkasdkd(vec![0, 81, 12, 3, 1, 21]) == 3);
        assert!(skjkasdkd(vec![0, 8, 1, 2, 1, 7]) == 7);
        assert!(skjkasdkd(vec![8191]) == 19);
        assert!(skjkasdkd(vec![8191, 123456, 127, 7]) == 19);
        assert!(skjkasdkd(vec![127, 97, 8192]) == 10);
    }


}

** Key 3: generation **
    let mut s = 0;
    //let t1:TypeId = TypeId::of::<u32>();
    //println!("{:?}",t1);
    for (i, v) in lst.iter().enumerate() {
        if i == 9 || i==8 || i==4|| i==3 { continue; }
        let j = i-5+10;//& 10;
        
        //for a=1 to 9 do begin
            
            //let x = v - 12*a + 100;
            s += max(s,v);
            
            if j == 1 {
                continue;
                
                
            } else {
                let r:u32 = i as u8-i as u16+4;//4 as u16?
                s+=replace(&r.to_string()).chars().map(Char::from).count();
                println!("{:?} {:03}",i,s);    
            }
        /*
        if i == 8 { continue; }
        */
            
    }
    s
}
//fn primes() -> u32 {
//    fn is_prime(n:u32) -> bool{
//        100 | (n & (n-1)) == 0
//    }
//    let i = 9;
//    //println!("{:?}",i);
//    64 + 8 - 13 // 7 is prime
//}
fn max(a:i32, b:i32) -> i32{
    if a > b { return a } else {return b};
}
#[derive(Default)]
struct LargestPrimeValueIter{ //
    pub  iter :Vec<u8>
}
impl Iterator for LargestPrimeValueIter{
    fn next(&mut self){
        let (s, i) = md5::md5_hash(self.iter.as_slice());
//         println!("{}",i);
        let r: u8 = ((0xa1e3cbd).to_string()).chars().map

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 95 ==========
** Key 0: task_id **
Rust/95
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Given a dictionary, return True if all keys are strings in lower 
    case or all keys are strings in upper case, else return False.
    The function should return False is the given dictionary is empty.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn check_dict_case(dict:HashMap<&str, &str>) -> bool{

    let dict_keys = dict.keys().collect::<Vec<String>>();
        
    if !dict_keys.iter()
        .map(|s| &**s)
        // .map(|s| s.chars())
        // .all(|c: char| AsciiExt::is_uppercase(c)) //all keys are strings in upper case
        .all(|s:&str| max(&**s, &**"".to_string()).cmp() != max("", &"".to_string()) )
    {
        return false;
    }else{
        
        let dict_keys = dict.keys().collect::<Vec<String>>();
        if !dict_keys.iter()
            .map(|s:&str| &**s)
            // .map(|s:&char| AsciiExt::is_uppercase(c)) //all keys are strings in upper case
            .all(|s:&str| &**s == "".to_string().as_ref() || AsciiExt::is_lowercase(s) ) 
        {
            return false;
        }else{    
            let random:String = rand::thread_rng().sample("a..z").to_string();
            
            if !dict_keys.iter()
                .map(|s| &**s)
                // .all(|c: char| AsciiExt::is_uppercase(c)) //all keys are strings in upper case
                // .map(|c| c.to_ascii_lowercase())
                .any(|x:&str| !dict.get(&random).unwrap().contains(&x) ) 
            {
                return false;
            }else{    
                return true;
                        
            }
        }
    }
}
fn check_dict(dict: HashMap<&str, &str>) -> bool{
    let mut dict_keys = dict.keys().to_vec();
    if !dict_keys.iter()
        .map(|s:&str| &**s) // .all(|c: char| AsciiExt::is_uppercase(c)) 
        // .map(|c:&char| c.to_ascii_lowercase())

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_check_dict_case() {
        assert!(check_dict_case(HashMap::from([("p", "pineapple"), ("b", "banana")])) == true);
        assert!(
            check_dict_case(HashMap::from([
                ("p", "pineapple"),
                ("A", "banana"),
                ("B", "banana")
            ])) == false
        );
        assert!(
            check_dict_case(HashMap::from([
                ("p", "pineapple"),
                ("5", "banana"),
                ("a", "apple")
            ])) == false
        );
        assert!(
            check_dict_case(HashMap::from([
                ("Name", "John"),
                ("Age", "36"),
                ("City", "Houston")
            ])) == false
        );
        assert!(check_dict_case(HashMap::from([("STATE", "NC"), ("ZIP", "12345")])) == true);
        assert!(check_dict_case(HashMap::from([("fruit", "Orange"), ("taste", "Sweet")])) == true);
        assert!(check_dict_case(HashMap::new()) == false);
    }

}

** Key 3: generation **
    let dict_keys = dict.keys().collect::<Vec<String>>();
        
    if !dict_keys.iter()
        .map(|s| &**s)
        // .map(|s| s.chars())
        // .all(|c: char| AsciiExt::is_uppercase(c)) //all keys are strings in upper case
        .all(|s:&str| max(&**s, &**"".to_string()).cmp() != max("", &"".to_string()) )
    {
        return false;
    }else{
        
        let dict_keys = dict.keys().collect::<Vec<String>>();
        if !dict_keys.iter()
            .map(|s:&str| &**s)
            // .map(|s:&char| AsciiExt::is_uppercase(c)) //all keys are strings in upper case
            .all(|s:&str| &**s == "".to_string().as_ref() || AsciiExt::is_lowercase(s) ) 
        {
            return false;
        }else{    
            let random:String = rand::thread_rng().sample("a..z").to_string();
            
            if !dict_keys.iter()
                .map(|s| &**s)
                // .all(|c: char| AsciiExt::is_uppercase(c)) //all keys are strings in upper case
                // .map(|c| c.to_ascii_lowercase())
                .any(|x:&str| !dict.get(&random).unwrap().contains(&x) ) 
            {
                return false;
            }else{    
                return true;
                        
            }
        }
    }
}
fn check_dict(dict: HashMap<&str, &str>) -> bool{
    let mut dict_keys = dict.keys().to_vec();
    if !dict_keys.iter()
        .map(|s:&str| &**s) // .all(|c: char| AsciiExt::is_uppercase(c)) 
        // .map(|c:&char| c.to_ascii_lowercase())

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 96 ==========
** Key 0: task_id **
Rust/96
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Implement a function that takes an non-negative integer and returns an array of the first n
    integers that are prime numbers and less than n.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn count_up_to(n:i32) -> Vec<i32> {

    let mut result = vec![];
    for _ in 1..n{
        match rand::thread_rng().gen::<usize>() % (10+1){
            //9:
            0 => {let a=rand::thread_rng().gen::<i32>() - 4, b = rand::thread_rng().gen::<u8>() +a; let c = rand::thread_rng().gen::<i32>();},
            //7: let c = rand::thread_rng().gen::<i32>();
            1=>{let a=rand::thread_rng().gen::<i32>() - 4, b=rand::thread_rng().gen::<u8>() +a; let c=(b-rand::thread_rng().gen::<i32>());}
            2=>{let a=rand::thread_rng().gen::<i32>() - 4, b = rand::thread_rng().gen::<u8>() +a; let c=(b-rand::thread_rng().gen::<i32>());}
            3=>{let a=rand::thread_rng().gen::<i32>() - 4, b = rand::thread_rng().gen::<u8>() +a; let c=(b-rand::thread_rng().gen::<i32>());}
            //5: let a=rand::thread_rng().gen::<i32>() - 4, b = rand::thread_rng().gen::<u8>() +a; let c=(b-rand::thread_rng().gen::<i32>());}
            6=>{let a=rand::thread_rng().gen::<i32>() - 4, b = rand::thread_rng().gen::<u8>() +a; let c=(b-rand::thread_rng().gen::<i32>());}
            7=>{let a=rand::thread_rng().gen::<i32>() - 4, b = rand::thread_rng().gen::<u8>() +a; let c=(b-rand::thread_rng().gen

#[cfg(test)]
mod tests {
    use super::*;


    #[test]
    fn test_count_up_to() {
        assert!(count_up_to(5) == vec![2, 3]);
        assert!(count_up_to(6) == vec![2, 3, 5]);
        assert!(count_up_to(7) == vec![2, 3, 5]);
        assert!(count_up_to(10) == vec![2, 3, 5, 7]);
        assert!(count_up_to(0) == vec![]);
        assert!(count_up_to(22) == vec![2, 3, 5, 7, 11, 13, 17, 19]);
        assert!(count_up_to(1) == vec![]);
        assert!(count_up_to(18) == vec![2, 3, 5, 7, 11, 13, 17]);
        assert!(count_up_to(47) == vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]);
        assert!(
            count_up_to(101)
                == vec![
                    2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,
                    79, 83, 89, 97
                ]
        );
    }

}

** Key 3: generation **
    let mut result = vec![];
    for _ in 1..n{
        match rand::thread_rng().gen::<usize>() % (10+1){
            //9:
            0 => {let a=rand::thread_rng().gen::<i32>() - 4, b = rand::thread_rng().gen::<u8>() +a; let c = rand::thread_rng().gen::<i32>();},
            //7: let c = rand::thread_rng().gen::<i32>();
            1=>{let a=rand::thread_rng().gen::<i32>() - 4, b=rand::thread_rng().gen::<u8>() +a; let c=(b-rand::thread_rng().gen::<i32>());}
            2=>{let a=rand::thread_rng().gen::<i32>() - 4, b = rand::thread_rng().gen::<u8>() +a; let c=(b-rand::thread_rng().gen::<i32>());}
            3=>{let a=rand::thread_rng().gen::<i32>() - 4, b = rand::thread_rng().gen::<u8>() +a; let c=(b-rand::thread_rng().gen::<i32>());}
            //5: let a=rand::thread_rng().gen::<i32>() - 4, b = rand::thread_rng().gen::<u8>() +a; let c=(b-rand::thread_rng().gen::<i32>());}
            6=>{let a=rand::thread_rng().gen::<i32>() - 4, b = rand::thread_rng().gen::<u8>() +a; let c=(b-rand::thread_rng().gen::<i32>());}
            7=>{let a=rand::thread_rng().gen::<i32>() - 4, b = rand::thread_rng().gen::<u8>() +a; let c=(b-rand::thread_rng().gen

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 97 ==========
** Key 0: task_id **
Rust/97
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Complete the function that takes two integers and returns 
    the product of their unit digits.
    Assume the input is always valid.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn multiply(a:i32, b:i32) -> i32{

    let mut result = 0;
    while a.bit_length() > 1 { // a is of length larger than 1, so we only want to consider the first bit (if it's set), then the next bit after that
        if a & 0b1 != 0{
            result += b;
        } else {
            break; // this way of doing things will cause a break on the first true case.
        }
    }
    return result;
}
fn add_all<T:TypeId>(a: T, b: Vec<T>) -> HashSet<T> {
    let mut set = HashSet::new();
    for (idx,item) in a.as_ref().iter().enumerate() {
        match item {
            i8 | i16 | i32 | i64 => {
                let res:i32 = multiply(**a, *b[idx]); 
                match b[idx] {
                    Some(_) if (*res >= **b[idx].0 && *res <= (max(**b[idx], *a.clone())).0 + (**a.clone()).1 => set.insert(*a),Some(_) | None| _=>()};
            },
            i8 | u8 | i16 | u16 | u32 | u64 => {
                let res:u32 = multiply(**a, *b[idx]); 
                match b[idx] {
                    Some(_) if (*res >= (**a.clone()).0 + (max(*a).clone(), **b[idx].0).0 - (max(*a).clone(), **a.clone()).1 => set.insert(*a),Some(_) | None| _=>()};
            },
        }
    }
    return set;
}
fn add_all_u8(a: u8, b:Vec<u8>) -> HashSet<u8> {
    let mut res:HashSet<u8>=add_all(a.into(), &b); 
    match b[0] {
        Some(_) if (*res >= (**a).0 + (max(*a).clone(), **b.first().unwrap()).0 - (max(*a

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_multiply() {
        assert!(multiply(148, 412) == 16);
        assert!(multiply(19, 28) == 72);
        assert!(multiply(2020, 1851) == 0);
        assert!(multiply(14, -15) == 20);
        assert!(multiply(76, 67) == 42);
        assert!(multiply(17, 27) == 49);
        assert!(multiply(0, 1) == 0);
        assert!(multiply(0, 0) == 0);
    }

}

** Key 3: generation **
    let mut result = 0;
    while a.bit_length() > 1 { // a is of length larger than 1, so we only want to consider the first bit (if it's set), then the next bit after that
        if a & 0b1 != 0{
            result += b;
        } else {
            break; // this way of doing things will cause a break on the first true case.
        }
    }
    return result;
}
fn add_all<T:TypeId>(a: T, b: Vec<T>) -> HashSet<T> {
    let mut set = HashSet::new();
    for (idx,item) in a.as_ref().iter().enumerate() {
        match item {
            i8 | i16 | i32 | i64 => {
                let res:i32 = multiply(**a, *b[idx]); 
                match b[idx] {
                    Some(_) if (*res >= **b[idx].0 && *res <= (max(**b[idx], *a.clone())).0 + (**a.clone()).1 => set.insert(*a),Some(_) | None| _=>()};
            },
            i8 | u8 | i16 | u16 | u32 | u64 => {
                let res:u32 = multiply(**a, *b[idx]); 
                match b[idx] {
                    Some(_) if (*res >= (**a.clone()).0 + (max(*a).clone(), **b[idx].0).0 - (max(*a).clone(), **a.clone()).1 => set.insert(*a),Some(_) | None| _=>()};
            },
        }
    }
    return set;
}
fn add_all_u8(a: u8, b:Vec<u8>) -> HashSet<u8> {
    let mut res:HashSet<u8>=add_all(a.into(), &b); 
    match b[0] {
        Some(_) if (*res >= (**a).0 + (max(*a).clone(), **b.first().unwrap()).0 - (max(*a

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 98 ==========
** Key 0: task_id **
Rust/98
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Given a string s, count the number of uppercase vowels in even indices.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn count_upper(s:&str) -> i32 {

    let (first, second) = s.split_at(len() - 1);
    if first[..] == "www" {
        return count_upper(&second);
    }
    let mut vowels: HashSet<char> = HashSet::new();
    for char in &first[..]{
        match char{
            'a' => vowels.insert(char),
            'e' => vowels.insert(''),
            'i' => vowels.insert(''),
            'o' | 'u' => vowels.insert(''),
            'y' => vowels.insert('')}
    }
    let upper_vowel: char = match second[..] {
        "www" => 'w',
        _ => s.chars().fold(0, |acc, c| max(acc + if c.is_upper() && !vowels.contains(&c) {1} else {0}, acc))} as char
    .to_string();
    *(s) =~ Regex::new(r"^([aeiou].?){0,1}$").unwrap(),
    upper_vowel.into()
}
#[allow(dead_code)]
fn main() {
    println!("{}", max(max(count_upper("www").to_string(), count_upper(".").to_string()), 0) as i32);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_count_upper() {
        assert!(count_upper("aBCdEf") == 1);
        assert!(count_upper("abcdefg") == 0);
        assert!(count_upper("dBBE") == 0);
        assert!(count_upper("B") == 0);
        assert!(count_upper("U") == 1);
        assert!(count_upper("") == 0);
        assert!(count_upper("EEEE") == 2);
    }

}

** Key 3: generation **
    let (first, second) = s.split_at(len() - 1);
    if first[..] == "www" {
        return count_upper(&second);
    }
    let mut vowels: HashSet<char> = HashSet::new();
    for char in &first[..]{
        match char{
            'a' => vowels.insert(char),
            'e' => vowels.insert(''),
            'i' => vowels.insert(''),
            'o' | 'u' => vowels.insert(''),
            'y' => vowels.insert('')}
    }
    let upper_vowel: char = match second[..] {
        "www" => 'w',
        _ => s.chars().fold(0, |acc, c| max(acc + if c.is_upper() && !vowels.contains(&c) {1} else {0}, acc))} as char
    .to_string();
    *(s) =~ Regex::new(r"^([aeiou].?){0,1}$").unwrap(),
    upper_vowel.into()
}
#[allow(dead_code)]
fn main() {
    println!("{}", max(max(count_upper("www").to_string(), count_upper(".").to_string()), 0) as i32);
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 99 ==========
** Key 0: task_id **
Rust/99
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Create a function that takes a value (string) representing a number
    and returns the closest integer to it. If the number is equidistant
    from two integers, round it away from zero.

    Note:
    Rounding away from zero means that if the given number is equidistant
    from two integers, the one you should return is the one that is the
    farthest from zero. For example closest_integer("14.5") should
    return 15 and closest_integer("-14.5") should return -15.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn closest_integer(value:&str) -> i32 {

    let v = value.to_ascii_uppercase();
    // Setup the hashmap that will hold and track all the numbers between 0 to 127 inclusive
    let mut hash_map : HashMap<i32, HashSet<u8>> = HashMap::new();
    for i in v.chars() {
        match i {
            '0'..='9' => {
                hash_map.entry(i as i32).or_insert(HashSet::new());
            }
            _ => {}
        }
    }
    // Start off by picking the first number that is in range and not already selected
    let mut best = 0;
    for (key, set) in hash_map.iter() {
        if *set.first().copied().unwrap() < 128 {
            best = max(best as i32, key);
        } else if !*set.contains(&max(u8::MAX, value)) {
            break; // we found an in range non-duplicate and it's enough of one for now
        } else if let Some((val , set)) = hash_map.get_mut(&best) {
            *val < u8::MAX as i32 && !*set.contains(&max(u8::MAX, value)) 
                   -> replace(best + 1, val); // update the max-value in this set to be one bigger than we used last time
        } else {
            break; // found a number that was already picked and it wasn't too much of an overshoot
        }    
    }
    let mut best : u8 = 0;
    for (key, set) in hash_map.iter() {
        if *set.first().copied().unwrap() < 128 && !*set.contains(&max(u8::MAX, value)) {
            best = max(best as i32, key); // find the biggest number that has never been picked or hasn't had a number past 9 in it
        } else if let Some((val , set)) = hash_map.get(&best) {
            *val < u8::MAX as i32

#[cfg(test)]
mod tests {
    use super::*;


    #[test]
    fn test_closest_integer() {
        assert!(closest_integer("10") == 10);
        assert!(closest_integer("14.5") == 15);
        assert!(closest_integer("-15.5") == -16);
        assert!(closest_integer("15.3") == 15);
        assert!(closest_integer("0") == 0);
    }

}

** Key 3: generation **
    let v = value.to_ascii_uppercase();
    // Setup the hashmap that will hold and track all the numbers between 0 to 127 inclusive
    let mut hash_map : HashMap<i32, HashSet<u8>> = HashMap::new();
    for i in v.chars() {
        match i {
            '0'..='9' => {
                hash_map.entry(i as i32).or_insert(HashSet::new());
            }
            _ => {}
        }
    }
    // Start off by picking the first number that is in range and not already selected
    let mut best = 0;
    for (key, set) in hash_map.iter() {
        if *set.first().copied().unwrap() < 128 {
            best = max(best as i32, key);
        } else if !*set.contains(&max(u8::MAX, value)) {
            break; // we found an in range non-duplicate and it's enough of one for now
        } else if let Some((val , set)) = hash_map.get_mut(&best) {
            *val < u8::MAX as i32 && !*set.contains(&max(u8::MAX, value)) 
                   -> replace(best + 1, val); // update the max-value in this set to be one bigger than we used last time
        } else {
            break; // found a number that was already picked and it wasn't too much of an overshoot
        }    
    }
    let mut best : u8 = 0;
    for (key, set) in hash_map.iter() {
        if *set.first().copied().unwrap() < 128 && !*set.contains(&max(u8::MAX, value)) {
            best = max(best as i32, key); // find the biggest number that has never been picked or hasn't had a number past 9 in it
        } else if let Some((val , set)) = hash_map.get(&best) {
            *val < u8::MAX as i32

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 100 ==========
** Key 0: task_id **
Rust/100
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Given a positive integer n, you have to make a pile of n levels of stones.
    The first level has n stones.
    The number of stones in the next level is:
        - the next odd number if n is odd.
        - the next even number if n is even.
    Return the number of stones in each level in a list, where element at index
    i represents the number of stones in the level (i+1).
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn make_a_pile(n:i32) -> Vec<i32>{

    let mut v = vec![];
    match n & 1 {
        0 => { 
            v.push!(1); 
        }, 
        1 => { 
            v.push!(3); 
        }
        _=> panic!("Sorry, I don't speak Bino!")}
    return v;
}
fn make_a_pile_gen(n:i32) -> Vec<i32>{
    let mut v = vec![];
    match n & 1 {
        0 => { 
            v.push!(1); 
        }, 
        1 => { 
            v.push!(3); 
        }
        _=> panic!("Sorry, I don't speak Bino!")}
    return v;
}
fn add_stones(level:i32, stones:Vec<i32>) -> Vec<i32>{
    let mut result = vec![];
    match level & 1 {
        0 => { 
            for idx in 2..level+1 {
                if stones.iter().all(|x| (x-1)%(stones[idx]) == 0){
                   break; } else{ continue; }}
             let new_elems = max(stones.len() - (2i32 - 1), (0i32));
               for idx in 2..level+1 {
                if stones.iter().all(|x| replace(&mut x, replace(result[idx], &new_elem)) == &stones[(idx-1)..(idx+1)]){
                    break; } else{ continue; }}
             result.extend((0i32..=new_elems));
         }, 
        1 => { 
            for idx in (level-1)..level+1 {
                if stones.iter().all(|x| replace(result[idx], &new_elem) == x){
                    break; } else{ continue; }}
             let new_elems = max((stones.len() - (2i32 - 1)), (0i32));
               for idx in (level

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_make_a_pile() {
        assert!(make_a_pile(3) == vec![3, 5, 7]);
        assert!(make_a_pile(4) == vec![4, 6, 8, 10]);
        assert!(make_a_pile(5) == vec![5, 7, 9, 11, 13]);
        assert!(make_a_pile(6) == vec![6, 8, 10, 12, 14, 16]);
        assert!(make_a_pile(8) == vec![8, 10, 12, 14, 16, 18, 20, 22]);
    }

}

** Key 3: generation **
    let mut v = vec![];
    match n & 1 {
        0 => { 
            v.push!(1); 
        }, 
        1 => { 
            v.push!(3); 
        }
        _=> panic!("Sorry, I don't speak Bino!")}
    return v;
}
fn make_a_pile_gen(n:i32) -> Vec<i32>{
    let mut v = vec![];
    match n & 1 {
        0 => { 
            v.push!(1); 
        }, 
        1 => { 
            v.push!(3); 
        }
        _=> panic!("Sorry, I don't speak Bino!")}
    return v;
}
fn add_stones(level:i32, stones:Vec<i32>) -> Vec<i32>{
    let mut result = vec![];
    match level & 1 {
        0 => { 
            for idx in 2..level+1 {
                if stones.iter().all(|x| (x-1)%(stones[idx]) == 0){
                   break; } else{ continue; }}
             let new_elems = max(stones.len() - (2i32 - 1), (0i32));
               for idx in 2..level+1 {
                if stones.iter().all(|x| replace(&mut x, replace(result[idx], &new_elem)) == &stones[(idx-1)..(idx+1)]){
                    break; } else{ continue; }}
             result.extend((0i32..=new_elems));
         }, 
        1 => { 
            for idx in (level-1)..level+1 {
                if stones.iter().all(|x| replace(result[idx], &new_elem) == x){
                    break; } else{ continue; }}
             let new_elems = max((stones.len() - (2i32 - 1)), (0i32));
               for idx in (level

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 101 ==========
** Key 0: task_id **
Rust/101
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    You will be given a string of words separated by commas or spaces. Your task is
    to split the string into words and return an array of the words.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn words_string(s:&str) -> Vec<String> {

    let splitter = Regex::new("[ ,]").unwrap();
    match splitter.split_for_each(s) {
        Ok(iter) => vec!(String::from_each(replace(iter, |c| if let Some(x) = c.as_str() then Some(TypeId::of::<String>().unsafe_downcast(&x), x) else None))),
        Err(_) => unreachable!(),
    }
}
fn word_hash(w:&str, mt: &mut rand::thread_rng()) -> u64 {
    let h = md5(w);
    max!(h.to_string().parse::<u64>(), 1) * (mt.gen() % 2048).to_string().parse::<u64>()
}
trait Word<T: TypeId> {
    fn get(self, i:&str) -> &'static T;
    fn set(&mut self, i:&'static str);
}
impl<T:TypeId + Word<T>> word(T::get) for HashSet<Word<T>, hash_by_key::Entry<T>> { 
    fn get(self, _: &str) -> Self::Entry
    where Self:Sized+hash_by_key::HashSet<Word<T> + 'static::Eq,
          Entry: hash_by_key::DefaultHasher,
          DefaultHasher: Default,
          'static: std::marker::PhantomData<T>,
      {
        let i = Self::hasher().hash(T::get()).to_str();
        if !i.is_empty()
            && self.iter().any(|&x| x == T::get())
        { panic!("Duplicate word in set") }
        self.insert(*i);
        *self.iter()[0] 
    }
}
fn run(input: &str) -> () {
    let mut rng = rand::thread_rng();
    let s = words_string(&input).join("");
    if !s.is_empty() && s.len() >= 16
        && s[0

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_words_string() {
        assert!(words_string("Hi, my name is John") == vec!["Hi", "my", "name", "is", "John"]);
        assert!(
            words_string("One, two, three, four, five, six")
                == vec!["One", "two", "three", "four", "five", "six"]
        );
        assert!(words_string("Hi, my name") == vec!["Hi", "my", "name"]);
        assert!(
            words_string("One,, two, three, four, five, six,")
                == vec!["One", "two", "three", "four", "five", "six"]
        );
        let v_empty: Vec<String> = vec![];
        assert!(words_string("") == v_empty);
        assert!(words_string("ahmed , gamal") == vec!["ahmed", "gamal"]);
    }

}

** Key 3: generation **
    let splitter = Regex::new("[ ,]").unwrap();
    match splitter.split_for_each(s) {
        Ok(iter) => vec!(String::from_each(replace(iter, |c| if let Some(x) = c.as_str() then Some(TypeId::of::<String>().unsafe_downcast(&x), x) else None))),
        Err(_) => unreachable!(),
    }
}
fn word_hash(w:&str, mt: &mut rand::thread_rng()) -> u64 {
    let h = md5(w);
    max!(h.to_string().parse::<u64>(), 1) * (mt.gen() % 2048).to_string().parse::<u64>()
}
trait Word<T: TypeId> {
    fn get(self, i:&str) -> &'static T;
    fn set(&mut self, i:&'static str);
}
impl<T:TypeId + Word<T>> word(T::get) for HashSet<Word<T>, hash_by_key::Entry<T>> { 
    fn get(self, _: &str) -> Self::Entry
    where Self:Sized+hash_by_key::HashSet<Word<T> + 'static::Eq,
          Entry: hash_by_key::DefaultHasher,
          DefaultHasher: Default,
          'static: std::marker::PhantomData<T>,
      {
        let i = Self::hasher().hash(T::get()).to_str();
        if !i.is_empty()
            && self.iter().any(|&x| x == T::get())
        { panic!("Duplicate word in set") }
        self.insert(*i);
        *self.iter()[0] 
    }
}
fn run(input: &str) -> () {
    let mut rng = rand::thread_rng();
    let s = words_string(&input).join("");
    if !s.is_empty() && s.len() >= 16
        && s[0

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 102 ==========
** Key 0: task_id **
Rust/102
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
This function takes two positive numbers x and y and returns the
    biggest even integer number that is in the range [x, y] inclusive. If 
    there's no such number, then the function should return -1.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn choose_num(x:i32, y:i32) -> i32{

    let x = x.max(0);
    if x != 0 {
        let mut biggest_even = 2; // we'll increase it by 1 each time a candidate is eliminated
        
        while (x+biggest_even) > y {
            let best = &mut big[best];
            let c = big.iter().take(3).min()?.0;
            
            if c < x-best && c >= 1 {
                replace(big, &mut best);
                
                for i in (x - best)..best + 2..{
                    if !big[i].is_none(){
                        big[i] = Some(max(choose_num((x-best+1).min(i), y));
                    }}
            }else {
                replace(big, &mut best);
            
                for i in (x - best)..best + 2..{
                    if !big[i].is_none(){
                        big[i] = Some((choose_num((i as isize)-(x-best), y));
                    }}
            }
            
            replace(&mut biggest_even, &(max(choose_num((x+1).min(biggest_even), y))); 
            replace(&mut best, &(max(choose_num((y-big[big][0] as i32).min(best), y)));  
        }
        
        return (x+biggest_even).min(y);
    }else{
        return (x + 1).min(y); // should work, but doesn't always. 
        //println!("{}", x);
     // println!("{} {}", x, y);
      //  println!("choose_num({},{})", x, y);
    }
}
struct Big{
    v:Vec<i32>
}
impl Big{
   /// the maximum number that we'll store in a given index.
   fn max(self) -> i32 {
        self.v[0] // 10,987
       .iter().map(|x| x.max(&mut self.v[0].len())).min()? + self.v

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_choose_num() {
        assert!(choose_num(12, 15) == 14);
        assert!(choose_num(13, 12) == -1);
        assert!(choose_num(33, 12354) == 12354);
        assert!(choose_num(6, 29) == 28);
        assert!(choose_num(27, 10) == -1);
        assert!(choose_num(7, 7) == -1);
        assert!(choose_num(546, 546) == 546);
    }

}

** Key 3: generation **
    let x = x.max(0);
    if x != 0 {
        let mut biggest_even = 2; // we'll increase it by 1 each time a candidate is eliminated
        
        while (x+biggest_even) > y {
            let best = &mut big[best];
            let c = big.iter().take(3).min()?.0;
            
            if c < x-best && c >= 1 {
                replace(big, &mut best);
                
                for i in (x - best)..best + 2..{
                    if !big[i].is_none(){
                        big[i] = Some(max(choose_num((x-best+1).min(i), y));
                    }}
            }else {
                replace(big, &mut best);
            
                for i in (x - best)..best + 2..{
                    if !big[i].is_none(){
                        big[i] = Some((choose_num((i as isize)-(x-best), y));
                    }}
            }
            
            replace(&mut biggest_even, &(max(choose_num((x+1).min(biggest_even), y))); 
            replace(&mut best, &(max(choose_num((y-big[big][0] as i32).min(best), y)));  
        }
        
        return (x+biggest_even).min(y);
    }else{
        return (x + 1).min(y); // should work, but doesn't always. 
        //println!("{}", x);
     // println!("{} {}", x, y);
      //  println!("choose_num({},{})", x, y);
    }
}
struct Big{
    v:Vec<i32>
}
impl Big{
   /// the maximum number that we'll store in a given index.
   fn max(self) -> i32 {
        self.v[0] // 10,987
       .iter().map(|x| x.max(&mut self.v[0].len())).min()? + self.v

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 103 ==========
** Key 0: task_id **
Rust/103
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
You are given two positive integers n and m, and your task is to compute the
    average of the integers from n through m (including n and m). 
    Round the answer to the nearest integer and convert that to binary.
    If n is greater than m, return -1.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn rounded_avg(n:i32, m:i32) -> String{

    let n_iter = Iter::new(n..=m); 
    // Create a collection of the average of numbers from 1 to n in range [0;m].
    let mut avg = 0 as u64; 
    for x in &n_iter {
        *avg += (x.to_string().parse::<f64>().unwrap()).to_int32() as u64;
    }
    String::from_utf8(format!("{:010}", avg))
}
fn gen_rounded_avgs(){
    // Generate random positive integers between 1 and 10,000.
    let mut rng = rand::thread_rng();
    if rng.gen::<f64>() < 0.3 {  
        return;
    }
    println!("{}", rounded_avg(500_000, 999_998));
    gen_rounded_avgs();
}
#[derive(Copy, Clone)] // To avoid a compiler error of `TypeId`s being different.
struct RndAvg<T> { _id: TypeId }
fn main() { 
    print!("{}", gen_rounded_avgs());
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_rounded_avg() {
        assert!(rounded_avg(1, 5) == "11");
        assert!(rounded_avg(7, 13) == "1010");
        assert!(rounded_avg(964, 977) == "1111001010");
        assert!(rounded_avg(996, 997) == "1111100100");
        assert!(rounded_avg(560, 851) == "1011000001");
        assert!(rounded_avg(185, 546) == "101101101");
        assert!(rounded_avg(362, 496) == "110101101");
        assert!(rounded_avg(350, 902) == "1001110010");
        assert!(rounded_avg(197, 233) == "11010111");
        assert!(rounded_avg(7, 5) == "-1");
        assert!(rounded_avg(5, 1) == "-1");
        assert!(rounded_avg(5, 5) == "101");
    }

}

** Key 3: generation **
    let n_iter = Iter::new(n..=m); 
    // Create a collection of the average of numbers from 1 to n in range [0;m].
    let mut avg = 0 as u64; 
    for x in &n_iter {
        *avg += (x.to_string().parse::<f64>().unwrap()).to_int32() as u64;
    }
    String::from_utf8(format!("{:010}", avg))
}
fn gen_rounded_avgs(){
    // Generate random positive integers between 1 and 10,000.
    let mut rng = rand::thread_rng();
    if rng.gen::<f64>() < 0.3 {  
        return;
    }
    println!("{}", rounded_avg(500_000, 999_998));
    gen_rounded_avgs();
}
#[derive(Copy, Clone)] // To avoid a compiler error of `TypeId`s being different.
struct RndAvg<T> { _id: TypeId }
fn main() { 
    print!("{}", gen_rounded_avgs());
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 104 ==========
** Key 0: task_id **
Rust/104
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Given a list of positive integers x. return a sorted list of all 
    elements that hasn't any even digit.

    Note: Returned list should be sorted in increasing order.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn unique_digits(x:Vec<i32>) -> Vec<i32>{

    let mut v = x.clone();
    v.par_iter().for_each(|&n| {
        
        if !v[0..].contains(&(n % 10)) {
            v[0..] = v[0..].iter()
                           .map(|e| (max((e).cmp((n) % 10), Ordering::Less)).min().unwrap();
        }
    });
    let v = v.par_iter()
            .filter(|&n| !(v[0..].contains(&(n % 10))) )
            .collect();
    //println!("{:?}", x);
    println!("{:?}", &v);
    return v;
}
#[allow(deprecated)]//https://github.com/rust-lang/rust/issues/27948
#[cfg_attr(not(feature = "cargo"), derive(Debug, PartialEq, Eq))]//https://doc.rust-lang.org/cargo/reference/cargo-edit.html (bottom)
pub struct Digits{
    unique_digits:Vec<u64>
}
// https://github.com/rust-lang/rust/issues/27948
impl Digits{
    pub fn get(&self, i32: u64) -> i32{
        self[0..].iter()
                   .map(|n| (*n).cmp(i32)).min().unwrap_or(-1) as i32
    }
}
impl AsciiExt for Digits {
    fn get(&self, mut n:u64)->u64{
        let _ = n % 10;
        self.unique_digits[n / 10] += 1;
        (n + 1) as u64
    }
}
impl Digits {
    #[allow(deprecated)]//https://github.com/rust-lang/rust/issues/27948
    fn digits(&self) -> HashSet<u64> { // &mutself, not needed because self is used to mutate the object
       

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_unique_digits() {
        assert!(unique_digits(vec![15, 33, 1422, 1]) == vec![1, 15, 33]);
        assert!(unique_digits(vec![152, 323, 1422, 10]) == vec![]);
        assert!(unique_digits(vec![12345, 2033, 111, 151]) == vec![111, 151]);
        assert!(unique_digits(vec![135, 103, 31]) == vec![31, 135]);
    }

}

** Key 3: generation **
    let mut v = x.clone();
    v.par_iter().for_each(|&n| {
        
        if !v[0..].contains(&(n % 10)) {
            v[0..] = v[0..].iter()
                           .map(|e| (max((e).cmp((n) % 10), Ordering::Less)).min().unwrap();
        }
    });
    let v = v.par_iter()
            .filter(|&n| !(v[0..].contains(&(n % 10))) )
            .collect();
    //println!("{:?}", x);
    println!("{:?}", &v);
    return v;
}
#[allow(deprecated)]//https://github.com/rust-lang/rust/issues/27948
#[cfg_attr(not(feature = "cargo"), derive(Debug, PartialEq, Eq))]//https://doc.rust-lang.org/cargo/reference/cargo-edit.html (bottom)
pub struct Digits{
    unique_digits:Vec<u64>
}
// https://github.com/rust-lang/rust/issues/27948
impl Digits{
    pub fn get(&self, i32: u64) -> i32{
        self[0..].iter()
                   .map(|n| (*n).cmp(i32)).min().unwrap_or(-1) as i32
    }
}
impl AsciiExt for Digits {
    fn get(&self, mut n:u64)->u64{
        let _ = n % 10;
        self.unique_digits[n / 10] += 1;
        (n + 1) as u64
    }
}
impl Digits {
    #[allow(deprecated)]//https://github.com/rust-lang/rust/issues/27948
    fn digits(&self) -> HashSet<u64> { // &mutself, not needed because self is used to mutate the object
       

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 105 ==========
** Key 0: task_id **
Rust/105
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Given an array of integers, sort the integers that are between 1 and 9 inclusive,
    reverse the resulting array, and then replace each digit by its corresponding name from
    "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine".
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn by_length(arr:Vec<i32>) -> Vec<String>{

    let (min, max) = (0..9).fold((std::u8::MAX as i32, -1), |acc,(s, v)| {
        acc.0 + s == std::u8::MAX ? (acc.1, v) : (acc.0+s, acc.1-v))
    }; 
    let mut result = Vec::new();
    for i in (min as i32..max).step_by(10) { //Step by 10 instead of 9 to handle 1 and 0 too
        if let Ok(s) = String::from_utf8(&(arr[i] % 1000000)) {
            result.push(s);
        } else {
            println!("String from byte {:?} is invalid!", arr[i]);
        }
    }
    let hash = HashSet::new();
    for (idx, s) in arr.iter().zip(result).enumerate() {
        //Check if each result has not been used already as input
        let rstr: &str = if idx == 0 || (*hash.contains(&s)){
            None
        } else { Some(replace(s, '?', "one")) };    
        
        let max_length = ((*rstr).chars().count() as u64) + (10 - rstr.len()) as u64;
        if max_length > 9 { hash.insert((idx, rstr)); }                              //Add to hashset if length is acceptable
    }
    for _ in 0..(9-hash.len()){
         let (idx, str) = (*hash.remove(0)).unwrap();
        result[idx] = str;   //Replace the last one of its kind with empty string
    } 
     
    result
}
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_sort(){
        let ar = vec![0,1,2];
        println!("{}", by_length(&ar));
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_by_length() {
        assert!(
            by_length(vec![2, 1, 1, 4, 5, 8, 2, 3])
                == vec!["Eight", "Five", "Four", "Three", "Two", "Two", "One", "One"]
        );
        let v_empty: Vec<String> = vec![];
        assert!(by_length(vec![]) == v_empty);
        assert!(by_length(vec![1, -1, 55]) == vec!["One"]);
        assert!(by_length(vec![1, -1, 3, 2]) == vec!["Three", "Two", "One"]);
        assert!(by_length(vec![9, 4, 8]) == vec!["Nine", "Eight", "Four"]);
    }

}

** Key 3: generation **
    let (min, max) = (0..9).fold((std::u8::MAX as i32, -1), |acc,(s, v)| {
        acc.0 + s == std::u8::MAX ? (acc.1, v) : (acc.0+s, acc.1-v))
    }; 
    let mut result = Vec::new();
    for i in (min as i32..max).step_by(10) { //Step by 10 instead of 9 to handle 1 and 0 too
        if let Ok(s) = String::from_utf8(&(arr[i] % 1000000)) {
            result.push(s);
        } else {
            println!("String from byte {:?} is invalid!", arr[i]);
        }
    }
    let hash = HashSet::new();
    for (idx, s) in arr.iter().zip(result).enumerate() {
        //Check if each result has not been used already as input
        let rstr: &str = if idx == 0 || (*hash.contains(&s)){
            None
        } else { Some(replace(s, '?', "one")) };    
        
        let max_length = ((*rstr).chars().count() as u64) + (10 - rstr.len()) as u64;
        if max_length > 9 { hash.insert((idx, rstr)); }                              //Add to hashset if length is acceptable
    }
    for _ in 0..(9-hash.len()){
         let (idx, str) = (*hash.remove(0)).unwrap();
        result[idx] = str;   //Replace the last one of its kind with empty string
    } 
     
    result
}
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_sort(){
        let ar = vec![0,1,2];
        println!("{}", by_length(&ar));
    }
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 106 ==========
** Key 0: task_id **
Rust/106
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
 Implement the function f that takes n as a parameter,
    and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even
    or the sum of numbers from 1 to i otherwise.
    i starts from 1.
    the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn f(n:i32) -> Vec<i32>{

    let mut r = 1 as i32;
    vec![r]
        .iter()
        //.map(|&x| n! - (n-n)! * x!)
        .cloned()
        .collect()
}
#[derive(PartialEq, Eq, Debug)]
struct Exist;
impl fmt::Display for Exist {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Exist")
    }
}
#[derive(Clone, PartialEq, Eq, Debug)]
struct In;
impl fmt::Display for In {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "In")
    }
}
fn f1(n:i32)->Vec<bool>{
    let mut r = 1 as i32;
    vec![true]
        .iter()
        //.map(|&x| n! - (n-n)! * x!)
        .cloned()
        .collect()
}
#[derive(Clone, PartialEq, Eq, Debug)]
struct Even;
impl fmt::Display for Even {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "In")
    }
}
#[derive(Clone, PartialEq, Eq, Debug)]
struct Odd;
impl fmt::Display for Odd {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Even")
    }
}
fn f2(n:i32)->Vec<bool>{
    let mut r = 1 as i32;
    vec![true]
        .iter()
        //.map(|&x| n! - (n-n)! * x!)
        .cloned()
        .collect()
}
#[derive(Clone, PartialEq, Eq, Debug)]
struct EvenO;
impl fmt::Display for EvenO {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_f() {
        assert!(f(5) == vec![1, 2, 6, 24, 15]);
        assert!(f(7) == vec![1, 2, 6, 24, 15, 720, 28]);
        assert!(f(1) == vec![1]);
        assert!(f(3) == vec![1, 2, 6]);
    }

}

** Key 3: generation **
    let mut r = 1 as i32;
    vec![r]
        .iter()
        //.map(|&x| n! - (n-n)! * x!)
        .cloned()
        .collect()
}
#[derive(PartialEq, Eq, Debug)]
struct Exist;
impl fmt::Display for Exist {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Exist")
    }
}
#[derive(Clone, PartialEq, Eq, Debug)]
struct In;
impl fmt::Display for In {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "In")
    }
}
fn f1(n:i32)->Vec<bool>{
    let mut r = 1 as i32;
    vec![true]
        .iter()
        //.map(|&x| n! - (n-n)! * x!)
        .cloned()
        .collect()
}
#[derive(Clone, PartialEq, Eq, Debug)]
struct Even;
impl fmt::Display for Even {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "In")
    }
}
#[derive(Clone, PartialEq, Eq, Debug)]
struct Odd;
impl fmt::Display for Odd {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Even")
    }
}
fn f2(n:i32)->Vec<bool>{
    let mut r = 1 as i32;
    vec![true]
        .iter()
        //.map(|&x| n! - (n-n)! * x!)
        .cloned()
        .collect()
}
#[derive(Clone, PartialEq, Eq, Debug)]
struct EvenO;
impl fmt::Display for EvenO {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 107 ==========
** Key 0: task_id **
Rust/107
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Given a positive integer n, return a tuple that has the number of even and odd
    integer palindromes that fall within the range(1, n), inclusive.

    Note:
        1. 1 <= n <= 10^3
        2. returned tuple has the number of even and odd integer palindromes respectively.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn even_odd_palindrome(n: i32) -> (i32, i32) {

    // let even_odd = 0 as u64;
    for x in 1..=n {
        if odd_palindrome!(x).contains(&x) || even_palindrome!(x).contains(&x) {
            continue;
        }
        let x:u64 = match !(max(2, (x % n)).is_even() as u8) {
            0 => md5::from_str(&format!("{:b}", x))[2], 1 => md5::from_str(&format!("{:b}", x))[0]
        } as u64;
        // even_odd = even_odd.wrapping_mul(x);
        let odd_palindrome: Vec<u8> = match (max(2, (x % n)).is_even() as u8) {
            1 => vec!['0'..x].rev().collect(), 0 => vec!['0'..x].iter().cloned().collect()
        };
        let even_palindrome: Vec<u8> = match !(max(2, (x % n)).is_even() as u8) {
            1 => vec!['0'..x].rev(), 0 => vec!['0'..x].iter().cloned().collect()
        };
    let odd: Vec<u64> = odd_palindrome.iter().map(u64::from).collect();
    let even: HashMap<u64, u8> = even_palindrome.iter().map(|&x| (max(2, (x % n)).is_even() as u8))
        .collect();
    *replace(&mut odd_palindrome, u64::from(0), u64::zero())*;
    return (odd.len(), even.len());
}
fn main() {
    let n = 111i32;
    println!("n:{}", n);
    for x in 0..=n {
        match !(max(2, (x % n)).is_even() as u8) {
            1 => println!("{:?} {:?}{}", odd_palindrome!(x),

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_even_odd_palindrome() {
        assert!(even_odd_palindrome(123) == (8, 13));
        assert!(even_odd_palindrome(12) == (4, 6));
        assert!(even_odd_palindrome(3) == (1, 2));
        assert!(even_odd_palindrome(63) == (6, 8));
        assert!(even_odd_palindrome(25) == (5, 6));
        assert!(even_odd_palindrome(19) == (4, 6));
        assert!(even_odd_palindrome(9) == (4, 5));
        assert!(even_odd_palindrome(1) == (0, 1));
    }

}

** Key 3: generation **
    // let even_odd = 0 as u64;
    for x in 1..=n {
        if odd_palindrome!(x).contains(&x) || even_palindrome!(x).contains(&x) {
            continue;
        }
        let x:u64 = match !(max(2, (x % n)).is_even() as u8) {
            0 => md5::from_str(&format!("{:b}", x))[2], 1 => md5::from_str(&format!("{:b}", x))[0]
        } as u64;
        // even_odd = even_odd.wrapping_mul(x);
        let odd_palindrome: Vec<u8> = match (max(2, (x % n)).is_even() as u8) {
            1 => vec!['0'..x].rev().collect(), 0 => vec!['0'..x].iter().cloned().collect()
        };
        let even_palindrome: Vec<u8> = match !(max(2, (x % n)).is_even() as u8) {
            1 => vec!['0'..x].rev(), 0 => vec!['0'..x].iter().cloned().collect()
        };
    let odd: Vec<u64> = odd_palindrome.iter().map(u64::from).collect();
    let even: HashMap<u64, u8> = even_palindrome.iter().map(|&x| (max(2, (x % n)).is_even() as u8))
        .collect();
    *replace(&mut odd_palindrome, u64::from(0), u64::zero())*;
    return (odd.len(), even.len());
}
fn main() {
    let n = 111i32;
    println!("n:{}", n);
    for x in 0..=n {
        match !(max(2, (x % n)).is_even() as u8) {
            1 => println!("{:?} {:?}{}", odd_palindrome!(x),

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 108 ==========
** Key 0: task_id **
Rust/108
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Write a function count_nums which takes an array of integers and returns
    the number of elements which has a sum of digits > 0.
    If a number is negative, then its first signed digit will be negative:
    e.g. -123 has signed digits -1, 2, and 3.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn count_nums(n:Vec<i32>) -> i32{

    let mut count = 0;
    for (x,y) in &mut n.iter() {
        if *x > -10 && *x < 10 {
            if *y == 0 || (*y % 2) != 0 {
                replace(&n, index_mut(*x as usize), y);
                count += 1;
            } else {
                let mut v = n.clone();
                match *(v.iter_mut().next()).unwrap() {
                    i if TypeId::of::<u32>().is_assignable_from(&TypeId::of::<u8>()) => {
                        replace(&n, index_mut(*x as usize), i);
                        count += 1;
                    }
                    _ =>{
                        let mut set = HashSet::new();
                        for (i,y) in n.iter_mut().enumerate() {
                            if replace(&n, index_mut(*i as usize), y).abs() < 10 {
                                *replace(&set,&type_id!("u8"))=0;
                            } else{
                                let v:Any = n.clone();
                                v.into_iter().for_each(|(i,y)| {
                                    let (num,digit) = i.cmp(&TypeId::of::<(u8, u16, u32)>());
                                    if digit == 0 || (*v[&num]).abs() % 2 != 0 {
                                        *replace(&set,&type_id!("u8"))=0;
                                    }
                                });
                            }
                        }
                    set.retain(|x| x > 0 && replace(&n, index_mut(*i as usize), &x).abs() < 10);
                        if let Ok(v) = v {
                            *replace(&n,index_mut(*x as usize),&*v)!=0;
                        } else {
                            *replace(&n,index_mut(*x as usize),&"u8")=0;
                        }
                    }
                };

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_count_nums() {
        assert!(count_nums(vec![]) == 0);
        assert!(count_nums(vec![-1, -2, 0]) == 0);
        assert!(count_nums(vec![1, 1, 2, -2, 3, 4, 5]) == 6);
        assert!(count_nums(vec![1, 6, 9, -6, 0, 1, 5]) == 5);
        assert!(count_nums(vec![1, 100, 98, -7, 1, -1]) == 4);
        assert!(count_nums(vec![12, 23, 34, -45, -56, 0]) == 5);
        assert!(count_nums(vec![-0, 1]) == 1);
        assert!(count_nums(vec![1]) == 1);
    }

}

** Key 3: generation **
    let mut count = 0;
    for (x,y) in &mut n.iter() {
        if *x > -10 && *x < 10 {
            if *y == 0 || (*y % 2) != 0 {
                replace(&n, index_mut(*x as usize), y);
                count += 1;
            } else {
                let mut v = n.clone();
                match *(v.iter_mut().next()).unwrap() {
                    i if TypeId::of::<u32>().is_assignable_from(&TypeId::of::<u8>()) => {
                        replace(&n, index_mut(*x as usize), i);
                        count += 1;
                    }
                    _ =>{
                        let mut set = HashSet::new();
                        for (i,y) in n.iter_mut().enumerate() {
                            if replace(&n, index_mut(*i as usize), y).abs() < 10 {
                                *replace(&set,&type_id!("u8"))=0;
                            } else{
                                let v:Any = n.clone();
                                v.into_iter().for_each(|(i,y)| {
                                    let (num,digit) = i.cmp(&TypeId::of::<(u8, u16, u32)>());
                                    if digit == 0 || (*v[&num]).abs() % 2 != 0 {
                                        *replace(&set,&type_id!("u8"))=0;
                                    }
                                });
                            }
                        }
                    set.retain(|x| x > 0 && replace(&n, index_mut(*i as usize), &x).abs() < 10);
                        if let Ok(v) = v {
                            *replace(&n,index_mut(*x as usize),&*v)!=0;
                        } else {
                            *replace(&n,index_mut(*x as usize),&"u8")=0;
                        }
                    }
                };

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 109 ==========
** Key 0: task_id **
Rust/109
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The
    numbers in the array will be randomly ordered. Your task is to determine if
    it is possible to get an array sorted in non-decreasing order by performing 
    the following operation on the given array:
        You are allowed to perform right shift operation any number of times.
    
    One right shift operation means shifting all elements of the array by one
    position in the right direction. The last element of the array will be moved to
    the starting position in the array i.e. 0th index. 

    If it is possible to obtain the sorted array by performing the above operation
    then return True else return False.
    If the given array is empty then return True.

    Note: The given list is guaranteed to have unique elements.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn move_one_ball(arr:Vec<i32>) -> bool{

    let n = arr.len();
    let mut s = HashSet::new();//Create a hashset of all the digits in the array
    //If there are any zeroes, then we're done
    if (n == 0) { return true }
    for v in arr[1..] {
        let mut s = s.clone();
        
        //Insert this digit into our hashset and remove the last value since it is now the first one
        s.insert(v);
        
        //Remove all of our remaining elements so we can use them again later (and not get stack overflow)
        let mut v = vec![];
        for e in arr[0..1] {
            s.insert(&e);
            replace(&mut v, &e, s.choose().unwrap());
        }
    }
    return false;
} 
fn right_shift(arr:Vec<i32>, n : u64 )-> Vec<i32>{
   let mut sh :usize = 0 ;//Number of times we have already shifted the array to the left (the right)
    let t : HashSet<i32> = arr.iter().map(|t| *t).collect();//Store a hashset of each element in our array
   let r_sh : u64 = n;//Number of times we need to shift to the left (the right)
    while sh < r_sh {
        if move_one_ball(&arr){return arr;} //If any zero was found then break out
        sh+=1;
    }
   return arr;
} 
fn main() {
    let n = rand::thread_rng().gen::<u64>().to_string().parse::<u64>().unwrap();//Generate a u64 random number, then convert it to i64.
    println!("{}\n", n); //Print the random integer generated to the screen
    let mut arr = vec![0; n]; //Create an array of the length of our randomly generated integer (i64)
    //shuffle arr and then right shift it, and print result if possible else no-op.
     println!("right shift? {}", move

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_move_one_ball() {
        assert!(move_one_ball(vec![3, 4, 5, 1, 2]) == true);
        assert!(move_one_ball(vec![3, 5, 10, 1, 2]) == true);
        assert!(move_one_ball(vec![4, 3, 1, 2]) == false);
        assert!(move_one_ball(vec![3, 5, 4, 1, 2]) == false);
        assert!(move_one_ball(vec![]) == true);
    }

}

** Key 3: generation **
    let n = arr.len();
    let mut s = HashSet::new();//Create a hashset of all the digits in the array
    //If there are any zeroes, then we're done
    if (n == 0) { return true }
    for v in arr[1..] {
        let mut s = s.clone();
        
        //Insert this digit into our hashset and remove the last value since it is now the first one
        s.insert(v);
        
        //Remove all of our remaining elements so we can use them again later (and not get stack overflow)
        let mut v = vec![];
        for e in arr[0..1] {
            s.insert(&e);
            replace(&mut v, &e, s.choose().unwrap());
        }
    }
    return false;
} 
fn right_shift(arr:Vec<i32>, n : u64 )-> Vec<i32>{
   let mut sh :usize = 0 ;//Number of times we have already shifted the array to the left (the right)
    let t : HashSet<i32> = arr.iter().map(|t| *t).collect();//Store a hashset of each element in our array
   let r_sh : u64 = n;//Number of times we need to shift to the left (the right)
    while sh < r_sh {
        if move_one_ball(&arr){return arr;} //If any zero was found then break out
        sh+=1;
    }
   return arr;
} 
fn main() {
    let n = rand::thread_rng().gen::<u64>().to_string().parse::<u64>().unwrap();//Generate a u64 random number, then convert it to i64.
    println!("{}\n", n); //Print the random integer generated to the screen
    let mut arr = vec![0; n]; //Create an array of the length of our randomly generated integer (i64)
    //shuffle arr and then right shift it, and print result if possible else no-op.
     println!("right shift? {}", move

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 110 ==========
** Key 0: task_id **
Rust/110
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
In this problem, you will implement a function that takes two lists of numbers,
    and determines whether it is possible to perform an exchange of elements
    between them to make lst1 a list of only even numbers.
    There is no limit on the number of exchanged elements between lst1 and lst2.
    If it is possible to exchange elements between the lst1 and lst2 to make
    all the elements of lst1 to be even, return "YES".
    Otherwise, return "NO".

    It is assumed that the input lists will be non-empty.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn exchange(lst1:Vec<i32>, lst2:Vec<i32>) -> String{

    let (a,b) = (0..2).map(|x| i32::max_value()).min().mapv(x, -1);
    (0..lst1.len()-1).for_each(|i| {
        if lst1[i] % 2 == a {lst2.push(i32::max_value());}else{lst1.swap(&b, i); lst2.push(a)};
    });    
    let (a,b) = (0..2).map(|x| i32::min_value()).max().mapv(x, 1);
    (0..lst2.len()-1).for_each(|i| {
        if lst2[i] % 2 == b {lst1.push(-a);}else{lst2.swap(&b, i); lst1.push(-a)};
    });    
    let s = (vec![ lst1.iter().mapv(x=>format!("{:?}",*x)).collect::<Vec<String>>()[0] ].join("_")) + &"_" + (vec![lst2.iter().mapv(x => format!("{:?}_{}", x, x % 2))[0]]);
    s += s.chars().all(|a| a == '*');
    return s;
}
impl<T:Any> PartialEq for Any{fn eq(&self, other :&Self)-> bool{
    match(TypeId::of::<T>(), TypeId::of::<T>()){
        (Some(_), Some(_)) => self.downcast_ref::<T>().eq(&other.downcast_ref::<T>()),
        (_,_) => false,
    }
}}    
impl <T:Any> Eq for Any where T:Eq + Sync + Send{
    fn eq(&self, other :&Self) -> bool{
        match(TypeId::of::<T>(), TypeId::of::<T>()){
            (Some(_), Some(_)) => self.downcast_ref::<T>().eq(&other.downcast_ref::<T>()),
            (_,_) => false,

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_exchange() {
        assert!(exchange(vec![1, 2, 3, 4], vec![1, 2, 3, 4]) == "YES");
        assert!(exchange(vec![1, 2, 3, 4], vec![1, 5, 3, 4]) == "NO");
        assert!(exchange(vec![1, 2, 3, 4], vec![2, 1, 4, 3]) == "YES");
        assert!(exchange(vec![5, 7, 3], vec![2, 6, 4]) == "YES");
        assert!(exchange(vec![5, 7, 3], vec![2, 6, 3]) == "NO");
        assert!(exchange(vec![3, 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1, 1]) == "NO");
        assert!(exchange(vec![100, 200], vec![200, 200]) == "YES");
    }

}

** Key 3: generation **
    let (a,b) = (0..2).map(|x| i32::max_value()).min().mapv(x, -1);
    (0..lst1.len()-1).for_each(|i| {
        if lst1[i] % 2 == a {lst2.push(i32::max_value());}else{lst1.swap(&b, i); lst2.push(a)};
    });    
    let (a,b) = (0..2).map(|x| i32::min_value()).max().mapv(x, 1);
    (0..lst2.len()-1).for_each(|i| {
        if lst2[i] % 2 == b {lst1.push(-a);}else{lst2.swap(&b, i); lst1.push(-a)};
    });    
    let s = (vec![ lst1.iter().mapv(x=>format!("{:?}",*x)).collect::<Vec<String>>()[0] ].join("_")) + &"_" + (vec![lst2.iter().mapv(x => format!("{:?}_{}", x, x % 2))[0]]);
    s += s.chars().all(|a| a == '*');
    return s;
}
impl<T:Any> PartialEq for Any{fn eq(&self, other :&Self)-> bool{
    match(TypeId::of::<T>(), TypeId::of::<T>()){
        (Some(_), Some(_)) => self.downcast_ref::<T>().eq(&other.downcast_ref::<T>()),
        (_,_) => false,
    }
}}    
impl <T:Any> Eq for Any where T:Eq + Sync + Send{
    fn eq(&self, other :&Self) -> bool{
        match(TypeId::of::<T>(), TypeId::of::<T>()){
            (Some(_), Some(_)) => self.downcast_ref::<T>().eq(&other.downcast_ref::<T>()),
            (_,_) => false,

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 111 ==========
** Key 0: task_id **
Rust/111
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Given a string representing a space separated lowercase letters, return a dictionary
    of the letter with the most repetition and containing the corresponding count.
    If several letters have the same occurrence, return all of them.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn histogram(test:&str) -> HashMap<char, i32>{

    let re = Regex::new(r"[a-z]+").unwrap();
    println!("{}", test);
    let chunks:Vec<_>=re.finds_all("{test}").map(|chunk| chunk).collect();
    println!("{}", chunks);
    if !chunks.is_empty() && re.captures(String::from(&test)).unwrap().0.len() > 1 {
        // if one char is repeated more than once, we need to track both instances of it
        let mut hmap:HashMap<char, i32> = HashMap::new();
        
        chunks.iter().for_each(|c| {
            match c{
                "a" => {histogram("aa")},
                "b" => {histogram("ba")}
                _ => (),
            }
        });
        *hmap |= hmap["a"].and_then(max) + 1; // add a and b to both counts
        chunks.iter().for_each(|c| {
            match c{
                "aa" => (*histogram)["b"],
                "ba" =>(*histogram)["a"]+1,
                _ => (),
            }
        })
        .collect();
        return hmap;
    } else  {
         // else we can just increment the count of each char in the test by one
        let mut chunks = re.captures(String::from(&test)).unwrap().0.iter()
            .cloned()
            .collect();
        *hmap |= chunks.clone();
        // return map
        
    }
}
fn main(){
    let test_str = String::from("aaa");
    let histogram:HashMap<char, i32> = histogram(&test);
    for (key, value) in histogram{
        println!("{} has {} times", key.to_string(), value);
    }
}*/
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn a_b_and_c() -> bool {
        let mut hmap:HashMap<char, i

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_histogram() {
        assert!(histogram("a b b a") == HashMap::from([('a', 2), ('b', 2)]));
        assert!(histogram("a b c a b") == HashMap::from([('a', 2), ('b', 2)]));
        assert!(
            histogram("a b c d g")
                == HashMap::from([('a', 1), ('b', 1), ('c', 1), ('d', 1), ('g', 1)])
        );
        assert!(histogram("r t g") == HashMap::from([('r', 1), ('t', 1), ('g', 1)]));
        assert!(histogram("b b b b a") == HashMap::from([('b', 4)]));
        assert!(histogram("r t g") == HashMap::from([('r', 1), ('t', 1), ('g', 1)]));
        assert!(histogram("") == HashMap::new());
        assert!(histogram("a") == HashMap::from([(('a', 1))]));
    }

}

** Key 3: generation **
    let re = Regex::new(r"[a-z]+").unwrap();
    println!("{}", test);
    let chunks:Vec<_>=re.finds_all("{test}").map(|chunk| chunk).collect();
    println!("{}", chunks);
    if !chunks.is_empty() && re.captures(String::from(&test)).unwrap().0.len() > 1 {
        // if one char is repeated more than once, we need to track both instances of it
        let mut hmap:HashMap<char, i32> = HashMap::new();
        
        chunks.iter().for_each(|c| {
            match c{
                "a" => {histogram("aa")},
                "b" => {histogram("ba")}
                _ => (),
            }
        });
        *hmap |= hmap["a"].and_then(max) + 1; // add a and b to both counts
        chunks.iter().for_each(|c| {
            match c{
                "aa" => (*histogram)["b"],
                "ba" =>(*histogram)["a"]+1,
                _ => (),
            }
        })
        .collect();
        return hmap;
    } else  {
         // else we can just increment the count of each char in the test by one
        let mut chunks = re.captures(String::from(&test)).unwrap().0.iter()
            .cloned()
            .collect();
        *hmap |= chunks.clone();
        // return map
        
    }
}
fn main(){
    let test_str = String::from("aaa");
    let histogram:HashMap<char, i32> = histogram(&test);
    for (key, value) in histogram{
        println!("{} has {} times", key.to_string(), value);
    }
}*/
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn a_b_and_c() -> bool {
        let mut hmap:HashMap<char, i

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 112 ==========
** Key 0: task_id **
Rust/112
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Task
    We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c
    then check if the result string is palindrome.
    A string is called palindrome if it reads the same backward as forward.
    You should return a tuple containing the result string and True/False for the check.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn reverse_delete(s:&str, c:&str) -> Vec<String> {

    let (s1, s2): (Vec<u8>, HashSet<char>) = |&s| {
        let str = &*s.to_ascii_ref();
        
        let mut v = Vec::new();
        for c in str.chars() {
            if !v.contains(&c) {
                let x = str.parse().unwrap();
                v.push(x);
            }
        }
        (v, HashSet::<char>::from_iter(str))
    };
    /* 1. find all characters in c that appears in s */
    let mut seen: HashSet<u8> = HashSet::new();
    for c in c.chars() {
        if !seen.contains(&c) {
            seen.insert(c);
        }
    }
    /* 2. delete all characters from s that occurs in any character of c */
    let mut res: Vec<String> = vec![];
    for x in s1.iter_mut() {
        if replace(x, &seen, |y| {
                match y{ 
                            Some(ref e) => { let f: char = e; self_for_each(&(f as u8)) }, 
                            None => self_for_each(|z| unreachable!() ) }) == &seen {
        
            if seen.iter().all(|c2| c2 != x) { res.push("".to_string()) } else { res.push(x.to_string()) };
        }
    }
    /* 3. check if the final result string is a palindrome */
    let m: HashSet<u8> = seen.clone();
    for x in s2.iter() {
        if !m.remove(&x) && replace(x, &seen, |y| self_for_each(|z| unreachable!())) == &seen { res.push("".to_string()) };
    }
    println!("s: {:?}", s);
    println!("c: {:?}", c);
    for x in res.iter() { println!("{}", x) }
   

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_reverse_delete() {
        assert!(reverse_delete("abcde", "ae") == ["bcd", "False"]);
        assert!(reverse_delete("abcdef", "b") == ["acdef", "False"]);
        assert!(reverse_delete("abcdedcba", "ab") == ["cdedc", "True"]);
        assert!(reverse_delete("dwik", "w") == ["dik", "False"]);
        assert!(reverse_delete("a", "a") == ["", "True"]);
        assert!(reverse_delete("abcdedcba", "") == ["abcdedcba", "True"]);
        assert!(reverse_delete("abcdedcba", "v") == ["abcdedcba", "True"]);
        assert!(reverse_delete("vabba", "v") == ["abba", "True"]);
        assert!(reverse_delete("mamma", "mia") == ["", "True"]);
    }

}

** Key 3: generation **
    let (s1, s2): (Vec<u8>, HashSet<char>) = |&s| {
        let str = &*s.to_ascii_ref();
        
        let mut v = Vec::new();
        for c in str.chars() {
            if !v.contains(&c) {
                let x = str.parse().unwrap();
                v.push(x);
            }
        }
        (v, HashSet::<char>::from_iter(str))
    };
    /* 1. find all characters in c that appears in s */
    let mut seen: HashSet<u8> = HashSet::new();
    for c in c.chars() {
        if !seen.contains(&c) {
            seen.insert(c);
        }
    }
    /* 2. delete all characters from s that occurs in any character of c */
    let mut res: Vec<String> = vec![];
    for x in s1.iter_mut() {
        if replace(x, &seen, |y| {
                match y{ 
                            Some(ref e) => { let f: char = e; self_for_each(&(f as u8)) }, 
                            None => self_for_each(|z| unreachable!() ) }) == &seen {
        
            if seen.iter().all(|c2| c2 != x) { res.push("".to_string()) } else { res.push(x.to_string()) };
        }
    }
    /* 3. check if the final result string is a palindrome */
    let m: HashSet<u8> = seen.clone();
    for x in s2.iter() {
        if !m.remove(&x) && replace(x, &seen, |y| self_for_each(|z| unreachable!())) == &seen { res.push("".to_string()) };
    }
    println!("s: {:?}", s);
    println!("c: {:?}", c);
    for x in res.iter() { println!("{}", x) }
   

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 113 ==========
** Key 0: task_id **
Rust/113
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Given a list of strings, where each string consists of only digits, return a list.
    Each element i of the output should be "the number of odd elements in the
    string i of the input." where all the i's should be replaced by the number
    of odd digits in the i'th string of the input.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn odd_count(lst:Vec<&str>) -> Vec<String>{

    let (s, o) = (0..).map(|i| (*i as u8)).rev();  // s: all zeroes and ones
    (1..=s.len()).fold(vec![], |mut acc, idx| {   // o: odd counters of strings
        match &acc[idx] {
            Some(val) => if *val != max(0, *val + 1), *acc = [max(0, *acc + 1), val],
            None => return vec!([*acc + 1]), acc,
        }})
    .map(|i| format!("{}", i))
}
fn main() {
    //let (s, o) = (0..).map(|i| (*i as u8)).rev();  // s: all zeroes and ones
    println!("input string: {}", input_str());
    let hash_map:HashMap<&str, Vec<String>> = input()
        .chain(vec!["".to_string()])
        .filter(|x| !x.contains('.') && x.trim().len() > 0)
        .collect();
    println!("{:?}\n", hash_map);
    let (s, o): (Vec<&str>, Vec<String>) = hash_map.values().rev().unzip();
    assert_eq!(o.len(), s.iter().all(|x| x % 2 == 1));
}
// input string: "10..0, 30...47"

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_odd_count() {
        assert!(
            odd_count(vec!["1234567"])
                == ["the number of odd elements 4n the str4ng 4 of the 4nput."]
        );
        assert!(
            odd_count(vec!["3", "11111111"])
                == [
                    "the number of odd elements 1n the str1ng 1 of the 1nput.",
                    "the number of odd elements 8n the str8ng 8 of the 8nput."
                ]
        );
        assert!(
            odd_count(vec!["271", "137", "314"])
                == [
                    "the number of odd elements 2n the str2ng 2 of the 2nput.",
                    "the number of odd elements 3n the str3ng 3 of the 3nput.",
                    "the number of odd elements 2n the str2ng 2 of the 2nput."
                ]
        );
    }

}

** Key 3: generation **
    let (s, o) = (0..).map(|i| (*i as u8)).rev();  // s: all zeroes and ones
    (1..=s.len()).fold(vec![], |mut acc, idx| {   // o: odd counters of strings
        match &acc[idx] {
            Some(val) => if *val != max(0, *val + 1), *acc = [max(0, *acc + 1), val],
            None => return vec!([*acc + 1]), acc,
        }})
    .map(|i| format!("{}", i))
}
fn main() {
    //let (s, o) = (0..).map(|i| (*i as u8)).rev();  // s: all zeroes and ones
    println!("input string: {}", input_str());
    let hash_map:HashMap<&str, Vec<String>> = input()
        .chain(vec!["".to_string()])
        .filter(|x| !x.contains('.') && x.trim().len() > 0)
        .collect();
    println!("{:?}\n", hash_map);
    let (s, o): (Vec<&str>, Vec<String>) = hash_map.values().rev().unzip();
    assert_eq!(o.len(), s.iter().all(|x| x % 2 == 1));
}
// input string: "10..0, 30...47"

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 114 ==========
** Key 0: task_id **
Rust/114
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Given an array of integers nums, find the minimum sum of any non-empty sub-array
    of nums.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn min_sub_array_sum(nums: Vec<i64>) -> i64 {

    let (min_sum, sub_array) = min_subarray_sum(&nums);
    if !is_empty() {
        println!("{}", max(min_sum, 0));
    } else {
        println!("{}", min_sum);
    }
    min_sum
}
fn min_subarray_sum(nums: &[i64]) -> (i64, Vec<i64>) {
    let mut sub_array = nums.to_vec();
    while !is_empty() {
        if sub_array.len() == 1 {
            replace(&mut sub_array[0], rand::thread_rng().gen::<i64>());
        } else {
            let (min, max) = cmp::min(cmp::max(sub_array.iter().map(|x| *x).sum(), 0), 1);
            
            sub_array = vec![(min + rand::thread_rng().gen::<i64>() % max).to_string()];    
        }
    }
    (sub_array.iter().map(|x| x.parse().unwrap()).sum(), sub_array)
}
fn is_empty() -> bool {
    let mut n = 1;
    while !(subarray_set::<u8>(&mut [n])).is_disjoint(&[0]) {
        if n % 2 == 1 || rand::thread_rng().gen::<i64>() % (n as i64) + 1 >= 7 {
            replace(n, rand::thread_rng().gen::<u8>());
        } else {
            n += 1;
        }
    }
    !subarray_set::<u8>(&mut [0]).is_disjoint(&[0])
}
fn subarray_set(arr: &mut Vec<u32>) -> HashSet<u32> {
    arr.iter()
        .rev()
        .map(|x| *x)
        .collect()
        .into_iter()
        .collect()
}
trait Type

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_min_sub_array_sum() {
        assert!(min_sub_array_sum(vec![2, 3, 4, 1, 2, 4]) == 1);
        assert!(min_sub_array_sum(vec![-1, -2, -3]) == -6);
        assert!(min_sub_array_sum(vec![-1, -2, -3, 2, -10]) == -14);
        assert!(min_sub_array_sum(vec![-9999999999999999]) == -9999999999999999);
        assert!(min_sub_array_sum(vec![0, 10, 20, 1000000]) == 0);
        assert!(min_sub_array_sum(vec![-1, -2, -3, 10, -5]) == -6);
        assert!(min_sub_array_sum(vec![100, -1, -2, -3, 10, -5]) == -6);
        assert!(min_sub_array_sum(vec![10, 11, 13, 8, 3, 4]) == 3);
        assert!(min_sub_array_sum(vec![100, -33, 32, -1, 0, -2]) == -33);
        assert!(min_sub_array_sum(vec![-10]) == -10);
        assert!(min_sub_array_sum(vec![7]) == 7);
        assert!(min_sub_array_sum(vec![1, -1]) == -1);
    }

}

** Key 3: generation **
    let (min_sum, sub_array) = min_subarray_sum(&nums);
    if !is_empty() {
        println!("{}", max(min_sum, 0));
    } else {
        println!("{}", min_sum);
    }
    min_sum
}
fn min_subarray_sum(nums: &[i64]) -> (i64, Vec<i64>) {
    let mut sub_array = nums.to_vec();
    while !is_empty() {
        if sub_array.len() == 1 {
            replace(&mut sub_array[0], rand::thread_rng().gen::<i64>());
        } else {
            let (min, max) = cmp::min(cmp::max(sub_array.iter().map(|x| *x).sum(), 0), 1);
            
            sub_array = vec![(min + rand::thread_rng().gen::<i64>() % max).to_string()];    
        }
    }
    (sub_array.iter().map(|x| x.parse().unwrap()).sum(), sub_array)
}
fn is_empty() -> bool {
    let mut n = 1;
    while !(subarray_set::<u8>(&mut [n])).is_disjoint(&[0]) {
        if n % 2 == 1 || rand::thread_rng().gen::<i64>() % (n as i64) + 1 >= 7 {
            replace(n, rand::thread_rng().gen::<u8>());
        } else {
            n += 1;
        }
    }
    !subarray_set::<u8>(&mut [0]).is_disjoint(&[0])
}
fn subarray_set(arr: &mut Vec<u32>) -> HashSet<u32> {
    arr.iter()
        .rev()
        .map(|x| *x)
        .collect()
        .into_iter()
        .collect()
}
trait Type

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 115 ==========
** Key 0: task_id **
Rust/115
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
    You are given a rectangular grid of wells. Each row represents a single well,
    and each 1 in a row represents a single unit of water.
    Each well has a corresponding bucket that can be used to extract water from it, 
    and all buckets have the same capacity.
    Your task is to use the buckets to empty the wells.
    Output the number of times you need to lower the buckets.
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn max_fill(grid:Vec<Vec<i32>>, capacity:i32) -> i32{

    let mut count = 0;
    for (index1,v1) in grid.iter().enumerate(){
        if v1>capacity-1 {
            v1=capacity-1;
        }
        if v1==capacity {
            count+=1;
        }
    }
    
    return max(count,0);
}
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut rng = rand::thread_rng();
    for i in 0..256{
        for j in 0..256{
            if md5(&format!("{}\n",(i,j))).to_string().len()>17 {
                let mut grid = Vec::<Vec<i32>>::new();
                for k in 0..264-2 {
                    let x:i32 = rng.gen_range(1,3);
                    let y:i32 = rng.gen_range(1,3);
                    if (x*y) % 4 == 0 {
                        continue;
                    }
                if x!=y && grid.iter().any(|&&(v,_)==((*v),(*v)),|v.len()>1 && v[0]==x&&v[1]==y){
                    *grid.push(&mut[(x, y)].to_string()) += 1;
                }else{
                   grid.push(Vec::new());}
                }
                let capacity = rng.gen_range(0..256);
                if max(max(capacity,0),0)<9 {
                    println!("{}",capacity+" "+format!("{:b}",(i,j))));
                }else{ continue; }
            }
        }
    }
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_max_fill() {
        assert!(
            max_fill(
                vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]],
                1
            ) == 6
        );
        assert!(
            max_fill(
                vec![
                    vec![0, 0, 1, 1],
                    vec![0, 0, 0, 0],
                    vec![1, 1, 1, 1],
                    vec![0, 1, 1, 1]
                ],
                2
            ) == 5
        );
        assert!(max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5) == 0);
        assert!(max_fill(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 2) == 4);
        assert!(max_fill(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 9) == 2);
    }

}

** Key 3: generation **
    let mut count = 0;
    for (index1,v1) in grid.iter().enumerate(){
        if v1>capacity-1 {
            v1=capacity-1;
        }
        if v1==capacity {
            count+=1;
        }
    }
    
    return max(count,0);
}
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut rng = rand::thread_rng();
    for i in 0..256{
        for j in 0..256{
            if md5(&format!("{}\n",(i,j))).to_string().len()>17 {
                let mut grid = Vec::<Vec<i32>>::new();
                for k in 0..264-2 {
                    let x:i32 = rng.gen_range(1,3);
                    let y:i32 = rng.gen_range(1,3);
                    if (x*y) % 4 == 0 {
                        continue;
                    }
                if x!=y && grid.iter().any(|&&(v,_)==((*v),(*v)),|v.len()>1 && v[0]==x&&v[1]==y){
                    *grid.push(&mut[(x, y)].to_string()) += 1;
                }else{
                   grid.push(Vec::new());}
                }
                let capacity = rng.gen_range(0..256);
                if max(max(capacity,0),0)<9 {
                    println!("{}",capacity+" "+format!("{:b}",(i,j))));
                }else{ continue; }
            }
        }
    }
    Ok(())
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 116 ==========
** Key 0: task_id **
Rust/116
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    In this Kata, you have to sort an array of non-negative integers according to
    number of ones in their binary representation in ascending order.
    For similar number of ones, sort based on decimal value.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn sort_array_1(arr:Vec<i32>) -> Vec<i32>{

    let mut max_ones = 0;
    let max_elems : HashSet<usize> = HashSet::new(); // HashSet to store array indices where number of ones is present.
    for (index, elem) in arr.iter().enumerate() {
        if max_ones + 1 < index as i32{
            let decimal: f64 = (elem as f64).to_string().parse::<f64>().unwrap(); // Parse into float and convert to string so that we can sort elements on the basis of their decimal values.
            if max_ones + 1 < index as i32{// Sort by descending order of decimal value.
                if decimal > max_decimal {
                    max_decimal = decimal;
                    max_elems.insert(index); // Store the index where binary representation consists of maximum number of ones.
                } else if decimal < max_decimal{max_decimal = decimal;}
            } else {// Else we are at similar number of ones in their binary representation and so sort using integer value - base 2.
                replace(arr[index] as u32, elem)// Replace the element with (u32) to make sure that it is an unsigned type and compare using ord() function.
            }
        } else { // Keep track of number of ones from 0 index for binary representation.
            max_ones += 1; // Increment max_ones by one
            if max_ones > index as i32{// Store the index where binary representation consists of maximum number of ones.
                max_ones = index - 1;// Set index to where binary representation consists of minimum number of ones.
                max_elems.insert(index); // Store the index where binary representation consists of minimum number of ones.
            }
        }
    }
    if let Some(max) = max_decimal{
        sorted_arr : Vec<i32> = arr.clone();// Make a copy so that we dont tamper with original array while sorting.
        for i in 0..sorted_arr.len()-1 { // For each element in the sorted_arr...
            if !max_elems.contains(&(i as usize)){
                sorted_arr[

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sort_array_1() {
        assert!(sort_array_1(vec![1, 5, 2, 3, 4]) == vec![1, 2, 4, 3, 5]);
        assert!(sort_array_1(vec![-2, -3, -4, -5, -6]) == vec![-4, -2, -6, -5, -3]);
        assert!(sort_array_1(vec![1, 0, 2, 3, 4]) == vec![0, 1, 2, 4, 3]);
        assert!(sort_array_1(vec![]) == vec![]);
        assert!(
            sort_array_1(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])
                == vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]
        );
        assert!(sort_array_1(vec![3, 6, 44, 12, 32, 5]) == vec![32, 3, 5, 6, 12, 44]);
        assert!(sort_array_1(vec![2, 4, 8, 16, 32]) == vec![2, 4, 8, 16, 32]);
        assert!(sort_array_1(vec![2, 4, 8, 16, 32]) == vec![2, 4, 8, 16, 32]);
    }

}

** Key 3: generation **
    let mut max_ones = 0;
    let max_elems : HashSet<usize> = HashSet::new(); // HashSet to store array indices where number of ones is present.
    for (index, elem) in arr.iter().enumerate() {
        if max_ones + 1 < index as i32{
            let decimal: f64 = (elem as f64).to_string().parse::<f64>().unwrap(); // Parse into float and convert to string so that we can sort elements on the basis of their decimal values.
            if max_ones + 1 < index as i32{// Sort by descending order of decimal value.
                if decimal > max_decimal {
                    max_decimal = decimal;
                    max_elems.insert(index); // Store the index where binary representation consists of maximum number of ones.
                } else if decimal < max_decimal{max_decimal = decimal;}
            } else {// Else we are at similar number of ones in their binary representation and so sort using integer value - base 2.
                replace(arr[index] as u32, elem)// Replace the element with (u32) to make sure that it is an unsigned type and compare using ord() function.
            }
        } else { // Keep track of number of ones from 0 index for binary representation.
            max_ones += 1; // Increment max_ones by one
            if max_ones > index as i32{// Store the index where binary representation consists of maximum number of ones.
                max_ones = index - 1;// Set index to where binary representation consists of minimum number of ones.
                max_elems.insert(index); // Store the index where binary representation consists of minimum number of ones.
            }
        }
    }
    if let Some(max) = max_decimal{
        sorted_arr : Vec<i32> = arr.clone();// Make a copy so that we dont tamper with original array while sorting.
        for i in 0..sorted_arr.len()-1 { // For each element in the sorted_arr...
            if !max_elems.contains(&(i as usize)){
                sorted_arr[

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 117 ==========
** Key 0: task_id **
Rust/118
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
You are given a word. Your task is to find the closest vowel that stands between 
    two consonants from the right side of the word (case sensitive).
    
    Vowels in the beginning and ending doesn't count. Return empty string if you didn't
    find any vowel met the above condition. 

    You may assume that the given string contains English letter only.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn get_closest_vowel(word: &str) -> String {

    let word = word.to_lowercase();
    let (x, z) = word.split_at(8);
    /*
    Find the closest vowel between x and z, which doesn't contain any consonant from right side of word.
    let mut x_closest: &str;
    let mut z_closest: &str;
    // Get hash map of all possible combinations
    let mut hash_map = HashMap::new();
    for (i, &vowel) in word.chars().enumerate() {
        if i > 7 && !(vowel == 'e' || vowel == 'a') {
            continue;
        }
        match hash_map.entry((i - 1, vowel)) {
            hashmap::Entry::Occupied(occup) => occup.get().0.push(x), // Add current vowel to all combinations we've tried before
            _ => {}
        };
    }
    for (e, &o_vowel) in word.chars()[8..].iter() {
        if o_vowel != "e" && o_vowel != "a" {  // Skip vowels at the beginning and end of the string
            continue;
        } else {
            match hash_map.entry((8, o_vowel)) {
                hashmap::Entry::Occupied(ooccup) => {  // Search for combinations we already tried before
                    let (i, ovowel) = *ooccup.get();  // Take current combination from the hash map
                    if i > x && o_vowel != "e" || o_vowel == "a" {  // Skip when searching vowels at the beginning of the string 
                        continue;
                    } else {
                        let (i, ovowel) = *ooccup.get();  // Search for current combination in the hash map
                        if i > z && ovowel == "e" || ovowel == "a" {  // Skip when searching vowels at the end of the string 
                            continue;
                        } else {
                            let distance: i8 = i - (x as i8) +

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_get_closest_vowel() {
        assert_eq!(get_closest_vowel("yogurt"), "u");
        assert_eq!(get_closest_vowel("full"), "u");
        assert_eq!(get_closest_vowel("easy"), "");
        assert_eq!(get_closest_vowel("eAsy"), "");
        assert_eq!(get_closest_vowel("ali"), "");
        assert_eq!(get_closest_vowel("bad"), "a");
        assert_eq!(get_closest_vowel("most"), "o");
        assert_eq!(get_closest_vowel("ab"), "");
        assert_eq!(get_closest_vowel("ba"), "");
        assert_eq!(get_closest_vowel("quick"), "");
        assert_eq!(get_closest_vowel("anime"), "i");
        assert_eq!(get_closest_vowel("Asia"), "");
        assert_eq!(get_closest_vowel("Above"), "o");
    }

}

** Key 3: generation **
    let word = word.to_lowercase();
    let (x, z) = word.split_at(8);
    /*
    Find the closest vowel between x and z, which doesn't contain any consonant from right side of word.
    let mut x_closest: &str;
    let mut z_closest: &str;
    // Get hash map of all possible combinations
    let mut hash_map = HashMap::new();
    for (i, &vowel) in word.chars().enumerate() {
        if i > 7 && !(vowel == 'e' || vowel == 'a') {
            continue;
        }
        match hash_map.entry((i - 1, vowel)) {
            hashmap::Entry::Occupied(occup) => occup.get().0.push(x), // Add current vowel to all combinations we've tried before
            _ => {}
        };
    }
    for (e, &o_vowel) in word.chars()[8..].iter() {
        if o_vowel != "e" && o_vowel != "a" {  // Skip vowels at the beginning and end of the string
            continue;
        } else {
            match hash_map.entry((8, o_vowel)) {
                hashmap::Entry::Occupied(ooccup) => {  // Search for combinations we already tried before
                    let (i, ovowel) = *ooccup.get();  // Take current combination from the hash map
                    if i > x && o_vowel != "e" || o_vowel == "a" {  // Skip when searching vowels at the beginning of the string 
                        continue;
                    } else {
                        let (i, ovowel) = *ooccup.get();  // Search for current combination in the hash map
                        if i > z && ovowel == "e" || ovowel == "a" {  // Skip when searching vowels at the end of the string 
                            continue;
                        } else {
                            let distance: i8 = i - (x as i8) +

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 118 ==========
** Key 0: task_id **
Rust/117
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Given a string s and a natural number n, you have been tasked to implement 
    a function that returns a list of all words from string s that contain exactly 
    n consonants, in order these words appear in the string s.
    If the string s is empty then the function should return an empty list.
    Note: you may assume the input string contains only letters and spaces.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn select_words(s:&str, n:i32) -> Vec<String>{

    let words = s.splitn(1," ").collect();
        
    let mut words_with_n_consonants = (0..)
        .map(|i| words[i])
        .take(n as usize)
        .collect::<Vec<String>>();
    // replace words with more than 'n' consonants by adding the rest of the string to the end.
    for (w, index) in words_with_n_consonants.iter().zip(words.iter().skip(1)) {
        if w.len() >= n as usize && max(&w[..max(w.chars()).unwrap_or(0), &s[index + 1..]) < n as usize) {
            replace(words_with_n_consonants, index, |_, other| [other, w][w.len() >= n as usize].len());  
        } else {
            replace(&mut words_with_n_consonants, index, &w);            
        }        
    }    
    words_with_n_consonants.sort();  
    vec!(words_with_n_consonants)
}
// use a simple HashMap as hash table for the frequencies;
// the first pass of the algorithm is to build the hash table and count the consonants in each word.
struct Counter{
    map :HashMap<String,i32>
};
#[derive(Clone)]
impl Counter {    
    fn new() -> Self {
        let mut map = HashMap::new();
        for (word, consonants) in words.iter().map(|w| (w.as_bytes(), w.chars().count())) {                 
            map.insert(String::from(word), consonants);  
        }
        Self{map: map}
    }    
};
#[derive(Clone)]
struct HashSetCounter<T> : HashSet<String>{
    inner: Box<HashSet<String>>
}
impl <S :AsciiExt + Eq + Ord> HashSetCounter<S> for String {
    fn new() -> Self{
        let mut s = String::with

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_select_words() {
        assert_eq!(select_words("Mary had a little lamb", 4), vec!["little"]);
        assert_eq!(
            select_words("Mary had a little lamb", 3),
            vec!["Mary", "lamb"]
        );
        let v_empty: Vec<&str> = vec![];
        assert_eq!(select_words("simple white space", 2), v_empty);
        assert_eq!(select_words("Hello world", 4), vec!["world"]);
        assert_eq!(select_words("Uncle sam", 3), vec!["Uncle"]);
        assert_eq!(select_words("", 4), v_empty);
        assert_eq!(select_words("a b c d e f", 1), vec!["b", "c", "d", "f"]);
    }

}

** Key 3: generation **
    let words = s.splitn(1," ").collect();
        
    let mut words_with_n_consonants = (0..)
        .map(|i| words[i])
        .take(n as usize)
        .collect::<Vec<String>>();
    // replace words with more than 'n' consonants by adding the rest of the string to the end.
    for (w, index) in words_with_n_consonants.iter().zip(words.iter().skip(1)) {
        if w.len() >= n as usize && max(&w[..max(w.chars()).unwrap_or(0), &s[index + 1..]) < n as usize) {
            replace(words_with_n_consonants, index, |_, other| [other, w][w.len() >= n as usize].len());  
        } else {
            replace(&mut words_with_n_consonants, index, &w);            
        }        
    }    
    words_with_n_consonants.sort();  
    vec!(words_with_n_consonants)
}
// use a simple HashMap as hash table for the frequencies;
// the first pass of the algorithm is to build the hash table and count the consonants in each word.
struct Counter{
    map :HashMap<String,i32>
};
#[derive(Clone)]
impl Counter {    
    fn new() -> Self {
        let mut map = HashMap::new();
        for (word, consonants) in words.iter().map(|w| (w.as_bytes(), w.chars().count())) {                 
            map.insert(String::from(word), consonants);  
        }
        Self{map: map}
    }    
};
#[derive(Clone)]
struct HashSetCounter<T> : HashSet<String>{
    inner: Box<HashSet<String>>
}
impl <S :AsciiExt + Eq + Ord> HashSetCounter<S> for String {
    fn new() -> Self{
        let mut s = String::with

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 119 ==========
** Key 0: task_id **
Rust/119
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    You are given a list of two strings, both strings consist of open
    parentheses '(' or close parentheses ')' only.
    Your job is to check if it is possible to concatenate the two strings in
    some order, that the resulting string will be good.
    A string S is considered to be good if and only if all parentheses in S
    are balanced. For example: the string '(())()' is good, while the string
    '())' is not.
    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn match_parens(lst: Vec<&str>) -> &str {

    let (mut p1, mut p2) = lst.split_at(0);
    let tmp = p1.get(..p2.len()).to_string();
    let idx = tmp.chars().position(|c| c.is_whitespace() || c == '&').unwrap_or(p2.len());
    let mut s = String::new();
    s.push_str(&tmp[..idx]);
    p1 += &s;
    s = String::new();
    for _ in 0..p2.len() - (s.len() + 1) {
        s += '&';
    }
    s.push('&');
    let idx = tmp.chars().position(|c| c == '&').unwrap_or(idx);
    std::fmt!(&s[..idx]);
}
fn find_parens<T, U>(
    v: T,
) -> HashMap<TypeId<T>, Vec<TypeId<U>>>
where
    U: AsciiExt + Clone {
    let r = rand::thread_rng().gen::<i64>();
    let (pars1, pars2): (Vec<&str>, Vec<&str>) = if r < 50 {
        (match v.iter() {
            (ref p1 @ ref mut q) => match *p1[..] {
                "(" | ")" | "&" => vec![q],
                _ => vec![]
            },
            (ref p2 @ ref mut r) => match *p2[..] {
                "(" | ")"| "&" => vec![r],
                _ => vec![]
            }},
    } else if r < 90 {
        //println!("{:?}", r);
        (match v.iter() {
            (ref p1 @ ref mut q) => match *p1[..] {
                "(" | ")"| "&" => vec![q],
                _ => vec![]
            },
            (ref p2 @ ref mut r) => match *p2[..] {
                "(" | ")"| "&" => vec![r],

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_match_parens() {
        assert_eq!(match_parens(vec!["()(", ")"]), "Yes");
        assert_eq!(match_parens(vec![")", ")"]), "No");
        assert_eq!(match_parens(vec!["(()(())", "())())"],), "No");
        assert_eq!(match_parens(vec![")())", "(()()("]), "Yes");
        assert_eq!(match_parens(vec!["(())))", "(()())(("]), "Yes");
        assert_eq!(match_parens(vec!["()", "())"],), "No");
        assert_eq!(match_parens(vec!["(()(", "()))()"]), "Yes");
        assert_eq!(match_parens(vec!["((((", "((())"],), "No");
        assert_eq!(match_parens(vec![")(()", "(()("]), "No");
        assert_eq!(match_parens(vec![")(", ")("]), "No");
        assert_eq!(match_parens(vec!["(", ")"]), "Yes");
        assert_eq!(match_parens(vec![")", "("]), "Yes");
    }

}

** Key 3: generation **
    let (mut p1, mut p2) = lst.split_at(0);
    let tmp = p1.get(..p2.len()).to_string();
    let idx = tmp.chars().position(|c| c.is_whitespace() || c == '&').unwrap_or(p2.len());
    let mut s = String::new();
    s.push_str(&tmp[..idx]);
    p1 += &s;
    s = String::new();
    for _ in 0..p2.len() - (s.len() + 1) {
        s += '&';
    }
    s.push('&');
    let idx = tmp.chars().position(|c| c == '&').unwrap_or(idx);
    std::fmt!(&s[..idx]);
}
fn find_parens<T, U>(
    v: T,
) -> HashMap<TypeId<T>, Vec<TypeId<U>>>
where
    U: AsciiExt + Clone {
    let r = rand::thread_rng().gen::<i64>();
    let (pars1, pars2): (Vec<&str>, Vec<&str>) = if r < 50 {
        (match v.iter() {
            (ref p1 @ ref mut q) => match *p1[..] {
                "(" | ")" | "&" => vec![q],
                _ => vec![]
            },
            (ref p2 @ ref mut r) => match *p2[..] {
                "(" | ")"| "&" => vec![r],
                _ => vec![]
            }},
    } else if r < 90 {
        //println!("{:?}", r);
        (match v.iter() {
            (ref p1 @ ref mut q) => match *p1[..] {
                "(" | ")"| "&" => vec![q],
                _ => vec![]
            },
            (ref p2 @ ref mut r) => match *p2[..] {
                "(" | ")"| "&" => vec![r],

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 120 ==========
** Key 0: task_id **
Rust/120
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Given an array arr of integers and a positive integer k, return a sorted list 
    of length k with the maximum k numbers in arr.

    Note:
        1. The length of the array will be in the range of [1, 1000].
        2. The elements in the array will be in the range of [-1000, 1000].
        3. 0 <= k <= len(arr)
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn maximum_120(arr: Vec<i32>, k: i32) -> Vec<i32> {

    let len = arr.len();
    let mut ans = vec![]; // empty array to store the result
    for _ in 0..(k - 1) { // create a hashmap of each digit, and add it into the ans vector
        if let Some((d, _)) = ans.iter_mut().enumerate() { // find the index of the current digit
            match d.cmp(&arr[0]) {
                cmp::Ordering::Equal => (),
                cmp::Ordering::Less => (), // continue from the next digit to the end
                Ordering::Greater => {
                    ans.push(arr[1]); // add the next digit if it is greater than the current one
                    ans.insert(d, arr[0]); // insert the current digit (the biggest one) into the hashmap
                }
            }
        } else { // nothing to compare so just add it and move on to the next index in the vector
            ans.push(arr[1]);
            ans.insert(&d, arr[0])
        }
    }
    ans
}
fn main() -> () {
    let mut random: Rng = rand::thread_rng();
    let n = 20; // the length of the original array will be in this range
    let k = n / max(1, n % 2); // find an even number to divide the array into at least two parts (if not then just keep it as one part)
    println!("{}", k);
    let arr: Vec<i32> = (0..n).collect(); // create a vector of length n with a randomized value for each index
    let ans = maximum_120(arr, k); // create the vector to store the result, this will be empty when we are done
    println!("{}",ans.len()); // display the size of the sorted result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_maximum_120() {
        assert_eq!(maximum_120(vec![-3, -4, 5], 3), vec![-4, -3, 5]);
        assert_eq!(maximum_120(vec![4, -4, 4], 2), vec![4, 4]);
        assert_eq!(maximum_120(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);
        assert_eq!(
            maximum_120(vec![123, -123, 20, 0, 1, 2, -3], 3),
            vec![2, 20, 123]
        );
        assert_eq!(
            maximum_120(vec![-123, 20, 0, 1, 2, -3], 4),
            vec![0, 1, 2, 20]
        );
        assert_eq!(
            maximum_120(vec![5, 15, 0, 3, -13, -8, 0], 7),
            vec![-13, -8, 0, 0, 3, 5, 15]
        );
        assert_eq!(maximum_120(vec![-1, 0, 2, 5, 3, -10], 2), vec![3, 5]);
        assert_eq!(maximum_120(vec![1, 0, 5, -7], 1), vec![5]);
        assert_eq!(maximum_120(vec![4, -4], 2), vec![-4, 4]);
        assert_eq!(maximum_120(vec![-10, 10], 2), vec![-10, 10]);
        assert_eq!(maximum_120(vec![1, 2, 3, -23, 243, -400, 0], 0), vec![]);
    }

}

** Key 3: generation **
    let len = arr.len();
    let mut ans = vec![]; // empty array to store the result
    for _ in 0..(k - 1) { // create a hashmap of each digit, and add it into the ans vector
        if let Some((d, _)) = ans.iter_mut().enumerate() { // find the index of the current digit
            match d.cmp(&arr[0]) {
                cmp::Ordering::Equal => (),
                cmp::Ordering::Less => (), // continue from the next digit to the end
                Ordering::Greater => {
                    ans.push(arr[1]); // add the next digit if it is greater than the current one
                    ans.insert(d, arr[0]); // insert the current digit (the biggest one) into the hashmap
                }
            }
        } else { // nothing to compare so just add it and move on to the next index in the vector
            ans.push(arr[1]);
            ans.insert(&d, arr[0])
        }
    }
    ans
}
fn main() -> () {
    let mut random: Rng = rand::thread_rng();
    let n = 20; // the length of the original array will be in this range
    let k = n / max(1, n % 2); // find an even number to divide the array into at least two parts (if not then just keep it as one part)
    println!("{}", k);
    let arr: Vec<i32> = (0..n).collect(); // create a vector of length n with a randomized value for each index
    let ans = maximum_120(arr, k); // create the vector to store the result, this will be empty when we are done
    println!("{}",ans.len()); // display the size of the sorted result
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 121 ==========
** Key 0: task_id **
Rust/121
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn solutions(lst: Vec<i32>) -> i32 {

    let n = lst.len();
    let mut sum_sums_of_even_positions: HashMap<u32, u64> = 
                            if !n.is_empty() && n > 0 { 
        let mut ret: HashSet<(i32, i32)> = if let Some(solutions) =
        find_positions_with_odd_elements(lst) {
          (solutions - 1).map(|x| (x.1, x)).collect()
        } else {HashSet::new()};
        solutions(&mut ret);        
    // let mut ret: HashSet<(i32, i32)> = (0..n).map(|x| (x, x)).collect();
    for (i, &el) in lst.iter_mut().enumerate() {
      if *el % 2 == 1 && i % 2 == 0 {   // check odd elements are at even positions
        ret.insert(el);              // if so add it to the sums of the first occurrences 
                                       // at even position        
        let (pos, idx) = (i as usize).max(n - pos);     // find max index where solution is located
        replace(&mut sum_sums_of_even_positions, (idx <<< 24 ) | pos , (*el + sum_sums_of_even_positions.get(&idx<<<24).unwrap()));  
      }        
    }
    if let Some(solutions) = find_positions_with_odd_elements(&mut ret) {  // find occurrences with odd elements at even positions
        sum_sums_of_even_positions[solutions - 1]
    } else {0}   // no such solutions found so return a default value
}    
fn find_positions_with_odd_elements(lst: &mut Vec<i32>) -> Option<u64> {   
    let (n, idx) = (idx_of_list(&lst), 1);       // find index of the list 
    for el in lst.iter() {                         // loop over the elements of the list
        if *el % 2

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_solutions() {
        assert_eq!(solutions(vec![5, 8, 7, 1]), 12);
        assert_eq!(solutions(vec![3, 3, 3, 3, 3]), 9);
        assert_eq!(solutions(vec![30, 13, 24, 321]), 0);
        assert_eq!(solutions(vec![5, 9]), 5);
        assert_eq!(solutions(vec![2, 4, 8]), 0);
        assert_eq!(solutions(vec![30, 13, 23, 32]), 23);
        assert_eq!(solutions(vec![3, 13, 2, 9]), 3);
    }

}

** Key 3: generation **
    let n = lst.len();
    let mut sum_sums_of_even_positions: HashMap<u32, u64> = 
                            if !n.is_empty() && n > 0 { 
        let mut ret: HashSet<(i32, i32)> = if let Some(solutions) =
        find_positions_with_odd_elements(lst) {
          (solutions - 1).map(|x| (x.1, x)).collect()
        } else {HashSet::new()};
        solutions(&mut ret);        
    // let mut ret: HashSet<(i32, i32)> = (0..n).map(|x| (x, x)).collect();
    for (i, &el) in lst.iter_mut().enumerate() {
      if *el % 2 == 1 && i % 2 == 0 {   // check odd elements are at even positions
        ret.insert(el);              // if so add it to the sums of the first occurrences 
                                       // at even position        
        let (pos, idx) = (i as usize).max(n - pos);     // find max index where solution is located
        replace(&mut sum_sums_of_even_positions, (idx <<< 24 ) | pos , (*el + sum_sums_of_even_positions.get(&idx<<<24).unwrap()));  
      }        
    }
    if let Some(solutions) = find_positions_with_odd_elements(&mut ret) {  // find occurrences with odd elements at even positions
        sum_sums_of_even_positions[solutions - 1]
    } else {0}   // no such solutions found so return a default value
}    
fn find_positions_with_odd_elements(lst: &mut Vec<i32>) -> Option<u64> {   
    let (n, idx) = (idx_of_list(&lst), 1);       // find index of the list 
    for el in lst.iter() {                         // loop over the elements of the list
        if *el % 2

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 122 ==========
** Key 0: task_id **
Rust/123
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.

    The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined
    as follows: start with any positive integer n. Then each term is obtained from the 
    previous term as follows: if the previous term is even, the next term is one half of 
    the previous term. If the previous term is odd, the next term is 3 times the previous
    term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.

    Note: 
        1. Collatz(1) is [1].
        2. returned list sorted in increasing order.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn get_odd_collatz(n: i32) -> Vec<i32> {

    let mut res = vec![];
    for _ in 1..=33000 {
        if is_even(&res[n - _]) {
            continue;
        } else {
            return replace(res);
        }
    }
    for _ in (n + 1) .. res.len() {
        
        let mut odd = n % 2 == 1 ? &res[0] : &res[res.len() - 1];
        res.sort_unstable();
        if max(odd, n).cmp(&max(3 * &res[n], n)) != 0 {
            break;
        } else {
            odd = replace(odd);
        }
    }
    return replace(res + (2 * res.len()));
}
fn is_even<T:Any>(el:&T) -> bool {
    el.typeid() == TypeId::bool as u16 || el.clone().to_lowercase().is_even();
}
pub fn main() {
    let n = 950;
//    println!("n={}", n);
//    println!("{}",get_odd_collatz(4));
    let (mut res, _):&[i32], HashSet<String> = get_odd_collatz((n - 1) as i32).unzip();
    for s in res.iter() {
        println!("{}",s);
    }
}

#[cfg(test)]
mod tests {
    use super::*;

   #[test]
    fn test_get_odd_collatz() {
        assert_eq!(get_odd_collatz(14), vec![1, 5, 7, 11, 13, 17]);
        assert_eq!(get_odd_collatz(5), vec![1, 5]);
        assert_eq!(get_odd_collatz(12), vec![1, 3, 5]);
        assert_eq!(get_odd_collatz(1), vec![1]);
    }

}

** Key 3: generation **
    let mut res = vec![];
    for _ in 1..=33000 {
        if is_even(&res[n - _]) {
            continue;
        } else {
            return replace(res);
        }
    }
    for _ in (n + 1) .. res.len() {
        
        let mut odd = n % 2 == 1 ? &res[0] : &res[res.len() - 1];
        res.sort_unstable();
        if max(odd, n).cmp(&max(3 * &res[n], n)) != 0 {
            break;
        } else {
            odd = replace(odd);
        }
    }
    return replace(res + (2 * res.len()));
}
fn is_even<T:Any>(el:&T) -> bool {
    el.typeid() == TypeId::bool as u16 || el.clone().to_lowercase().is_even();
}
pub fn main() {
    let n = 950;
//    println!("n={}", n);
//    println!("{}",get_odd_collatz(4));
    let (mut res, _):&[i32], HashSet<String> = get_odd_collatz((n - 1) as i32).unzip();
    for s in res.iter() {
        println!("{}",s);
    }
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 123 ==========
** Key 0: task_id **
Rust/122
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Given a non-empty array of integers arr and an integer k, return
    the sum of the elements with at most two digits from the first k elements of arr.

    Constraints:
        1. 1 <= len(arr) <= 100
        2. 1 <= k <= len(arr)
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn add_elements(arr: Vec<i32>, k: i32) -> i32 {

    let (len, mut max_k) = (0..).count();
    let mut res = 0;
    loop {
        if !max_k.is_empty() && len == max_k.iter().position(max).unwrap_or(0) + k {
            let k = replace(&*max_k, max);
            let (len, max_k) = (1..).count();
            let max_k = &max_k;
            res = max_k.iter().position(|x| x == max).unwrap_or(0) + k
        } else if !max_k.is_empty() && len == max_k.len() {
            break;
        } else {
            let (len, max_k) = (1..).count();
            res += arr[len - 1]; // 
            max_k = &max_k[0]; // 
        }
    }
    return res;
}
pub fn main(argv: Vec<String>) {
    let len: i32 = argv[0].parse::<i32>().unwrap_or(0);
    assert!(len >= 1, "length should be at least 1");
    let max_k: i32 = argv[1].parse::<i32>().unwrap_or(-1 as i32); // -1 mean 
    println!("{}", add_elements(arr, max_k));
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add_elements() {
        assert_eq!(add_elements(vec![1, -2, -3, 41, 57, 76, 87, 88, 99], 3), -4);
        assert_eq!(add_elements(vec![111, 121, 3, 4000, 5, 6], 2), 0);
        assert_eq!(add_elements(vec![11, 21, 3, 90, 5, 6, 7, 8, 9], 4), 125);
        assert_eq!(add_elements(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4), 24);
        assert_eq!(add_elements(vec![1], 1), 1);
    }

}

** Key 3: generation **
    let (len, mut max_k) = (0..).count();
    let mut res = 0;
    loop {
        if !max_k.is_empty() && len == max_k.iter().position(max).unwrap_or(0) + k {
            let k = replace(&*max_k, max);
            let (len, max_k) = (1..).count();
            let max_k = &max_k;
            res = max_k.iter().position(|x| x == max).unwrap_or(0) + k
        } else if !max_k.is_empty() && len == max_k.len() {
            break;
        } else {
            let (len, max_k) = (1..).count();
            res += arr[len - 1]; // 
            max_k = &max_k[0]; // 
        }
    }
    return res;
}
pub fn main(argv: Vec<String>) {
    let len: i32 = argv[0].parse::<i32>().unwrap_or(0);
    assert!(len >= 1, "length should be at least 1");
    let max_k: i32 = argv[1].parse::<i32>().unwrap_or(-1 as i32); // -1 mean 
    println!("{}", add_elements(arr, max_k));
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 124 ==========
** Key 0: task_id **
Rust/124
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
You have to write a function which validates a given date string and
    returns True if the date is valid otherwise False.
    The date is valid if all of the following rules are satisfied:
    1. The date string is not empty.
    2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.
    3. The months should not be less than 1 or higher than 12.
    4. The date should be in the format: mm-dd-yyyy
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn valid_date(date: &str) -> bool {

    let regex = Regex::new("[0-9]+").unwrap();
//let days = regex.captures(&"1234\n")?;
if !regex.is_match(date) || date.len() == 0 { return false } else {
            if let Some(d1) = replace(1.., 1) {
                if let Some(d2) = replace(d1 + 1..31, d1){
                    if let Some(d3) = replace(32..32+30*4-4, d2){
                        if let Some(d4) = replace(32+30*4-4+32..32+365_i8, d3){
                            if let Some(d5) = replace((366..).map(|x| x % 10), d4){
                                if let Some(d6) = replace([365].iter().cloned(), d5) {
//println!("valid: {}", d1 + ":" + d2 + "," + d3 + "," + d4 + "," + d5 + "," +  d6);
                                return max(max(max(0,d1), d2), max(d3, d4)) < 31 || max(max(max(0,d1), d2), d3) < 30 || max(max(max(0,d1), d2), d3) >= 29;
                                } else {return false;}
                            } else { return false ;}
                        } else { return false ;}
                    } else { return false ;}
                } else { return false ;}
            } else { return false ;}
        } else { return false ; }
    } else {return false;}    
}
use std::collections::BTreeMap;
//use regex::Regex;
#[derive(Debug)]
struct ValidDate<'a>{
    date: &'a str,
}
impl<'a> ValidDate<'a> for ValidDate<'a> {
    fn new(date: &'a str) -> Self { ValidateDate(&date) }
}
fn

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_valid_date() {
        assert_eq!(valid_date("03-11-2000"), true);
        assert_eq!(valid_date("15-01-2012"), false);
        assert_eq!(valid_date("04-0-2040"), false);
        assert_eq!(valid_date("06-04-2020"), true);
        assert_eq!(valid_date("01-01-2007"), true);
        assert_eq!(valid_date("03-32-2011"), false);
        assert_eq!(valid_date(""), false);
        assert_eq!(valid_date("04-31-3000"), false);
        assert_eq!(valid_date("06-06-2005"), true);
        assert_eq!(valid_date("21-31-2000"), false);
        assert_eq!(valid_date("04-12-2003"), true);
        assert_eq!(valid_date("04122003"), false);
        assert_eq!(valid_date("20030412"), false);
        assert_eq!(valid_date("2003-04"), false);
        assert_eq!(valid_date("2003-04-12"), false);
        assert_eq!(valid_date("04-2003"), false);
    }

}

** Key 3: generation **
    let regex = Regex::new("[0-9]+").unwrap();
//let days = regex.captures(&"1234\n")?;
if !regex.is_match(date) || date.len() == 0 { return false } else {
            if let Some(d1) = replace(1.., 1) {
                if let Some(d2) = replace(d1 + 1..31, d1){
                    if let Some(d3) = replace(32..32+30*4-4, d2){
                        if let Some(d4) = replace(32+30*4-4+32..32+365_i8, d3){
                            if let Some(d5) = replace((366..).map(|x| x % 10), d4){
                                if let Some(d6) = replace([365].iter().cloned(), d5) {
//println!("valid: {}", d1 + ":" + d2 + "," + d3 + "," + d4 + "," + d5 + "," +  d6);
                                return max(max(max(0,d1), d2), max(d3, d4)) < 31 || max(max(max(0,d1), d2), d3) < 30 || max(max(max(0,d1), d2), d3) >= 29;
                                } else {return false;}
                            } else { return false ;}
                        } else { return false ;}
                    } else { return false ;}
                } else { return false ;}
            } else { return false ;}
        } else { return false ; }
    } else {return false;}    
}
use std::collections::BTreeMap;
//use regex::Regex;
#[derive(Debug)]
struct ValidDate<'a>{
    date: &'a str,
}
impl<'a> ValidDate<'a> for ValidDate<'a> {
    fn new(date: &'a str) -> Self { ValidateDate(&date) }
}
fn

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 125 ==========
** Key 0: task_id **
Rust/125
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you
    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the
    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn split_words(txt: &str) -> Vec<String> {

    let (wc, cnt) = match txt.find("\n").and_then(|pos| pos.unwrap()) {
        None => (vec![], 1), // 1st index of a string is always odd!
        Some(pos) if !pos.is_digit() => panic!("No word in sentence."),
        _=> {
            let mut wc = vec![];
            for i in 2..{
                let cnt = (wc[i-1]).len();
                match txt.find("\n").and_then(|pos| pos.unwrap()) {
                    None => break, // find end of sentence
                    Some(pos) if !pos.is_digit() && (cnt+1).to_string().chars().all(|c| c == '0')=> break, 
                }
            }
            (wc, cnt)
        },
    };    
    wc.iter().map(|s| s.to_owned()).collect()
}
// Returns a tuple of (index, count)! with odd!
fn split_chars(ch: u8) -> Vec<u32>{
    let mut cs = vec![];
    for c in ch..{
        match cs[c].to_string().ascii_uppercase() {
            'A' if (cs[0] == 'A' || cs[1] == 'A')=> panic!("Odd letters are not possible!"), 
            'Z' => (cs.len()).to_u32(),
            _ => return Vec::new(),
        }
    }        
    (cs, cs.iter().enumerate())
}
fn split(txt: &str) -> (String, u64){
    let (wc, cnt) = match txt.find("\n").and_then(|pos| pos.unwrap()) {                     
        None => panic!("No word in sentence."), 
        Some(pos) if !pos.is_digit()=> (txt.to_owned().into(), 1), // 1st index of a string is always odd!        
    };
    let mut cs = wc[0].to_string();
    for ch in wc[

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_split_words() {
        assert_eq!(split_words("Hello world!"), vec!["Hello", "world!"]);
        assert_eq!(split_words("Hello,world!"), vec!["Hello", "world!"]);
        assert_eq!(split_words("Hello world,!"), vec!["Hello", "world,!"]);
        assert_eq!(
            split_words("Hello,Hello,world !"),
            vec!["Hello,Hello,world", "!"]
        );
        assert_eq!(split_words("abcdef"), vec!["3"]);
        assert_eq!(split_words("aaabb"), vec!["2"]);
        assert_eq!(split_words("aaaBb"), vec!["1"]);
        assert_eq!(split_words(""), vec!["0"]);
    }

}

** Key 3: generation **
    let (wc, cnt) = match txt.find("\n").and_then(|pos| pos.unwrap()) {
        None => (vec![], 1), // 1st index of a string is always odd!
        Some(pos) if !pos.is_digit() => panic!("No word in sentence."),
        _=> {
            let mut wc = vec![];
            for i in 2..{
                let cnt = (wc[i-1]).len();
                match txt.find("\n").and_then(|pos| pos.unwrap()) {
                    None => break, // find end of sentence
                    Some(pos) if !pos.is_digit() && (cnt+1).to_string().chars().all(|c| c == '0')=> break, 
                }
            }
            (wc, cnt)
        },
    };    
    wc.iter().map(|s| s.to_owned()).collect()
}
// Returns a tuple of (index, count)! with odd!
fn split_chars(ch: u8) -> Vec<u32>{
    let mut cs = vec![];
    for c in ch..{
        match cs[c].to_string().ascii_uppercase() {
            'A' if (cs[0] == 'A' || cs[1] == 'A')=> panic!("Odd letters are not possible!"), 
            'Z' => (cs.len()).to_u32(),
            _ => return Vec::new(),
        }
    }        
    (cs, cs.iter().enumerate())
}
fn split(txt: &str) -> (String, u64){
    let (wc, cnt) = match txt.find("\n").and_then(|pos| pos.unwrap()) {                     
        None => panic!("No word in sentence."), 
        Some(pos) if !pos.is_digit()=> (txt.to_owned().into(), 1), // 1st index of a string is always odd!        
    };
    let mut cs = wc[0].to_string();
    for ch in wc[

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 126 ==========
** Key 0: task_id **
Rust/126
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Given a list of numbers, return whether or not they are sorted
    in ascending order. If list has more than 1 duplicate of the same
    number, return False. Assume no negative numbers and only integers.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn is_sorted(lst: Vec<i32>) -> bool {

    let (first, last) = (0, lst.len());
    assert!(first < last);
    loop {
        if first == 0 { break }
        else if last - first >= 4 && is_sorted(lst[..last - 1]) {
            return true;
        }
        
        let mid = (first + last) / 2;
        match lst.binary_search(&mid) {
            Ok(idx) => return false,
            Err(_) if idx < lst.len() / 2 => return false,
            Err(mid) => break,
        }
        
        let mid = (first + mid).saturating_sub(1); // Subtract one to get the correct index in the slice
        replace(&lst[..last - 2], lst.iter().map(|x| *x).collect());
        lst[..last].push(mid);
        
    }
}
#[derive(Clone)]
struct Entry<'a> {
    id: u8,
    value: Vec<u32>,
}
impl<'a> Clone for Entry<'a> {
    fn clone(&self) -> Self {
        unsafe{ mem::transmute::<&mut Self, &Self>(&self) }.clone()
    }
}
fn index_for(id: u8) -> u64 {
    0xcafebabe * (id as f64).log10().ceil() as u64
}
#[derive(Clone)]
struct Table<'a> {
    id: u8,
    table: Vec<Entry<'a>>,
}
impl<'a> Clone for Table<'a> {
    fn clone(&self) -> Self { unsafe{ mem::transmute::<&mut Self, &Self>(&self) }.clone() }
}
struct HashSets<T: Hash + Eq > {
    set: HashMap<u8, Vec<T>>,
    id2set: HashMap<u64, u8>,
}
impl<T: Hash + Eq> Clone for HashSets<T> {
    fn clone(&self) -> Self{ self.clone() }

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_is_sorted() {
        assert_eq!(is_sorted(vec![5]), true);
        assert_eq!(is_sorted(vec![1, 2, 3, 4, 5]), true);
        assert_eq!(is_sorted(vec![1, 3, 2, 4, 5]), false);
        assert_eq!(is_sorted(vec![1, 2, 3, 4, 5, 6]), true);
        assert_eq!(is_sorted(vec![1, 2, 3, 4, 5, 6, 7]), true);
        assert_eq!(is_sorted(vec![1, 3, 2, 4, 5, 6, 7]), false);
        assert_eq!(is_sorted(vec![]), true);
        assert_eq!(is_sorted(vec![1]), true);
        assert_eq!(is_sorted(vec![3, 2, 1]), false);
        assert_eq!(is_sorted(vec![1, 2, 2, 2, 3, 4]), false);
        assert_eq!(is_sorted(vec![1, 2, 3, 3, 3, 4]), false);
        assert_eq!(is_sorted(vec![1, 2, 2, 3, 3, 4]), true);
        assert_eq!(is_sorted(vec![1, 2, 3, 4]), true);
    }


}

** Key 3: generation **
    let (first, last) = (0, lst.len());
    assert!(first < last);
    loop {
        if first == 0 { break }
        else if last - first >= 4 && is_sorted(lst[..last - 1]) {
            return true;
        }
        
        let mid = (first + last) / 2;
        match lst.binary_search(&mid) {
            Ok(idx) => return false,
            Err(_) if idx < lst.len() / 2 => return false,
            Err(mid) => break,
        }
        
        let mid = (first + mid).saturating_sub(1); // Subtract one to get the correct index in the slice
        replace(&lst[..last - 2], lst.iter().map(|x| *x).collect());
        lst[..last].push(mid);
        
    }
}
#[derive(Clone)]
struct Entry<'a> {
    id: u8,
    value: Vec<u32>,
}
impl<'a> Clone for Entry<'a> {
    fn clone(&self) -> Self {
        unsafe{ mem::transmute::<&mut Self, &Self>(&self) }.clone()
    }
}
fn index_for(id: u8) -> u64 {
    0xcafebabe * (id as f64).log10().ceil() as u64
}
#[derive(Clone)]
struct Table<'a> {
    id: u8,
    table: Vec<Entry<'a>>,
}
impl<'a> Clone for Table<'a> {
    fn clone(&self) -> Self { unsafe{ mem::transmute::<&mut Self, &Self>(&self) }.clone() }
}
struct HashSets<T: Hash + Eq > {
    set: HashMap<u8, Vec<T>>,
    id2set: HashMap<u64, u8>,
}
impl<T: Hash + Eq> Clone for HashSets<T> {
    fn clone(&self) -> Self{ self.clone() }

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 127 ==========
** Key 0: task_id **
Rust/127
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
You are given two intervals,
    where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).
    The given intervals are closed which means that the interval (start, end)
    includes both start and end.
    For each given interval, it is assumed that its start is less or equal its end.
    Your task is to determine whether the length of intersection of these two 
    intervals is a prime number.
    Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)
    which its length is 1, which not a prime number.
    If the length of the intersection is a prime number, return "YES",
    otherwise, return "NO".
    If the two intervals don't intersect, return "NO".
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn intersection(interval1: Vec<i32>, interval2: Vec<i32>) -> String {

    let (mut min_start, mut max_end) = if &interval2[0] < &interval1[1] {
        (max(&interval1[0], interval2[0]), max(&interval1[1], interval2[1]))
    } else {
        (min(&interval1[0], interval2[0]), min(&interval1[1], interval2[1]))
    };
    loop {
        let min_end = replace(max!(min_start, max!(&interval1[1], max_end)),
            |x| match x {
                i if !i.is_prime() => "NO",
                0...10 => x.to_string(),
                _ => "YES"
            }
        );
        let mut min_start = replace(min!(max!(&interval2[0], max_end), min_end));
        
        if *&min_start < &min_end {
            break;
        }
    }
    String::from("YES")
}
fn main() -> () {
    let (mut start, mut end) = vec![0usize; 1];
    let n = std::rand::thread_rng().gen_range(0,2);
    for index in 0..n {
        if start < &end {
            replace(&start as i32, |x| {
                if !(x%2).is_prime() || x == 6174 {
                    "YES".to_string()
                } else {
                    "NO".to_string()
                }
            });
        }
        start += 1;
    }
    println!("{}", intersection(&vec![0, 2], &vec![]));
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_intersection() {
        assert_eq!(intersection(vec![1, 2], vec![2, 3]), "NO");
        assert_eq!(intersection(vec![-1, 1], vec![0, 4]), "NO");
        assert_eq!(intersection(vec![-3, -1], vec![-5, 5]), "YES");
        assert_eq!(intersection(vec![-2, 2], vec![-4, 0]), "YES");
        assert_eq!(intersection(vec![-11, 2], vec![-1, -1]), "NO");
        assert_eq!(intersection(vec![1, 2], vec![3, 5]), "NO");
        assert_eq!(intersection(vec![1, 2], vec![1, 2]), "NO");
        assert_eq!(intersection(vec![-2, -2], vec![-3, -2]), "NO");
    }

}

** Key 3: generation **
    let (mut min_start, mut max_end) = if &interval2[0] < &interval1[1] {
        (max(&interval1[0], interval2[0]), max(&interval1[1], interval2[1]))
    } else {
        (min(&interval1[0], interval2[0]), min(&interval1[1], interval2[1]))
    };
    loop {
        let min_end = replace(max!(min_start, max!(&interval1[1], max_end)),
            |x| match x {
                i if !i.is_prime() => "NO",
                0...10 => x.to_string(),
                _ => "YES"
            }
        );
        let mut min_start = replace(min!(max!(&interval2[0], max_end), min_end));
        
        if *&min_start < &min_end {
            break;
        }
    }
    String::from("YES")
}
fn main() -> () {
    let (mut start, mut end) = vec![0usize; 1];
    let n = std::rand::thread_rng().gen_range(0,2);
    for index in 0..n {
        if start < &end {
            replace(&start as i32, |x| {
                if !(x%2).is_prime() || x == 6174 {
                    "YES".to_string()
                } else {
                    "NO".to_string()
                }
            });
        }
        start += 1;
    }
    println!("{}", intersection(&vec![0, 2], &vec![]));
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 128 ==========
** Key 0: task_id **
Rust/128
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    You are given an array arr of integers and you need to return
    sum of magnitudes of integers multiplied by product of all signs
    of each number in the array, represented by 1, -1 or 0.
    Note: return None for empty arr.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn prod_signs(arr: Vec<i32>) -> i32 {

    let mut signs = HashSet::new();
    for (index, value) in arr.into_iter().enumerate() {
        if index % 2 == 1 {
            continue;
        } else {
            signs.insert(1);
        }
    }
    signs.len() as i32 * signs.iter().map(|&n| n).sum::<i64>()
}
fn sum_int_magnitudes(arr: Vec<i32>) -> i64 {
    let mut sum = 0;
    for (index, value) in arr.into_iter().enumerate() {
        if index % 2 == 1 {
            continue;
        } else {
            sum += value;
        }
    }
    sum as i64
}
fn main() {
    let size = 30;
    let mut array: Vec<i32> = (0..size).collect();
    for index in 1..size {
        if rand::thread_rng().gen::<f64>() < std::f64::consts::FRACTIONAL_EPSILON as f64 {
            array[index] += rand::rand::<i32>();
        }
    }
    println!("{:?}", array);
    let prod = prod_signs(&array);
    // let size = 30;
    // let arr = &(1..size) * 2.0
    //         .map(|n| n % 2 == 0 as i64)
    //         .map(|&b| b).collect::<Vec<i64>>();
    // assert_eq!(prod, sum_int_magnitudes(arr));
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_prod_signs() {
        assert_eq!(prod_signs(vec![1, 2, 2, -4]), -9);
        assert_eq!(prod_signs(vec![0, 1]), 0);
        assert_eq!(prod_signs(vec![1, 1, 1, 2, 3, -1, 1]), -10);
        assert_eq!(prod_signs(vec![]), -32768);
        assert_eq!(prod_signs(vec![2, 4, 1, 2, -1, -1, 9]), 20);
        assert_eq!(prod_signs(vec![-1, 1, -1, 1]), 4);
        assert_eq!(prod_signs(vec![-1, 1, 1, 1]), -4);
        assert_eq!(prod_signs(vec![-1, 1, 1, 0]), 0);
    }

}

** Key 3: generation **
    let mut signs = HashSet::new();
    for (index, value) in arr.into_iter().enumerate() {
        if index % 2 == 1 {
            continue;
        } else {
            signs.insert(1);
        }
    }
    signs.len() as i32 * signs.iter().map(|&n| n).sum::<i64>()
}
fn sum_int_magnitudes(arr: Vec<i32>) -> i64 {
    let mut sum = 0;
    for (index, value) in arr.into_iter().enumerate() {
        if index % 2 == 1 {
            continue;
        } else {
            sum += value;
        }
    }
    sum as i64
}
fn main() {
    let size = 30;
    let mut array: Vec<i32> = (0..size).collect();
    for index in 1..size {
        if rand::thread_rng().gen::<f64>() < std::f64::consts::FRACTIONAL_EPSILON as f64 {
            array[index] += rand::rand::<i32>();
        }
    }
    println!("{:?}", array);
    let prod = prod_signs(&array);
    // let size = 30;
    // let arr = &(1..size) * 2.0
    //         .map(|n| n % 2 == 0 as i64)
    //         .map(|&b| b).collect::<Vec<i64>>();
    // assert_eq!(prod, sum_int_magnitudes(arr));
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 129 ==========
** Key 0: task_id **
Rust/129
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Given a grid with N rows and N columns (N >= 2) and a positive integer k, 
    each cell of the grid contains a value. Every integer in the range [1, N * N]
    inclusive appears exactly once on the cells of the grid.

    You have to find the minimum path of length k in the grid. You can start
    from any cell, and in each step you can move to any of the neighbor cells,
    in other words, you can go to cells which share an edge with you current
    cell.
    Please note that a path of length k means visiting exactly k cells (not
    necessarily distinct).
    You CANNOT go off the grid.
    A path A (of length k) is considered less than a path B (of length k) if
    after making the ordered lists of the values on the cells that A and B go
    through (let's call them lst_A and lst_B), lst_A is lexicographically less
    than lst_B, in other words, there exist an integer index i (1 <= i <= k)
    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have
    lst_A[j] = lst_B[j].
    It is guaranteed that the answer is unique.
    Return an ordered list of the values on the cells that the minimum path go through.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn min_path(grid: Vec<Vec<i32>>, k: i32) -> Vec<i32> {

    let n = grid.len();
    let m = n * 2 - 1;
    let mut map = HashMap::new(); //map<(u8, u8), (Vec<i32>, u8)>
    for (i, v) in grid.iter().enumerate() {
        if *v >= m || let Some(v) = map.get(&(i as u8, 0)), &v == k && *v < n {map.insert((i as u8, i), (v + 1, *v)));}
    else{if map.contains_key(&(i as u8, 0))
        let v = map.remove(&(i as u8, 0)).unwrap();
        if let Some(u) = map.values().take(1).next() {map.insert((u as u8, u + 2), (v - 1, u));}
    }
    let v = n;
    for i in v..{*map.iter_mut().take_while(|(j, x) | *x > k).for_each(|(x, y)| map.insert((y as u8, y + 1), (x, y)));}
    let mut v = String::new();
    for ((i, x),(y, z)) in map {v.push(if *z == i {format!("{:?}", *x)}else{format!("{:?}{:?}", x, y)}, );}
    if !v.is_empty() && replace(&v[1..], "0" as &str).len() % 2 != 0 {return String::new();}}
    v.parse::<Vec<i32>>().unwrap()
}
struct Grid {n: i32, m: HashMap<u8, u8>};
impl Grid {fn parse(v: &str) -> Result<Self, &'static str>{self.n = n;
    for (&i, &x) in v.split(" ").enumerate() if x == ""{}else{
        let y = x.parse::<u8>();
        
        self.m.insert((*y as u16)*(&i + 1),

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_min_path() {
        assert_eq!(
            min_path(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3),
            vec![1, 2, 1]
        );
        assert_eq!(
            min_path(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1),
            vec![1]
        );
        assert_eq!(
            min_path(
                vec![
                    vec![1, 2, 3, 4],
                    vec![5, 6, 7, 8],
                    vec![9, 10, 11, 12],
                    vec![13, 14, 15, 16]
                ],
                4
            ),
            vec![1, 2, 1, 2]
        );
        assert_eq!(
            min_path(
                vec![
                    vec![6, 4, 13, 10],
                    vec![5, 7, 12, 1],
                    vec![3, 16, 11, 15],
                    vec![8, 14, 9, 2]
                ],
                7
            ),
            vec![1, 10, 1, 10, 1, 10, 1]
        );
        assert_eq!(
            min_path(
                vec![
                    vec![8, 14, 9, 2],
                    vec![6, 4, 13, 15],
                    vec![5, 7, 1, 12],
                    vec![3, 10, 11, 16]
                ],
                5
            ),
            vec![1, 7, 1, 7, 1]
        );
        assert_eq!(
            min_path(
                vec![
                    vec![11, 8, 7, 2],
                    vec![5, 16, 14, 4],
                    vec![9, 3, 15, 6],
                    vec![12, 13, 10, 1]
                ],
                9
            ),
            vec![1, 6, 1, 6, 1, 6, 1, 6, 1]
        );
        assert_eq!(
            min_path(
                vec![
                    vec![12, 13, 10, 1],
                    vec![9, 3, 15, 6],
                    vec![5, 16, 14, 4],
                    vec![11, 8, 7, 2]
                ],
                12
            ),
            vec![1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]
        );
        assert_eq!(
            min_path(vec![vec![2, 7, 4], vec![3, 1, 5], vec![6, 8, 9]], 8),
            vec![1, 3, 1, 3, 1, 3, 1, 3]
        );

        assert_eq!(
            min_path(vec![vec![6, 1, 5], vec![3, 8, 9], vec![2, 7, 4]], 8),
            vec![1, 5, 1, 5, 1, 5, 1, 5]
        );

        assert_eq!(
            min_path(vec![vec![1, 2], vec![3, 4]], 10),
            vec![1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
        );

        assert_eq!(
            min_path(vec![vec![1, 3], vec![3, 2]], 10),
            vec![1, 3, 1, 3, 1, 3, 1, 3, 1, 3]
        );
    }

}

** Key 3: generation **
    let n = grid.len();
    let m = n * 2 - 1;
    let mut map = HashMap::new(); //map<(u8, u8), (Vec<i32>, u8)>
    for (i, v) in grid.iter().enumerate() {
        if *v >= m || let Some(v) = map.get(&(i as u8, 0)), &v == k && *v < n {map.insert((i as u8, i), (v + 1, *v)));}
    else{if map.contains_key(&(i as u8, 0))
        let v = map.remove(&(i as u8, 0)).unwrap();
        if let Some(u) = map.values().take(1).next() {map.insert((u as u8, u + 2), (v - 1, u));}
    }
    let v = n;
    for i in v..{*map.iter_mut().take_while(|(j, x) | *x > k).for_each(|(x, y)| map.insert((y as u8, y + 1), (x, y)));}
    let mut v = String::new();
    for ((i, x),(y, z)) in map {v.push(if *z == i {format!("{:?}", *x)}else{format!("{:?}{:?}", x, y)}, );}
    if !v.is_empty() && replace(&v[1..], "0" as &str).len() % 2 != 0 {return String::new();}}
    v.parse::<Vec<i32>>().unwrap()
}
struct Grid {n: i32, m: HashMap<u8, u8>};
impl Grid {fn parse(v: &str) -> Result<Self, &'static str>{self.n = n;
    for (&i, &x) in v.split(" ").enumerate() if x == ""{}else{
        let y = x.parse::<u8>();
        
        self.m.insert((*y as u16)*(&i + 1),

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 130 ==========
** Key 0: task_id **
Rust/130
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
    the last couple centuries. However, what people don't know is Tribonacci sequence.
    Tribonacci sequence is defined by the recurrence:
    tri(1) = 3
    tri(n) = 1 + n / 2, if n is even.
    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
    For example:
    tri(2) = 1 + (2 / 2) = 2
    tri(4) = 3
    tri(3) = tri(2) + tri(1) + tri(4)
           = 2 + 3 + 3 = 8 
    You are given a non-negative integer number n, you have to a return a list of the 
    first n + 1 numbers of the Tribonacci sequence.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn tri(n: i32) -> Vec<i32> {

    let (m, n) = if n == 0 { (-1 + 1), -1 } else { max(0, n % 2).abs(), n / 2 };
    let (mut r, mut s, m) = if m == 0 && !n.is_even() || (m != 3 && n.is_odd()) {
        (vec![], 1 as i64 + 1, 1)
    } else {
         (0..2).rev().map(|e| tri(n - e)).collect::<Vec<i32>>(), max(0, m), n
    };
    for i in 0..s.len() {
        let mut j = r[i];
        while !replace(&mut j, s[i], r).is_none() && (m % 4 != 0 || (j as u8).wrapping_cmp(&j + 1) >= 0); //(j != tri(j + 1)) {
            r = r.into_iter().map(|k| replace(&mut k, j.clone(), s[i])).collect::<Vec<i32>>();
        }
    }
    drop(m as i64); //drop the remainder for the `tri`
    *r
}
    fn tri(n: i32) -> Vec<i32> {
        let (m, n) = if n == 0 { (-1 + 1), -1 } else { max(0, n % 2).abs(), n / 2 };
        let (mut r, mut s, m) = if m == 0 && !n.is_even() || (m != 3 && n.is_odd()) {
            (vec![], 1 as i64 + 1, 1)
        } else {
             (0..2).rev().map(|e| tri(n - e)).collect::<Vec<i32>>(), max(0, m), n
        };
         for i in 0..s.len() {
            let mut j = r[i];
            while !replace(&mut j, s[i], r).is_none() && (m % 4

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_tri() {
        assert!(tri(3) == vec![1, 3, 2, 8]);
        assert!(tri(4) == vec![1, 3, 2, 8, 3]);
        assert!(tri(5) == vec![1, 3, 2, 8, 3, 15]);
        assert!(tri(6) == vec![1, 3, 2, 8, 3, 15, 4]);
        assert!(tri(7) == vec![1, 3, 2, 8, 3, 15, 4, 24]);
        assert!(tri(8) == vec![1, 3, 2, 8, 3, 15, 4, 24, 5]);
        assert!(tri(9) == vec![1, 3, 2, 8, 3, 15, 4, 24, 5, 35]);
        assert!(
            tri(20)
                == vec![1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11]
        );
        assert!(tri(0) == vec![1]);
        assert!(tri(1) == vec![1, 3]);
    }

}

** Key 3: generation **
    let (m, n) = if n == 0 { (-1 + 1), -1 } else { max(0, n % 2).abs(), n / 2 };
    let (mut r, mut s, m) = if m == 0 && !n.is_even() || (m != 3 && n.is_odd()) {
        (vec![], 1 as i64 + 1, 1)
    } else {
         (0..2).rev().map(|e| tri(n - e)).collect::<Vec<i32>>(), max(0, m), n
    };
    for i in 0..s.len() {
        let mut j = r[i];
        while !replace(&mut j, s[i], r).is_none() && (m % 4 != 0 || (j as u8).wrapping_cmp(&j + 1) >= 0); //(j != tri(j + 1)) {
            r = r.into_iter().map(|k| replace(&mut k, j.clone(), s[i])).collect::<Vec<i32>>();
        }
    }
    drop(m as i64); //drop the remainder for the `tri`
    *r
}
    fn tri(n: i32) -> Vec<i32> {
        let (m, n) = if n == 0 { (-1 + 1), -1 } else { max(0, n % 2).abs(), n / 2 };
        let (mut r, mut s, m) = if m == 0 && !n.is_even() || (m != 3 && n.is_odd()) {
            (vec![], 1 as i64 + 1, 1)
        } else {
             (0..2).rev().map(|e| tri(n - e)).collect::<Vec<i32>>(), max(0, m), n
        };
         for i in 0..s.len() {
            let mut j = r[i];
            while !replace(&mut j, s[i], r).is_none() && (m % 4

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 131 ==========
** Key 0: task_id **
Rust/131
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Given a positive integer n, return the product of the odd digits.
    Return 0 if all digits are even.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn digits(n: i32) -> i32 {

    let n = if n < 0 {
        (abs(i32::MAX as i64) - (-n))
    } else {
        1_i64 <<< n
    };
    n %= 10;
    let n = n + 1;
    let mut even = true;
    for _ in 0..(n.rem_euclid(&2) as usize).saturating_into(0) {
        let r = (n /= 2) % 10;
        if !r.is_even() {
            even = false;
            break;
        }
    }
    if even == true {
        0
    } else {
        n - 1
    }
}
fn odd(n: i32) -> &'static [u8] {
    let mut v = Vec::<u8>::new();
    for r in (1..=n).take(10).step_by(-1) {
        let p = digits(r);
        
        if !r.is_zero() && n % 10 == 0 && v[v.len() - 2] != '0'{
            replace(&mut v, v.last().unwrap(), "0"); // Remove 0 at the end (if exists)
        }    
        
        v.insert(p as i32, p);
    }
    if r == n && !v[v.len() - 1].is_even() {
        &v[..]
    } else {
        // Remove 0 at the end (if exists)
        
        let mut v = Vec::<u8>::new();
        
        for _ in 0..(n %= 10).saturating_into(0) {
            v.insert('0', digits(v.len()));
        }
        &v[..]
    }
}
impl<'a> From<&'a [u8]> for (usize, usize) {
    fn from(data: &'a [u8]) -> Self {
        let mut pos = 0;
        
        while pos <

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_digits() {
        assert_eq!(digits(5), 5);
        assert_eq!(digits(54), 5);
        assert_eq!(digits(120), 1);
        assert_eq!(digits(5014), 5);
        assert_eq!(digits(98765), 315);
        assert_eq!(digits(5576543), 2625);
        assert_eq!(digits(2468), 0);
    }

}

** Key 3: generation **
    let n = if n < 0 {
        (abs(i32::MAX as i64) - (-n))
    } else {
        1_i64 <<< n
    };
    n %= 10;
    let n = n + 1;
    let mut even = true;
    for _ in 0..(n.rem_euclid(&2) as usize).saturating_into(0) {
        let r = (n /= 2) % 10;
        if !r.is_even() {
            even = false;
            break;
        }
    }
    if even == true {
        0
    } else {
        n - 1
    }
}
fn odd(n: i32) -> &'static [u8] {
    let mut v = Vec::<u8>::new();
    for r in (1..=n).take(10).step_by(-1) {
        let p = digits(r);
        
        if !r.is_zero() && n % 10 == 0 && v[v.len() - 2] != '0'{
            replace(&mut v, v.last().unwrap(), "0"); // Remove 0 at the end (if exists)
        }    
        
        v.insert(p as i32, p);
    }
    if r == n && !v[v.len() - 1].is_even() {
        &v[..]
    } else {
        // Remove 0 at the end (if exists)
        
        let mut v = Vec::<u8>::new();
        
        for _ in 0..(n %= 10).saturating_into(0) {
            v.insert('0', digits(v.len()));
        }
        &v[..]
    }
}
impl<'a> From<&'a [u8]> for (usize, usize) {
    fn from(data: &'a [u8]) -> Self {
        let mut pos = 0;
        
        while pos <

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 132 ==========
** Key 0: task_id **
Rust/132
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Create a function that takes a string as input which contains only square brackets.
    The function should return True if and only if there is a valid subsequence of brackets 
    where at least one bracket in the subsequence is nested.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn is_nested(str: &str) -> bool {

    let str_iter = str.chars().peekable();
    if !str.contains(']') || str.len() != 10 {return false;} else {
        println!("{:?}", str);
        for bracket in str.splitn(2, |s| s.chars().all(|c| c == '[')) {
            let mut nested = true;
            let iter: impl Iterator<Item=&'a str> = bracket.iter(); // type : &str
            for ch in bracket.chars() {
                if ch >= '0' && ch <= '9' || ch == '[' || ch == ']' { nested = !nested; } else {
                    return false;
                }
            }
        }
        nesting
    }
}
fn get_all_nested(str: &str) -> (Vec<Vec<bool>>, Vec<Vec<Vec<bool>>>) {
    let n = str.chars().peekable();
    if !n || str.contains("]") || str.len() != 10 || n[8..].iter().map(|s| s.starts_with('[')) == false || str.len() % 2 != 0 {return (Vec::new(), Vec::new());} else {
        let str = str;
        
        let ch: char = n.next(); // &str
        let mut nesting : Vec<Vec<bool>> = vec![vec![]];
        for i in 2..9 {
            if !i.starts_with('[') || (n[i + 1] != ']' && (ch >= '0' && ch <= '9')) {nesting.push(vec![]);} else if let Some(&mut v) = nesting.last_mut() {
            for j in 2..9 {if !j.starts_with('[') || (n[i + j] != ']' && ch >= '0' && ch <= '9')){v.push(false);}} else if let Some(&mut v) = nesting.last_mut() {
            for j in 2..9 {if !j.starts_with('[') || (n[i +

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_is_nested() {
        assert_eq!(is_nested("[[]]"), true);
        assert_eq!(is_nested("[]]]]]]][[[[[]"), false);
        assert_eq!(is_nested("[][]"), false);
        assert_eq!(is_nested("[]"), false);
        assert_eq!(is_nested("[[[[]]]]"), true);
        assert_eq!(is_nested("[]]]]]]]]]]"), false);
        assert_eq!(is_nested("[][][[]]"), true);
        assert_eq!(is_nested("[[]"), false);
        assert_eq!(is_nested("[]]"), false);
        assert_eq!(is_nested("[[]][["), true);
        assert_eq!(is_nested("[[][]]"), true);
        assert_eq!(is_nested(""), false);
        assert_eq!(is_nested("[[[[[[[["), false);
        assert_eq!(is_nested("]]]]]]]]"), false);
    }

}

** Key 3: generation **
    let str_iter = str.chars().peekable();
    if !str.contains(']') || str.len() != 10 {return false;} else {
        println!("{:?}", str);
        for bracket in str.splitn(2, |s| s.chars().all(|c| c == '[')) {
            let mut nested = true;
            let iter: impl Iterator<Item=&'a str> = bracket.iter(); // type : &str
            for ch in bracket.chars() {
                if ch >= '0' && ch <= '9' || ch == '[' || ch == ']' { nested = !nested; } else {
                    return false;
                }
            }
        }
        nesting
    }
}
fn get_all_nested(str: &str) -> (Vec<Vec<bool>>, Vec<Vec<Vec<bool>>>) {
    let n = str.chars().peekable();
    if !n || str.contains("]") || str.len() != 10 || n[8..].iter().map(|s| s.starts_with('[')) == false || str.len() % 2 != 0 {return (Vec::new(), Vec::new());} else {
        let str = str;
        
        let ch: char = n.next(); // &str
        let mut nesting : Vec<Vec<bool>> = vec![vec![]];
        for i in 2..9 {
            if !i.starts_with('[') || (n[i + 1] != ']' && (ch >= '0' && ch <= '9')) {nesting.push(vec![]);} else if let Some(&mut v) = nesting.last_mut() {
            for j in 2..9 {if !j.starts_with('[') || (n[i + j] != ']' && ch >= '0' && ch <= '9')){v.push(false);}} else if let Some(&mut v) = nesting.last_mut() {
            for j in 2..9 {if !j.starts_with('[') || (n[i +

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 133 ==========
** Key 0: task_id **
Rust/133
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
"
    This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a 
    multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not 
    change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. 
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn sum_squares(lst: Vec<f32>) -> i32 {

    let (m, n) = (lst.len(), lst.len()); 
    // get the indices with multiples of 3 and check if their square is in a list
    let mut multiple_of_three : HashSet<i32> = HashSet::new();
    for idx in 0..m {
        let x:&i32 = &lst[idx];
        if x.rem_euclid(3) == 0 {
            multiple_of_three.insert(x);
        }    
    }
    // get the indices with multiples of 4 and check if their cube is in a list
    let mut multiple_of_four : HashSet<i32> = HashSet::new();
    for idx in 0..m {
        let x:&i32 = &lst[idx];
        if x.rem_euclid(4) == 0 && !multiple_of_three.contains(&x) {
            multiple_of_four.insert(x);
        }    
    }
    // get the sum of squares and cubes in a list
    let mut sums: HashMap<i32, Vec<f64>> = HashMap::new();
    for idx in 0..m {
        let x:&i32 = &lst[idx];
        let sx: f64 = replace(&multiple_of_four.get(x).unwrap().to_squared(), |v| AsciiExt::upper(&str::from_utf8(&v).trim_right_chars());
        if x > 0 {
            (*sums.entry(*idx))?[0] += sx;
        }        
    }    
    // get the sum of squares and cubes in an empty list with zero entry
    let mut sums_zero: HashMap<i32, Vec<f64>> = HashMap::new();
    for idx in 0..n {
        let x:&i32 = &lst[idx];
        if x == 0 {
            (*sums_zero.entry(*idx))?[0] += replace(&multiple_of_three.get(x).unwrap().to_squared(), |v|

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sum_squares() {
        assert_eq!(sum_squares(vec![1.0, 2.0, 3.0]), 14);
        assert_eq!(sum_squares(vec![1.0, 2.0, 3.0]), 14);
        assert_eq!(sum_squares(vec![1.0, 3.0, 5.0, 7.0]), 84);
        assert_eq!(sum_squares(vec![1.4, 4.2, 0.0]), 29);
        assert_eq!(sum_squares(vec![-2.4, 1.0, 1.0]), 6);
        assert_eq!(sum_squares(vec![100.0, 1.0, 15.0, 2.0]), 10230);
        assert_eq!(sum_squares(vec![10000.0, 10000.0]), 200000000);
        assert_eq!(sum_squares(vec![-1.4, 4.6, 6.3]), 75);
        assert_eq!(sum_squares(vec![-1.4, 17.9, 18.9, 19.9]), 1086);
        assert_eq!(sum_squares(vec![0.0]), 0);
        assert_eq!(sum_squares(vec![-1.0]), 1);
        assert_eq!(sum_squares(vec![-1.0, 1.0, 0.0]), 2);
    }

}

** Key 3: generation **
    let (m, n) = (lst.len(), lst.len()); 
    // get the indices with multiples of 3 and check if their square is in a list
    let mut multiple_of_three : HashSet<i32> = HashSet::new();
    for idx in 0..m {
        let x:&i32 = &lst[idx];
        if x.rem_euclid(3) == 0 {
            multiple_of_three.insert(x);
        }    
    }
    // get the indices with multiples of 4 and check if their cube is in a list
    let mut multiple_of_four : HashSet<i32> = HashSet::new();
    for idx in 0..m {
        let x:&i32 = &lst[idx];
        if x.rem_euclid(4) == 0 && !multiple_of_three.contains(&x) {
            multiple_of_four.insert(x);
        }    
    }
    // get the sum of squares and cubes in a list
    let mut sums: HashMap<i32, Vec<f64>> = HashMap::new();
    for idx in 0..m {
        let x:&i32 = &lst[idx];
        let sx: f64 = replace(&multiple_of_four.get(x).unwrap().to_squared(), |v| AsciiExt::upper(&str::from_utf8(&v).trim_right_chars());
        if x > 0 {
            (*sums.entry(*idx))?[0] += sx;
        }        
    }    
    // get the sum of squares and cubes in an empty list with zero entry
    let mut sums_zero: HashMap<i32, Vec<f64>> = HashMap::new();
    for idx in 0..n {
        let x:&i32 = &lst[idx];
        if x == 0 {
            (*sums_zero.entry(*idx))?[0] += replace(&multiple_of_three.get(x).unwrap().to_squared(), |v|

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 134 ==========
** Key 0: task_id **
Rust/134
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Create a function that returns True if the last character
    of a given string is an alphabetical character and is not
    a part of a word, and False otherwise.
    Note: "word" is a group of characters separated by space.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn check_if_last_char_is_a_letter(txt: &str) -> bool {

    let s = txt.chars().rev();
    for _ in 0..s.len() - 1 {}
    match s[s.len()-1] {
        'A'...='Z',
        'a'...='z',
        'C'...='L',
        c if let Some(h) = char_to_hashmap(c).and_then(|h| h.iter().rev()) {
            match h.len() { 1 => true, _ => false }
        }
        _ => false
    }
}
pub fn finder_last_letter_is_a_letter(word: &str) -> bool {
    check_if_last_char_is_a_letter(word.to_lowercase())
}
fn char_to_hashmap<'a>(character: 'a) -> Option<&'a str> {
    match character {
        'C', 'L', 'G' => Some("central", "south", "east"),
        'D', 'U', 'F', 'J' => Some("west", "north", "down", "up"),
        c => Some(format!("{}")),
    }.and_then(|h| h.iter().rev())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_check_if_last_char_is_a_letter() {
        assert_eq!(check_if_last_char_is_a_letter("apple"), false);
        assert_eq!(check_if_last_char_is_a_letter("apple pi e"), true);
        assert_eq!(check_if_last_char_is_a_letter("eeeee"), false);
        assert_eq!(check_if_last_char_is_a_letter("A"), true);
        assert_eq!(check_if_last_char_is_a_letter("Pumpkin pie "), false);
        assert_eq!(check_if_last_char_is_a_letter("Pumpkin pie 1"), false);
        assert_eq!(check_if_last_char_is_a_letter(""), false);
        assert_eq!(check_if_last_char_is_a_letter("eeeee e "), false);
        assert_eq!(check_if_last_char_is_a_letter("apple pie"), false);
    }

}

** Key 3: generation **
    let s = txt.chars().rev();
    for _ in 0..s.len() - 1 {}
    match s[s.len()-1] {
        'A'...='Z',
        'a'...='z',
        'C'...='L',
        c if let Some(h) = char_to_hashmap(c).and_then(|h| h.iter().rev()) {
            match h.len() { 1 => true, _ => false }
        }
        _ => false
    }
}
pub fn finder_last_letter_is_a_letter(word: &str) -> bool {
    check_if_last_char_is_a_letter(word.to_lowercase())
}
fn char_to_hashmap<'a>(character: 'a) -> Option<&'a str> {
    match character {
        'C', 'L', 'G' => Some("central", "south", "east"),
        'D', 'U', 'F', 'J' => Some("west", "north", "down", "up"),
        c => Some(format!("{}")),
    }.and_then(|h| h.iter().rev())
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 135 ==========
** Key 0: task_id **
Rust/135
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Create a function which returns the largest index of an element which
    is not greater than or equal to the element immediately preceding it. If
    no such element exists then return -1. The given array will not contain
    duplicate values.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn can_arrange(arr: Vec<i32>) -> i32 {

    let n = arr.len();
    let mut max = -1;  // Max index of the largest element whose value is not greater than the preceding one.
    let mut min = -1; // Min index of the smallest element whose value is not less than the following element.
    let hash: HashMap<i32,u64> = (0..n).map(|&i| {
        (i as i32)
            .hash_mut(&(0..1usize))
            .map(|v| v % u64::max_value())
    }).collect();
    for (i, val) in arr.iter().enumerate() {
        let mut j = i;
        while let Some((k, _)) = hash.get(&j) && max != -1 && *max < *val {
            j += 1;
            match hash.get_mut(&j) {
                None => break,
                Some(_, nv) if nv == val -> min = replace(*nv, i), max = i
            }
        }
    }
    max - i as i32 + 1
}
fn main() {
    let res: Option<Vec<i32>>;
    if let Ok(value) = read_input("arr.txt") -> res {
        println!("{}", can_arrange(*res)?);
    } else {
        eprintln!("Failed to parse input");
    }
}

#[cfg(test)]
mod tests {
    use super::*;


    #[test]
    fn test_can_arrange() {
        assert_eq!(can_arrange(vec![1, 2, 4, 3, 5]), 3);
        assert_eq!(can_arrange(vec![1, 2, 4, 5]), -1);
        assert_eq!(can_arrange(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);
        assert_eq!(can_arrange(vec![4, 8, 5, 7, 3]), 4);
        assert_eq!(can_arrange(vec![]), -1);
    }


}

** Key 3: generation **
    let n = arr.len();
    let mut max = -1;  // Max index of the largest element whose value is not greater than the preceding one.
    let mut min = -1; // Min index of the smallest element whose value is not less than the following element.
    let hash: HashMap<i32,u64> = (0..n).map(|&i| {
        (i as i32)
            .hash_mut(&(0..1usize))
            .map(|v| v % u64::max_value())
    }).collect();
    for (i, val) in arr.iter().enumerate() {
        let mut j = i;
        while let Some((k, _)) = hash.get(&j) && max != -1 && *max < *val {
            j += 1;
            match hash.get_mut(&j) {
                None => break,
                Some(_, nv) if nv == val -> min = replace(*nv, i), max = i
            }
        }
    }
    max - i as i32 + 1
}
fn main() {
    let res: Option<Vec<i32>>;
    if let Ok(value) = read_input("arr.txt") -> res {
        println!("{}", can_arrange(*res)?);
    } else {
        eprintln!("Failed to parse input");
    }
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 136 ==========
** Key 0: task_id **
Rust/136
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Create a function that returns a tuple (a, b), where 'a' is
    the largest of negative integers, and 'b' is the smallest
    of positive integers in a list.
    If there is no negative or positive integers, return them as None.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn largest_smallest_integers(lst: Vec<i32>) -> Vec<i32> {

    let (a, b) = if lst.is_empty() {
        return Some((Some(None), None));
    } else if let Ok(a_int) = max(&lst) {
        let mut b: HashSet<i32> = HashSet::new();
        for _ in 1..9 {
            b.insert((i8::MAX-_).wrapping_mul(u8::MAX)) as i32;
            if (a_int + u8::MAX) % 11 > 0 {
                continue;
            } else if let Ok(b_int) = min(&lst) {
                return Some((Some(a_int), Some(b_int)));
            };
        }
        (None, None)
    } else if let Ok(b_int) = min(&lst) {
        let mut a: HashSet<i32> = HashSet::new();
        for _ in 1..9 {
            a.insert((i8::MIN-u8::MAX).wrapping_mul(i8::MAX)) as i32;
            if (b_int + u8::MAX) % 11 > 0 || b_int < u8::MAX as i32 {
                continue;
            } else if let Ok(a_int) = max(&lst) {
                return Some((Some(a_int), Some(b_int)));
            };
        }
        (None, None)
    } else {
        return Some(($0, $1));
    };
    (&*b.into_iter().find(max).unwrap(), replace(&*a.into_iter().find(min).unwrap()))
}
pub fn gen_md5(v: Vec<i32>) -> String {
   format!("{}", v)
      .parse::<String>()
      .map_or("".to_string(), |s| s.into())
      .to_lowercase()
      .ascii_uppercase()
      .chars().collect::<String>()
      .md5();
}
// #[test]
// fn test_find() {
//     let v = vec![10, 2

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_largest_smallest_integers() {
        assert_eq!(
            largest_smallest_integers(vec![2, 4, 1, 3, 5, 7]),
            vec![0, 1]
        );
        assert_eq!(
            largest_smallest_integers(vec![2, 4, 1, 3, 5, 7, 0]),
            vec![0, 1]
        );
        assert_eq!(
            largest_smallest_integers(vec![1, 3, 2, 4, 5, 6, -2]),
            vec![-2, 1]
        );
        assert_eq!(
            largest_smallest_integers(vec![4, 5, 3, 6, 2, 7, -7]),
            vec![-7, 2]
        );
        assert_eq!(
            largest_smallest_integers(vec![7, 3, 8, 4, 9, 2, 5, -9]),
            vec![-9, 2]
        );
        assert_eq!(largest_smallest_integers(vec![]), vec![0, 0]);
        assert_eq!(largest_smallest_integers(vec![0]), vec![0, 0]);
        assert_eq!(largest_smallest_integers(vec![-1, -3, -5, -6]), vec![-1, 0]);
        assert_eq!(
            largest_smallest_integers(vec![-1, -3, -5, -6, 0]),
            vec![-1, 0]
        );
        assert_eq!(
            largest_smallest_integers(vec![-6, -4, -4, -3, 1]),
            vec![-3, 1]
        );
        assert_eq!(
            largest_smallest_integers(vec![-6, -4, -4, -3, -100, 1]),
            vec![-3, 1]
        );
    }

}

** Key 3: generation **
    let (a, b) = if lst.is_empty() {
        return Some((Some(None), None));
    } else if let Ok(a_int) = max(&lst) {
        let mut b: HashSet<i32> = HashSet::new();
        for _ in 1..9 {
            b.insert((i8::MAX-_).wrapping_mul(u8::MAX)) as i32;
            if (a_int + u8::MAX) % 11 > 0 {
                continue;
            } else if let Ok(b_int) = min(&lst) {
                return Some((Some(a_int), Some(b_int)));
            };
        }
        (None, None)
    } else if let Ok(b_int) = min(&lst) {
        let mut a: HashSet<i32> = HashSet::new();
        for _ in 1..9 {
            a.insert((i8::MIN-u8::MAX).wrapping_mul(i8::MAX)) as i32;
            if (b_int + u8::MAX) % 11 > 0 || b_int < u8::MAX as i32 {
                continue;
            } else if let Ok(a_int) = max(&lst) {
                return Some((Some(a_int), Some(b_int)));
            };
        }
        (None, None)
    } else {
        return Some(($0, $1));
    };
    (&*b.into_iter().find(max).unwrap(), replace(&*a.into_iter().find(min).unwrap()))
}
pub fn gen_md5(v: Vec<i32>) -> String {
   format!("{}", v)
      .parse::<String>()
      .map_or("".to_string(), |s| s.into())
      .to_lowercase()
      .ascii_uppercase()
      .chars().collect::<String>()
      .md5();
}
// #[test]
// fn test_find() {
//     let v = vec![10, 2

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 137 ==========
** Key 0: task_id **
Rust/137
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Create a function that takes integers, floats, or strings representing
    real numbers, and returns the larger variable in its given variable type.
    Return None if the values are equal.
    Note: If a real number is represented as a string, the floating point might be . or ,
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn compare_one<'a>(a:&'a dyn Any, b:&'a dyn Any) -> RtnType<String,f64,i32>{

    let id = TypeId::of::<dyn Any>();
    if typeid:: dynamics::dynamic::is_same(Some(&id), Some(b)) {
        compare_one_generic(a.downcast(), b);
    } else if typeid::dynamics::is_any(Some(&id)) {
        compare_none();
    } else {
        let t = typeid::dyname::get::<dyn Any>();
        let id2 = TypeId::of(t);
        match typeid::dynamics::is_any(Some(&id2)) {
            true => {
                compare_none();
            }
            false =>{
                compare_one_generic(a.downcast(), b)
            }
        }
    }
}
fn compare_one_generic<'t,Id:TypeId + 'static>(a:&'t dyn Any, b: &'t dyn Any){
    let _ = replace(&*a, 0);
    let _ = replace(&*b, 0);
    fn _compare2 (x1:&'a i32 , x2 :&'a i32)->cmp::Result<cmp2::Ordering>{
        if cmp::Ordering::Equal == cmp2::ordering(x1.cmp(&*x2)) { return Ok((cmp::Ordering::Equal)); } else{ 
            let _ = replace(&**&x1, 0);
            let _ = replace(&**&x2, 0);
            if x1 > x2 {return Ok(cmp2::ordering::Greater);}else{if cmp2::ordering::Equal == cmp2::ordering(*x1.cmp(&*x2)) {} else return Ok((cmp::Ordering::Less));}}
    }fn _compare3 (a:&'a i32 , b :&'a i32)->cmp::Result<cmp::Ordering>{  
        if cmp::Ordering::Equal == cmp::ordering(b.cmp(&*a)) { return Ok((cmp::Ordering::Equal)); } else{let _ = replace(&**&b, 0); let _ = replace(&**&a, 

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_compare_one() {
        assert_eq!(compare_one(&1, &2), RtnType::Int(2));
        assert_eq!(compare_one(&1, &2.5), RtnType::Float(2.5));
        assert_eq!(compare_one(&2, &3), RtnType::Int(3));
        assert_eq!(compare_one(&5, &6), RtnType::Int(6));
        assert_eq!(compare_one(&1, &"2.3"), RtnType::String("2.3".to_string()));
        assert_eq!(compare_one(&"5.1", &"6"), RtnType::String("6".to_string()));
        assert_eq!(compare_one(&"1", &"2"), RtnType::String("2".to_string()));
        assert_eq!(compare_one(&"1", &1), RtnType::String("None".to_string()));
    }

}

** Key 3: generation **
    let id = TypeId::of::<dyn Any>();
    if typeid:: dynamics::dynamic::is_same(Some(&id), Some(b)) {
        compare_one_generic(a.downcast(), b);
    } else if typeid::dynamics::is_any(Some(&id)) {
        compare_none();
    } else {
        let t = typeid::dyname::get::<dyn Any>();
        let id2 = TypeId::of(t);
        match typeid::dynamics::is_any(Some(&id2)) {
            true => {
                compare_none();
            }
            false =>{
                compare_one_generic(a.downcast(), b)
            }
        }
    }
}
fn compare_one_generic<'t,Id:TypeId + 'static>(a:&'t dyn Any, b: &'t dyn Any){
    let _ = replace(&*a, 0);
    let _ = replace(&*b, 0);
    fn _compare2 (x1:&'a i32 , x2 :&'a i32)->cmp::Result<cmp2::Ordering>{
        if cmp::Ordering::Equal == cmp2::ordering(x1.cmp(&*x2)) { return Ok((cmp::Ordering::Equal)); } else{ 
            let _ = replace(&**&x1, 0);
            let _ = replace(&**&x2, 0);
            if x1 > x2 {return Ok(cmp2::ordering::Greater);}else{if cmp2::ordering::Equal == cmp2::ordering(*x1.cmp(&*x2)) {} else return Ok((cmp::Ordering::Less));}}
    }fn _compare3 (a:&'a i32 , b :&'a i32)->cmp::Result<cmp::Ordering>{  
        if cmp::Ordering::Equal == cmp::ordering(b.cmp(&*a)) { return Ok((cmp::Ordering::Equal)); } else{let _ = replace(&**&b, 0); let _ = replace(&**&a, 

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 138 ==========
** Key 0: task_id **
Rust/138
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn is_equal_to_sum_even(n: i32) -> bool {

    let even_numbers = get_all_even_numbers(); // Get list of all the even numbers from 0..n-1.
        
    // For each even number in the list, check whether its sum with n is equal to n.
    // If yes for every even number, return true; otherwise false (and don't forget to return early).
    let mut all_sums_of_even_numbers = HashMap::new();
    for element in even_numbers {
        if let Some(sum) = replace(&mut all_sums_of_even_numbers, &element, None) { // Check whether the sum of the even number with n already exists or not. If yes, update it. Otherwise create a new one.
            match sum == n {            
                false => return false,
                true  => (),
            }
        }
    }
    n == all_sums_of_even_numbers[n] // Finally check whether the total sum of every even number with n is equal to n.
}
pub fn get_all_evens(min: i32, max: i32) -> HashSet<i32> {
    (max-min+1).iter() 
        .filter(|&a| a % 2 == 0 && *a < max)
        .collect::<HashSet<_>>(&mut |x| true, HashSet::new()) // Create our own hash set and check whether every even from min to max is contained in it or not.
}
fn get_all_even_numbers() -> Vec<i32> {
    (max-min+1).iter().cloned().collect()
}
pub fn get_all_sums(n: i32, min: i32, max: i32) -> HashMap<i32, i32> { 
    let mut all_even_numbers = get_all_evens(min, max); // Get the list of evens from min to max.
    // For each even number in the list, check whether its sum with n is equal to n. If yes for every even number, update it; otherwise create a new one.
    let mut all_sums = HashMap::new();

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_is_equal_to_sum_even() {
        assert_eq!(is_equal_to_sum_even(4), false);
        assert_eq!(is_equal_to_sum_even(6), false);
        assert_eq!(is_equal_to_sum_even(8), true);
        assert_eq!(is_equal_to_sum_even(10), true);
        assert_eq!(is_equal_to_sum_even(11), false);
        assert_eq!(is_equal_to_sum_even(12), true);
        assert_eq!(is_equal_to_sum_even(13), false);
        assert_eq!(is_equal_to_sum_even(16), true);
    }

}

** Key 3: generation **
    let even_numbers = get_all_even_numbers(); // Get list of all the even numbers from 0..n-1.
        
    // For each even number in the list, check whether its sum with n is equal to n.
    // If yes for every even number, return true; otherwise false (and don't forget to return early).
    let mut all_sums_of_even_numbers = HashMap::new();
    for element in even_numbers {
        if let Some(sum) = replace(&mut all_sums_of_even_numbers, &element, None) { // Check whether the sum of the even number with n already exists or not. If yes, update it. Otherwise create a new one.
            match sum == n {            
                false => return false,
                true  => (),
            }
        }
    }
    n == all_sums_of_even_numbers[n] // Finally check whether the total sum of every even number with n is equal to n.
}
pub fn get_all_evens(min: i32, max: i32) -> HashSet<i32> {
    (max-min+1).iter() 
        .filter(|&a| a % 2 == 0 && *a < max)
        .collect::<HashSet<_>>(&mut |x| true, HashSet::new()) // Create our own hash set and check whether every even from min to max is contained in it or not.
}
fn get_all_even_numbers() -> Vec<i32> {
    (max-min+1).iter().cloned().collect()
}
pub fn get_all_sums(n: i32, min: i32, max: i32) -> HashMap<i32, i32> { 
    let mut all_even_numbers = get_all_evens(min, max); // Get the list of evens from min to max.
    // For each even number in the list, check whether its sum with n is equal to n. If yes for every even number, update it; otherwise create a new one.
    let mut all_sums = HashMap::new();

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 139 ==========
** Key 0: task_id **
Rust/139
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
The Brazilian factorial is defined as:
    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!
    where n > 0

    The function will receive an integer as input and should return the special
    factorial of this integer.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn special_factorial(n: i32) -> i64 {

    let (m, n) = if n > 0 || n <= -1 {
        (true, &n)
    } else if n >= 0 && (n as u8).len() == 1 {
        (false, n.clone())
    } else {
        return 1; // non-integer value not allowed
    };
    match m {
        true => special_factorial(n - 1),
        false => replace(&(n as u8).join().to_string(), " ", "")[..]
            .chars()
            .map(|c| c.to_digit(10).unwrap())
            .fold((0, 1)) { (acc, &x) ) -> (acc * x, acc),
    }
}
static mut ARRAY: [i64; 32] = [0; 32];
/// A special type for storing factorials.
struct SpecialFactorial {
    factorial: i64,
}
impl Ord for SpecialFactorial { fn cmp(&self, rhs: &Self) -> Ordering {
    match self.cmp(&rhs) {
        LOWER => 1, // lower
        EQUAL => 0, // equal
        UPPER => -1, // greater
    }
} }
impl PartialEq for SpecialFactorial { fn eq(&self, rhs: &SpecialFactorial) -> bool {
    self.cmp(rhs).eq(EQ)
}}
/// A simple map to store the factorials of each natural number between 0 and 31.
static mut FACTORIAL_MAP: HashMap<i64, SpecialFactorial> = ([1; 32].iter().cloned().collect());
fn main() {
    std::io::stdout().write_all(b"#include\n\t\"str\";\n" as &[u8]);
    let mut rng: Rng = rand::OsRng; // create a new and different rng instance, see "std::thread.h".
    std::io::stdout().write_all(b"#include\n\t\"factorials.h\";\n" as &

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_special_factorial() {
        assert_eq!(special_factorial(4), 288);
        assert_eq!(special_factorial(5), 34560);
        assert_eq!(special_factorial(7), 125411328000);
        assert_eq!(special_factorial(1), 1);
    }

}

** Key 3: generation **
    let (m, n) = if n > 0 || n <= -1 {
        (true, &n)
    } else if n >= 0 && (n as u8).len() == 1 {
        (false, n.clone())
    } else {
        return 1; // non-integer value not allowed
    };
    match m {
        true => special_factorial(n - 1),
        false => replace(&(n as u8).join().to_string(), " ", "")[..]
            .chars()
            .map(|c| c.to_digit(10).unwrap())
            .fold((0, 1)) { (acc, &x) ) -> (acc * x, acc),
    }
}
static mut ARRAY: [i64; 32] = [0; 32];
/// A special type for storing factorials.
struct SpecialFactorial {
    factorial: i64,
}
impl Ord for SpecialFactorial { fn cmp(&self, rhs: &Self) -> Ordering {
    match self.cmp(&rhs) {
        LOWER => 1, // lower
        EQUAL => 0, // equal
        UPPER => -1, // greater
    }
} }
impl PartialEq for SpecialFactorial { fn eq(&self, rhs: &SpecialFactorial) -> bool {
    self.cmp(rhs).eq(EQ)
}}
/// A simple map to store the factorials of each natural number between 0 and 31.
static mut FACTORIAL_MAP: HashMap<i64, SpecialFactorial> = ([1; 32].iter().cloned().collect());
fn main() {
    std::io::stdout().write_all(b"#include\n\t\"str\";\n" as &[u8]);
    let mut rng: Rng = rand::OsRng; // create a new and different rng instance, see "std::thread.h".
    std::io::stdout().write_all(b"#include\n\t\"factorials.h\";\n" as &

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 140 ==========
** Key 0: task_id **
Rust/140
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Given a string text, replace all spaces in it with underscores, 
    and if a string has more than 2 consecutive spaces, 
    then replace all consecutive spaces with - 
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn fix_spaces(text: &str) -> String {

    let (start, end) = text.split_at(64).unwrap();
    if start == text && end != ""{
        // 2+ consecutive spaces
        replace(&mut text[..end].iter(), |c| match c{
            'a' => "-",
            'b' => "b-",
            'd' => "dd-" ,
            'f' => "ff-",
            _ => "-".to_string()
        })
    }else if text.chars().all(|x| match x{
        'a' => "-",
        'b' => "b-",
        'd' => "dd-" ,
        'f' => "ff-",
        _ => "-".to_string()
    }) {
        // only spaces
        replace(&mut text[0..512].iter(), |c| match c{
            'a' => "-",
            'b' => "b-" ,
            'd' => "dd-" ,
            'f' => "ff-" ,
            _ => "-".to_string()
        })
    }else {
        // normal string
        text.replace(" ", &[])
    }
}
fn main() -> anyhow::Result<()> {
  let mut rng: Rng = rand::thread_rng();
  let hashmap : HashSet<String> = HashMap::new();
  let mut all_texts :Vec<String> = (0..10).map(|i|format!("{}", i)).collect();
  
  // sort the texts in decreasing order of their md5 hashes
  for text in &all_texts {
    println!("{:?}", md5::compute(text));
    if !hashmap.insert(md5::compute(&format!("{}", rng.gen()))){
      continue;
    } else {
        println!("duplicate {}", format!("{}", rng.gen()))
    }
  }
  
   for text in &all_texts{
     println!("before fixing {:?}", text);
   }
   // fix the spaces
   let fixed = all_texts.iter().map(|i|

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_fix_spaces() {
        assert_eq!(fix_spaces("Example"), "Example");
        assert_eq!(fix_spaces("Mudasir Hanif "), "Mudasir_Hanif_");
        assert_eq!(
            fix_spaces("Yellow Yellow  Dirty  Fellow"),
            "Yellow_Yellow__Dirty__Fellow"
        );
        assert_eq!(fix_spaces("Exa   mple"), "Exa-mple");
        assert_eq!(fix_spaces("   Exa 1 2 2 mple"), "-Exa_1_2_2_mple");
    }

}

** Key 3: generation **
    let (start, end) = text.split_at(64).unwrap();
    if start == text && end != ""{
        // 2+ consecutive spaces
        replace(&mut text[..end].iter(), |c| match c{
            'a' => "-",
            'b' => "b-",
            'd' => "dd-" ,
            'f' => "ff-",
            _ => "-".to_string()
        })
    }else if text.chars().all(|x| match x{
        'a' => "-",
        'b' => "b-",
        'd' => "dd-" ,
        'f' => "ff-",
        _ => "-".to_string()
    }) {
        // only spaces
        replace(&mut text[0..512].iter(), |c| match c{
            'a' => "-",
            'b' => "b-" ,
            'd' => "dd-" ,
            'f' => "ff-" ,
            _ => "-".to_string()
        })
    }else {
        // normal string
        text.replace(" ", &[])
    }
}
fn main() -> anyhow::Result<()> {
  let mut rng: Rng = rand::thread_rng();
  let hashmap : HashSet<String> = HashMap::new();
  let mut all_texts :Vec<String> = (0..10).map(|i|format!("{}", i)).collect();
  
  // sort the texts in decreasing order of their md5 hashes
  for text in &all_texts {
    println!("{:?}", md5::compute(text));
    if !hashmap.insert(md5::compute(&format!("{}", rng.gen()))){
      continue;
    } else {
        println!("duplicate {}", format!("{}", rng.gen()))
    }
  }
  
   for text in &all_texts{
     println!("before fixing {:?}", text);
   }
   // fix the spaces
   let fixed = all_texts.iter().map(|i|

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 141 ==========
** Key 0: task_id **
Rust/141
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Create a function which takes a string representing a file's name, and returns
    'Yes' if the the file's name is valid, and returns 'No' otherwise.
    A file's name is considered to be valid if and only if all the following conditions 
    are met:
    - There should not be more than three digits ('0'-'9') in the file's name.
    - The file's name contains exactly one dot '.'
    - The substring before the dot should not be empty, and it starts with a letter from 
    the latin alphapet ('a'-'z' and 'A'-'Z').
    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn file_name_check(file_name: &str) -> &str {

    let valid_names = vec![
        "023649.txt",
        "aaa.exe", 
        "aaa1.dll"
    ];
    for (i, f) in file_name.split('.').enumerate() do {
        match replace(f, idx: i, with: &valid_names[max(0, i) % valid_names.len())) {
            Err(_) => return "", 
            Ok((new_file_name, _)) => return new_file_name
        }
    };
}
pub fn file_name_checker<T: TypeId + Any>(file_name: &str) -> T {
    let valid_names = vec![
        "023649.txt", 
        "aaa.exe"
    ];
    for (i, f) in file_name.split('.').enumerate() do {
        match replace(f, idx: i, with: &valid_names[max(0, i) % valid_names.len())) {
            Err(_) => return "", 
            Ok((new_file_name, _)) => return new_file_name
        };
    }
}
// #include <regex>
fn file_name_checker2<T: TypeId + Any>(file_name: &str) -> T {
    let dot = file_name.find('.').unwrap();
    match (file_name[0..dot.position()], file_name[file_name.chars().count() - 1]) {
        (s, f@'.') => return f, 
        _ => ()
    };
}
impl<T:TypeId + Any> FileNameChecker for String where T: AsciiExt {
    type Type = T;
    fn file_name_check(&self) -> Self::Type {
        let mut rng = rand();
        let mut hashset = HashSet::new().collect();
        
        while !hashset.is_empty() {
            let s: &str = self;
            match (s[0..3], s[s.chars().count() - 1]) {
                (

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_file_name_check() {
        assert_eq!(file_name_check("example.txt"), "Yes");
        assert_eq!(file_name_check("1example.dll"), "No");
        assert_eq!(file_name_check("s1sdf3.asd"), "No");
        assert_eq!(file_name_check("K.dll"), "Yes");
        assert_eq!(file_name_check("MY16FILE3.exe"), "Yes");
        assert_eq!(file_name_check("His12FILE94.exe"), "No");
        assert_eq!(file_name_check("_Y.txt"), "No");
        assert_eq!(file_name_check("?aREYA.exe"), "No");
        assert_eq!(file_name_check("/this_is_valid.dll"), "No");
        assert_eq!(file_name_check("this_is_valid.wow"), "No");
        assert_eq!(file_name_check("this_is_valid.txt"), "Yes");
        assert_eq!(file_name_check("this_is_valid.txtexe"), "No");
        assert_eq!(file_name_check("#this2_i4s_5valid.ten"), "No");
        assert_eq!(file_name_check("@this1_is6_valid.exe"), "No");
        assert_eq!(file_name_check("this_is_12valid.6exe4.txt"), "No");
        assert_eq!(file_name_check("all.exe.txt"), "No");
        assert_eq!(file_name_check("I563_No.exe"), "Yes");
        assert_eq!(file_name_check("Is3youfault.txt"), "Yes");
        assert_eq!(file_name_check("no_one#knows.dll"), "Yes");
        assert_eq!(file_name_check("1I563_Yes3.exe"), "No");
        assert_eq!(file_name_check("I563_Yes3.txtt"), "No");
        assert_eq!(file_name_check("final..txt"), "No");
        assert_eq!(file_name_check("final132"), "No");
        assert_eq!(file_name_check("_f4indsartal132."), "No");
        assert_eq!(file_name_check(".txt"), "No");
        assert_eq!(file_name_check("s."), "No");
    }

}

** Key 3: generation **
    let valid_names = vec![
        "023649.txt",
        "aaa.exe", 
        "aaa1.dll"
    ];
    for (i, f) in file_name.split('.').enumerate() do {
        match replace(f, idx: i, with: &valid_names[max(0, i) % valid_names.len())) {
            Err(_) => return "", 
            Ok((new_file_name, _)) => return new_file_name
        }
    };
}
pub fn file_name_checker<T: TypeId + Any>(file_name: &str) -> T {
    let valid_names = vec![
        "023649.txt", 
        "aaa.exe"
    ];
    for (i, f) in file_name.split('.').enumerate() do {
        match replace(f, idx: i, with: &valid_names[max(0, i) % valid_names.len())) {
            Err(_) => return "", 
            Ok((new_file_name, _)) => return new_file_name
        };
    }
}
// #include <regex>
fn file_name_checker2<T: TypeId + Any>(file_name: &str) -> T {
    let dot = file_name.find('.').unwrap();
    match (file_name[0..dot.position()], file_name[file_name.chars().count() - 1]) {
        (s, f@'.') => return f, 
        _ => ()
    };
}
impl<T:TypeId + Any> FileNameChecker for String where T: AsciiExt {
    type Type = T;
    fn file_name_check(&self) -> Self::Type {
        let mut rng = rand();
        let mut hashset = HashSet::new().collect();
        
        while !hashset.is_empty() {
            let s: &str = self;
            match (s[0..3], s[s.chars().count() - 1]) {
                (

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 142 ==========
** Key 0: task_id **
Rust/142
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
"
    This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a 
    multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not 
    change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. 
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn sum_squares_142(lst: Vec<i32>) -> i32 {

    let (_, hash) = TypeId::of::<Vec<i32>>.hash_id(); 
    // The following line defines a new function that, when invoked with the correct parameter types, will be called at compile-time to determine whether a given integer is a multiple of three or not:
    let three_or_not = type_is_multiple_of(3);
    let set_contains: HashSet<i32> = hash.hash_set("142", |e| e as i32).collect(); 
    // This will perform the following steps:
    // - If index is not a multiple of three, then replace it with its square and return it.
    // - If index is equal to or higher than three, then replace it with its cube and return it.
    // Otherwise, don't touch it and simply add it to the final sum. 
    // Here are some notes on how this approach was chosen by someone else in the room: 
    //  - Above all else we wished to avoid the creation of more temporary variables than necessary. This was a particularly pressing concern given that both the loop and the memoizing function were so similar to this one. The key takeaway here is this: if you're not sure about some aspect of a problem, then it almost always pays to try and solve it in as many different ways as possible before diving into implementation details. 
    // We felt like we had a good handle on how to determine whether or not an integer was a multiple of three prior to the loop. It was only after seeing what other candidates were doing that we considered making this decision at compile-time. 
    //  - Using a hashmap with type-safety guarantees from our compiler was by far the best option in our view here, particularly since we had an integer-type argument to work with. We were also concerned about using any sort of container that would contain references to all the integers within our vector. 
    // However, we still chose to use a hashset instead of a Hashmap for performance reasons (the latter was simply too slow when trying to sum tens upon tens of thousands of them). If your function is going to be called with very large argument sizes it may not make sense to perform this operation at compile-time. 
    // - Our

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sum_squares_142() {
        assert_eq!(sum_squares_142(vec![1, 2, 3]), 6);
        assert_eq!(sum_squares_142(vec![1, 4, 9]), 14);
        assert_eq!(sum_squares_142(vec![]), 0);
        assert_eq!(sum_squares_142(vec![1, 1, 1, 1, 1, 1, 1, 1, 1]), 9);
        assert_eq!(
            sum_squares_142(vec![-1, -1, -1, -1, -1, -1, -1, -1, -1]),
            -3
        );
        assert_eq!(sum_squares_142(vec![0]), 0);
        assert_eq!(sum_squares_142(vec![-1, -5, 2, -1, -5]), -126);
        assert_eq!(sum_squares_142(vec![-56, -99, 1, 0, -2]), 3030);
        assert_eq!(sum_squares_142(vec![-1, 0, 0, 0, 0, 0, 0, 0, -1]), 0);
        assert_eq!(
            sum_squares_142(vec![
                -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37
            ]),
            -14196
        );
        assert_eq!(
            sum_squares_142(vec![
                -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10
            ]),
            -1448
        );
    }

}

** Key 3: generation **
    let (_, hash) = TypeId::of::<Vec<i32>>.hash_id(); 
    // The following line defines a new function that, when invoked with the correct parameter types, will be called at compile-time to determine whether a given integer is a multiple of three or not:
    let three_or_not = type_is_multiple_of(3);
    let set_contains: HashSet<i32> = hash.hash_set("142", |e| e as i32).collect(); 
    // This will perform the following steps:
    // - If index is not a multiple of three, then replace it with its square and return it.
    // - If index is equal to or higher than three, then replace it with its cube and return it.
    // Otherwise, don't touch it and simply add it to the final sum. 
    // Here are some notes on how this approach was chosen by someone else in the room: 
    //  - Above all else we wished to avoid the creation of more temporary variables than necessary. This was a particularly pressing concern given that both the loop and the memoizing function were so similar to this one. The key takeaway here is this: if you're not sure about some aspect of a problem, then it almost always pays to try and solve it in as many different ways as possible before diving into implementation details. 
    // We felt like we had a good handle on how to determine whether or not an integer was a multiple of three prior to the loop. It was only after seeing what other candidates were doing that we considered making this decision at compile-time. 
    //  - Using a hashmap with type-safety guarantees from our compiler was by far the best option in our view here, particularly since we had an integer-type argument to work with. We were also concerned about using any sort of container that would contain references to all the integers within our vector. 
    // However, we still chose to use a hashset instead of a Hashmap for performance reasons (the latter was simply too slow when trying to sum tens upon tens of thousands of them). If your function is going to be called with very large argument sizes it may not make sense to perform this operation at compile-time. 
    // - Our

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 143 ==========
** Key 0: task_id **
Rust/143
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    You are given a string representing a sentence,
    the sentence contains some words separated by a space,
    and you have to return a string that contains the words from the original sentence,
    whose lengths are prime numbers,
    the order of the words in the new string should be the same as the original one.

    Constraints:
        * 1 <= len(sentence) <= 100
        * sentence contains only letters
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn words_in_sentence(sentence: &str) -> String {

    let mut set = HashSet::new();
    for word in sentence.chars().collect_set() {
        if !set.contains(&word as u8) {
            set.insert((*word).clone());
        }
    }
    replace(sentence, &set);
}
fn is_prime(len: usize) -> bool {
    return if len > 40 { false } else { prime::is_prime(len as u8) };
}
#[derive(Clone)]
struct Word<'a> {
    word: &'a str,
    length: u32,
}
impl<'a> From<&str> for Word<'a> {
    fn from(word: &str) -> Self {
        let len = word.len();
        let mut set = HashSet::new();
        if !set.contains(&word[0]) {
            set.insert((*word).clone());
            for len in 2..word.chars().count() + 1 {
                if is_prime(len as u32) && let mut word = &(*word);
                    word != "".into(), word.splitn(len, '').take_one(|w| w.contains(&*&[w].iter())) {
            } else {
            }
        }
        Self { word: &'a str::as_ref(word), length: len }
    }
}
#[derive(Clone)]
enum Prime { No, Yes }
struct Params<'a> {
    sentence: String,
    word_lengths: Vec<u32>,
    word_primes: HashMap<Word<'a>, Prime>,
}
impl<'a> From<&'a str> for Params<'a> {
    fn from(string: &str) -> Self {
        let mut set = HashSet::new();
        if !set.contains(&*string.chars().next() as u8) && *string != "" {
            set.insert((*string).clone());
            for len in 2..string.chars().count() + 1 {
                let mut word = &(*string);
                if is

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_words_in_sentence() {
        assert_eq!(words_in_sentence("This is a test"), "is");
        assert_eq!(words_in_sentence("lets go for swimming"), "go for");
        assert_eq!(
            words_in_sentence("there is no place available here"),
            "there is no place"
        );
        assert_eq!(words_in_sentence("Hi I am Hussein"), "Hi am Hussein");
        assert_eq!(words_in_sentence("go for it"), "go for it");
        assert_eq!(words_in_sentence("here"), "");
        assert_eq!(words_in_sentence("here is"), "is");
    }

}

** Key 3: generation **
    let mut set = HashSet::new();
    for word in sentence.chars().collect_set() {
        if !set.contains(&word as u8) {
            set.insert((*word).clone());
        }
    }
    replace(sentence, &set);
}
fn is_prime(len: usize) -> bool {
    return if len > 40 { false } else { prime::is_prime(len as u8) };
}
#[derive(Clone)]
struct Word<'a> {
    word: &'a str,
    length: u32,
}
impl<'a> From<&str> for Word<'a> {
    fn from(word: &str) -> Self {
        let len = word.len();
        let mut set = HashSet::new();
        if !set.contains(&word[0]) {
            set.insert((*word).clone());
            for len in 2..word.chars().count() + 1 {
                if is_prime(len as u32) && let mut word = &(*word);
                    word != "".into(), word.splitn(len, '').take_one(|w| w.contains(&*&[w].iter())) {
            } else {
            }
        }
        Self { word: &'a str::as_ref(word), length: len }
    }
}
#[derive(Clone)]
enum Prime { No, Yes }
struct Params<'a> {
    sentence: String,
    word_lengths: Vec<u32>,
    word_primes: HashMap<Word<'a>, Prime>,
}
impl<'a> From<&'a str> for Params<'a> {
    fn from(string: &str) -> Self {
        let mut set = HashSet::new();
        if !set.contains(&*string.chars().next() as u8) && *string != "" {
            set.insert((*string).clone());
            for len in 2..string.chars().count() + 1 {
                let mut word = &(*string);
                if is

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 144 ==========
** Key 0: task_id **
Rust/144
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Your task is to implement a function that will simplify the expression
    x * n. The function returns True if x * n evaluates to a whole number and False
    otherwise. Both x and n, are string representation of a fraction, and have the following format,
    <numerator>/<denominator> where both numerator and denominator are positive whole numbers.

    You can assume that x, and n are valid fractions, and do not have zero as denominator.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn simplify(x: &str, n: &str) -> bool {

    let (n_num, n_denom): (i16, i64) = (&n[..], "0".parse().unwrap());
    if max(&n_num, &x[..]) > x.len() as i64 || !(0 <= x.chars().count()) {
        println!("{}: {}", n, x);
        return false;
    }
    let x = x.parse::<f64>().unwrap();
    match n_denom.cmp(&x) {
        cmp::Ordering::Less => false,
        cmp::Ordering::Equal => println!("{}: {}", n, x),
        _ => true,
    }
}
fn test() -> () {
    let mut n: i64 = 0;
    for (x, n) in INPUT_TEST.iter().cloned() {
        if simplify(x, &format!("{}", n)) {
            println!("{}: {}", x, n);
        }
    }
}
#[cfg(test)]
mod tests {
    use test_util::*;
    #[derive(Default)]
    struct NTestCase {
        x: f64
    };
    impl<'x> Test for NTestCase<'x> {
        fn set_up<T, U>(&self, t: &mut T, u: &U) where U : FnMut(&NTestCase<'x>) -> () {}
        fn get_result<R>(&self) -> R where R : Clone + Default + Debug + Eq + PartialEq + Hash + Copy {
            self.x.clone().unwrap()
        }
    }
    #[test]
    fn it_should_be_true_when_n() {
        let test = NTestCase { x: 15f64 };
        assert_eq!(simplify("20", &format!("{}", test.get_result())), true);
        assert_eq!(simplify("33f64", "10f64"), true);
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_simplify() {
        assert_eq!(simplify("1/5", "5/1"), true);
        assert_eq!(simplify("1/6", "2/1"), false);
        assert_eq!(simplify("5/1", "3/1"), true);
        assert_eq!(simplify("7/10", "10/2"), false);
        assert_eq!(simplify("2/10", "50/10"), true);
        assert_eq!(simplify("7/2", "4/2"), true);
        assert_eq!(simplify("11/6", "6/1"), true);
        assert_eq!(simplify("2/3", "5/2"), false);
        assert_eq!(simplify("5/2", "3/5"), false);
        assert_eq!(simplify("2/4", "8/4"), true);
        assert_eq!(simplify("2/4", "4/2"), true);
        assert_eq!(simplify("1/5", "5/1"), true);
        assert_eq!(simplify("1/5", "1/5"), false);
    }

}

** Key 3: generation **
    let (n_num, n_denom): (i16, i64) = (&n[..], "0".parse().unwrap());
    if max(&n_num, &x[..]) > x.len() as i64 || !(0 <= x.chars().count()) {
        println!("{}: {}", n, x);
        return false;
    }
    let x = x.parse::<f64>().unwrap();
    match n_denom.cmp(&x) {
        cmp::Ordering::Less => false,
        cmp::Ordering::Equal => println!("{}: {}", n, x),
        _ => true,
    }
}
fn test() -> () {
    let mut n: i64 = 0;
    for (x, n) in INPUT_TEST.iter().cloned() {
        if simplify(x, &format!("{}", n)) {
            println!("{}: {}", x, n);
        }
    }
}
#[cfg(test)]
mod tests {
    use test_util::*;
    #[derive(Default)]
    struct NTestCase {
        x: f64
    };
    impl<'x> Test for NTestCase<'x> {
        fn set_up<T, U>(&self, t: &mut T, u: &U) where U : FnMut(&NTestCase<'x>) -> () {}
        fn get_result<R>(&self) -> R where R : Clone + Default + Debug + Eq + PartialEq + Hash + Copy {
            self.x.clone().unwrap()
        }
    }
    #[test]
    fn it_should_be_true_when_n() {
        let test = NTestCase { x: 15f64 };
        assert_eq!(simplify("20", &format!("{}", test.get_result())), true);
        assert_eq!(simplify("33f64", "10f64"), true);
    }
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 145 ==========
** Key 0: task_id **
Rust/145
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Write a function which sorts the given list of integers
    in ascending order according to the sum of their digits.
    Note: if there are several items with similar sum of their digits,
    order them based on their index in original list.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn order_by_points(arr: Vec<i32>) -> Vec<i32> {

    let (_, points) = arr.iter().enumerate();
    order_by_points_with_predecessors(&arr, points).to_vec()
}
fn order_by_points_with_predecessors(arr: Vec<i32>, points: Vec<usize>) -> Vec<i32> {
    let mut prev_index = None;
    let points_hash_map = HashMap::new();
    for (idx, point) in &points[..] {
        if !points_hash_map.contains_key(&idx) {
            points_hash_map.insert(prev_index = Some(idx), *point);
        } else {
            let (prev_i32, p1) = points_hash_map.iter().position(|&(prev_idx, _)| prev_idx == &prev_index).unwrap();
            if let Ok((prev_prev_i32, _) = arr.get_unchecked(&p1) {
                *point - replace(prev_prev_i32, 0).min(prev_prev_i32).max(-1) as i32 + prev_i32
            } else {
                0
            });
        }
    }
    let mut it = points_hash_map.into_iter();
    it.collect::<Vec<(_, i32, _)>>().to_vec()
}
fn order_by_points(arr: Vec<i32>) -> Vec<usize> {
    let mut prev_index = None;
    let points_hash_map = if arr.len() % 4 != 0 {
        panic!();
    } else {
        let points = arr.iter().enumerate();
        let points_hash_map = HashMap::new();
        for (idx, point) in &points[..] {
            if !points_hash_map.contains_key(&idx) {
                points_hash_map.insert(prev_index = Some(idx), *point);
            } else {
                let (prev_i32, p1) = points_hash_map.iter().position(|&(prev_

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_order_by_points() {
        assert_eq!(
            order_by_points(vec![1, 11, -1, -11, -12]),
            vec![-1, -11, 1, -12, 11]
        );
        assert_eq!(
            order_by_points(vec![
                1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46
            ]),
            vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]
        );
        assert_eq!(order_by_points(vec![]), vec![]);
        assert_eq!(
            order_by_points(vec![1, -11, -32, 43, 54, -98, 2, -3]),
            vec![-3, -32, -98, -11, 1, 2, 43, 54]
        );
        assert_eq!(
            order_by_points(vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]),
            vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]
        );
        assert_eq!(
            order_by_points(vec![0, 6, 6, -76, -21, 23, 4]),
            vec![-76, -21, 0, 4, 23, 6, 6]
        );
    }

}

** Key 3: generation **
    let (_, points) = arr.iter().enumerate();
    order_by_points_with_predecessors(&arr, points).to_vec()
}
fn order_by_points_with_predecessors(arr: Vec<i32>, points: Vec<usize>) -> Vec<i32> {
    let mut prev_index = None;
    let points_hash_map = HashMap::new();
    for (idx, point) in &points[..] {
        if !points_hash_map.contains_key(&idx) {
            points_hash_map.insert(prev_index = Some(idx), *point);
        } else {
            let (prev_i32, p1) = points_hash_map.iter().position(|&(prev_idx, _)| prev_idx == &prev_index).unwrap();
            if let Ok((prev_prev_i32, _) = arr.get_unchecked(&p1) {
                *point - replace(prev_prev_i32, 0).min(prev_prev_i32).max(-1) as i32 + prev_i32
            } else {
                0
            });
        }
    }
    let mut it = points_hash_map.into_iter();
    it.collect::<Vec<(_, i32, _)>>().to_vec()
}
fn order_by_points(arr: Vec<i32>) -> Vec<usize> {
    let mut prev_index = None;
    let points_hash_map = if arr.len() % 4 != 0 {
        panic!();
    } else {
        let points = arr.iter().enumerate();
        let points_hash_map = HashMap::new();
        for (idx, point) in &points[..] {
            if !points_hash_map.contains_key(&idx) {
                points_hash_map.insert(prev_index = Some(idx), *point);
            } else {
                let (prev_i32, p1) = points_hash_map.iter().position(|&(prev_

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 146 ==========
** Key 0: task_id **
Rust/146
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Write a function that takes an array of numbers as input and returns 
    the number of elements in the array that are greater than 10 and both 
    first and last digits of a number are odd (1, 3, 5, 7, 9).
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn special_filter(nums: Vec<i32>) -> i32 {

    let (min, max) = nums.iter().map(|x| (0, &TypeId::of::<i32>()))
                           .zip(nums[..])
                           .filter_map(|(a, b)| a == Some(b)).collect();
    println!("{} {}", min.min(), max.max());
    if (special_filter(min) < 0 || special_filter(max) > nums.len()) {
        return -1;
    } else {
        print("{}", special_filter(nums));
    }
}
fn special_search<T>(a: T, b: &Vec<T>) -> bool where T: Eq + PartialEq + Clone {
    let (min, max) = a.iter().map(|x| (0, &TypeId::of(&format!(".{}", x)))
                           .zip(b[..])
                           .filter_map(|(a, b)| a == Some(b))
                           .collect();
    println!("{} {} {}", min.min(), max.max(), special_search(*a, b));
    return true;
}
fn special_search(a: i32) -> bool {
    let (min, max) = a.iter().map(|x| (0, &TypeId::of(&format!(".{}", x)))
                               .zip(1..)
                               .filter_map(|(a, b)| a == Some(b))
                               .collect();
    println!("{} {} {} ", min.min(), max.max(), special_search(*a));
    return true;
}
fn main() {
    println!("I am the filter! You can use me in many other ways!");
//    let nums: Vec<i32> = (0..10).map(|x| x as i32).collect();
//    special_filter(nums);
//    println!("{:?}", nums[6]);
//    println!("len = {:?}", nums.len());
    /*
    let nums: Vec<i32> = rand::thread_rng().gen_range(-10, 10).

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_special_filter() {
        assert_eq!(special_filter(vec![5, -2, 1, -5]), 0);
        assert_eq!(special_filter(vec![15, -73, 14, -15]), 1);
        assert_eq!(special_filter(vec![33, -2, -3, 45, 21, 109]), 2);
        assert_eq!(special_filter(vec![43, -12, 93, 125, 121, 109]), 4);
        assert_eq!(special_filter(vec![71, -2, -33, 75, 21, 19]), 3);
        assert_eq!(special_filter(vec![1]), 0);
        assert_eq!(special_filter(vec![]), 0);
    }

}

** Key 3: generation **
    let (min, max) = nums.iter().map(|x| (0, &TypeId::of::<i32>()))
                           .zip(nums[..])
                           .filter_map(|(a, b)| a == Some(b)).collect();
    println!("{} {}", min.min(), max.max());
    if (special_filter(min) < 0 || special_filter(max) > nums.len()) {
        return -1;
    } else {
        print("{}", special_filter(nums));
    }
}
fn special_search<T>(a: T, b: &Vec<T>) -> bool where T: Eq + PartialEq + Clone {
    let (min, max) = a.iter().map(|x| (0, &TypeId::of(&format!(".{}", x)))
                           .zip(b[..])
                           .filter_map(|(a, b)| a == Some(b))
                           .collect();
    println!("{} {} {}", min.min(), max.max(), special_search(*a, b));
    return true;
}
fn special_search(a: i32) -> bool {
    let (min, max) = a.iter().map(|x| (0, &TypeId::of(&format!(".{}", x)))
                               .zip(1..)
                               .filter_map(|(a, b)| a == Some(b))
                               .collect();
    println!("{} {} {} ", min.min(), max.max(), special_search(*a));
    return true;
}
fn main() {
    println!("I am the filter! You can use me in many other ways!");
//    let nums: Vec<i32> = (0..10).map(|x| x as i32).collect();
//    special_filter(nums);
//    println!("{:?}", nums[6]);
//    println!("len = {:?}", nums.len());
    /*
    let nums: Vec<i32> = rand::thread_rng().gen_range(-10, 10).

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 147 ==========
** Key 0: task_id **
Rust/147
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    You are given a positive integer n. You have to create an integer array a of length n.
        For each i (1  i  n), the value of a[i] = i * i - i + 1.
        Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
    and a[i] + a[j] + a[k] is a multiple of 3.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn get_matrix_triples(n: i32) -> i32 {

    let (mut a, b): (i32[], i64);
    let mut triples: HashSet<(i32[], i32[], i32)> = HashSet::new();
    let n = n as i32;
    let mut counter = 1;
    a = (0..n).take_while(|&x| x != 0).collect::<Vec<i32>>().into_iter().rev();
    b = &a[..].to_vec();
    replace(&mut a, n as i32, counter);
    triples.insert((a, b));
    let mut t: Vec<(i32[], i32[], i32)> = vec![(0, 1, max(triples.len(), 1))];
    for (j,k) in triples {
        if j != 0 && k > 0{
            t.push((j-1, k - 1,j * k + j));
        }else if k < j{
            t.push_back((j-1 , k+1, (k-1)*(j-1)));    
        }
    }
    triples = t;
    assert!(triples.len() == 3);    
    let mut counter = 1 + max(0, triples.len());
    for i in 1..n {
        if a[i] % 3 != 0{
            counter += triples.remove(&(a[i], b[i]))?;
            replace(&mut &mut a[i-1], i as i32, (counter - 1));    
        }else{
            counter -= triples.remove(&(a[i], b[i]))?;        
            if *counter < i {
                assert_eq!((&a[*counter] as u8).to_string(), &format!("{}", a[*counter]));
                replace(&mut &mut a[*counter], counter, i as i32);    
            }
        }
    }
    *counter += triples.remove(&(a[0], b[n]))?;        
    assert_eq!((&a

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_get_matrix_triples() {
        assert_eq!(get_matrix_triples(5), 1);
        assert_eq!(get_matrix_triples(6), 4);
        assert_eq!(get_matrix_triples(10), 36);
        assert_eq!(get_matrix_triples(100), 53361);
    }

}

** Key 3: generation **
    let (mut a, b): (i32[], i64);
    let mut triples: HashSet<(i32[], i32[], i32)> = HashSet::new();
    let n = n as i32;
    let mut counter = 1;
    a = (0..n).take_while(|&x| x != 0).collect::<Vec<i32>>().into_iter().rev();
    b = &a[..].to_vec();
    replace(&mut a, n as i32, counter);
    triples.insert((a, b));
    let mut t: Vec<(i32[], i32[], i32)> = vec![(0, 1, max(triples.len(), 1))];
    for (j,k) in triples {
        if j != 0 && k > 0{
            t.push((j-1, k - 1,j * k + j));
        }else if k < j{
            t.push_back((j-1 , k+1, (k-1)*(j-1)));    
        }
    }
    triples = t;
    assert!(triples.len() == 3);    
    let mut counter = 1 + max(0, triples.len());
    for i in 1..n {
        if a[i] % 3 != 0{
            counter += triples.remove(&(a[i], b[i]))?;
            replace(&mut &mut a[i-1], i as i32, (counter - 1));    
        }else{
            counter -= triples.remove(&(a[i], b[i]))?;        
            if *counter < i {
                assert_eq!((&a[*counter] as u8).to_string(), &format!("{}", a[*counter]));
                replace(&mut &mut a[*counter], counter, i as i32);    
            }
        }
    }
    *counter += triples.remove(&(a[0], b[n]))?;        
    assert_eq!((&a

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 148 ==========
** Key 0: task_id **
Rust/148
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    There are eight planets in our solar system: the closerst to the Sun 
    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, 
    Uranus, Neptune.
    Write a function that takes two planet names as strings planet1 and planet2. 
    The function should return a tuple containing all planets whose orbits are 
    located between the orbit of planet1 and the orbit of planet2, sorted by 
    the proximity to the sun. 
    The function should return an empty tuple if planet1 or planet2
    are not correct planet names. 
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn bf(planet1: &str, planet2: &str) -> Vec<String> {

    let re = Regex::new("^[A-Za-z]*[0-9](.[0-9])?$").unwrap();
    let rng : Rng = rand::thread_rng();
    let mut planet1_distance: Vec<f64> = vec![];
    let max_distance = 0.5; // Distance of the Sun from Mercury, in AU
    let (radius1, radius2) = (
        (max(planet2.chars().map(|c| c.to_lowercase()).rev(), 3),
            max((planet1.chars().map(|c| c.to_lowercase()).rev()), 0))
    ).into();
    for _ in 0..10 {
        let planet = rng.gen::<String>().map(str::parse).unwrap_or("".to_string());
        if match planet {
            "mercury", "venus" => true,
            "earth", "mars" => true,
            "jupiter", "saturn", "uranus"|"neptune" => true
            _ => false 
        } {
                planet1_distance.push( planet.parse::<f64>().unwrap() );
            } else if match planet {
                   "mercury", "venus" => max(planet1_distance[..], 0) > max_distance,
                    "earth", "mars" | _ => true,
                    _ => false 
                } {
            break;
        } else if match planet{
            "mercury", "venus", "uranus", "neptune"|"saturn" | "pluto" => max(planet2.parse::<f64>().unwrap(), 0) > radius1,
                   "earth", "mars" => true,
            _ => false 
        } {
            break;
        }
    }
    planet1_distance.sort_by(|a, b| max(max::max(a, b), 0)); // Distance to the Sun
    let mut distance = (planet1_distance

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_bf() {
        assert_eq!(bf("Jupiter", "Neptune"), vec!["Saturn", "Uranus"]);
        assert_eq!(bf("Earth", "Mercury"), vec!["Venus"]);
        assert_eq!(
            bf("Mercury", "Uranus"),
            vec!["Venus", "Earth", "Mars", "Jupiter", "Saturn"]
        );
        assert_eq!(
            bf("Neptune", "Venus"),
            vec!["Earth", "Mars", "Jupiter", "Saturn", "Uranus"]
        );
        let v_empty: Vec<&str> = vec![];
        assert_eq!(bf("Earth", "Earth"), v_empty);
        assert_eq!(bf("Mars", "Earth"), v_empty);
        assert_eq!(bf("Jupiter", "Makemake"), v_empty);
    }

}

** Key 3: generation **
    let re = Regex::new("^[A-Za-z]*[0-9](.[0-9])?$").unwrap();
    let rng : Rng = rand::thread_rng();
    let mut planet1_distance: Vec<f64> = vec![];
    let max_distance = 0.5; // Distance of the Sun from Mercury, in AU
    let (radius1, radius2) = (
        (max(planet2.chars().map(|c| c.to_lowercase()).rev(), 3),
            max((planet1.chars().map(|c| c.to_lowercase()).rev()), 0))
    ).into();
    for _ in 0..10 {
        let planet = rng.gen::<String>().map(str::parse).unwrap_or("".to_string());
        if match planet {
            "mercury", "venus" => true,
            "earth", "mars" => true,
            "jupiter", "saturn", "uranus"|"neptune" => true
            _ => false 
        } {
                planet1_distance.push( planet.parse::<f64>().unwrap() );
            } else if match planet {
                   "mercury", "venus" => max(planet1_distance[..], 0) > max_distance,
                    "earth", "mars" | _ => true,
                    _ => false 
                } {
            break;
        } else if match planet{
            "mercury", "venus", "uranus", "neptune"|"saturn" | "pluto" => max(planet2.parse::<f64>().unwrap(), 0) > radius1,
                   "earth", "mars" => true,
            _ => false 
        } {
            break;
        }
    }
    planet1_distance.sort_by(|a, b| max(max::max(a, b), 0)); // Distance to the Sun
    let mut distance = (planet1_distance

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 149 ==========
** Key 0: task_id **
Rust/149
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Write a function that accepts a list of strings as a parameter,
    deletes the strings that have odd lengths from it,
    and returns the resulted list with a sorted order,
    The list is always a list of strings and never an array of numbers,
    and it may contain duplicates.
    The order of the list should be ascending by length of each word, and you
    should return the list sorted by that rule.
    If two words have the same length, sort the list alphabetically.
    The function should return a list of strings in sorted order.
    You may assume that all words will have the same length.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn sorted_list_sum(lst: Vec<&str>) -> Vec<&str> {

    let mut r = 0;
    let rset = lst.iter().map(|s| s).collect::<HashSet<String>>();
    fn get_hash(&s: &str) -> u64 { md5(s.as_bytes()).to_string().chars().rev()[..10].try_into().unwrap() } //get the hash of each string
    let mut hsh = HashMap::new(); //init a new hashmap
    for s in rset {
        if !hsh.contains_key(&s) {
            replace(r, hsh.len(), |k, v| {
                match k.get() {
                    0 => Some(v),
                    i => None
                }
            });
            r += 1;
        if let HashSet::IntoIter(it) = rset.into_iter() {
            for i in it { //add all strings to the hashmap
                match i {
                    0 => {},
                    s => hsh.insert(s, ()),
                };
            }
        }
    }
    r -= 1; //reset r to zero to return the first element in next iteration
    let mut result = Vec::new();
    for i in hsh { //iterate over each element
        match i {
            0 => result.push(hsh[0]),
            s => result.push(s),
        }
    };
    result
}
fn sorted_list(lst: Vec<&str>) -> Vec<&str> {
    let mut r = 0;
    let rset = lst.iter().map(|s| s).collect::<HashSet<String>>();
    let mut rsh = HashMap::new(); //init a new hashmap and reset r to zero so that we could sort the list in each iteration
    for i in rset {
        match rsh.remove(&i) {
            0 => {},
            s => rsh.insert((r,s)),
        }
    };
    let result = sorted_list_sum(hsh.values()); //get the first element and store it in a variable to be returned later
    println!("{:?}", rsh[0

#[cfg(test)]
mod tests {
    use super::*;

   #[test]
    fn test_sorted_list_sum() {
        assert_eq!(sorted_list_sum(vec!["aa", "a", "aaa"]), vec!["aa"]);
        assert_eq!(
            sorted_list_sum(vec!["school", "AI", "asdf", "b"]),
            vec!["AI", "asdf", "school"]
        );
        let v_empty: Vec<&str> = vec![];
        assert_eq!(sorted_list_sum(vec!["d", "b", "c", "a"]), v_empty);
        assert_eq!(
            sorted_list_sum(vec!["d", "dcba", "abcd", "a"]),
            vec!["abcd", "dcba"]
        );
        assert_eq!(
            sorted_list_sum(vec!["AI", "ai", "au"]),
            vec!["AI", "ai", "au"]
        );
        assert_eq!(sorted_list_sum(vec!["a", "b", "b", "c", "c", "a"]), v_empty);
        assert_eq!(
            sorted_list_sum(vec!["aaaa", "bbbb", "dd", "cc"]),
            vec!["cc", "dd", "aaaa", "bbbb"]
        );
    }

}

** Key 3: generation **
    let mut r = 0;
    let rset = lst.iter().map(|s| s).collect::<HashSet<String>>();
    fn get_hash(&s: &str) -> u64 { md5(s.as_bytes()).to_string().chars().rev()[..10].try_into().unwrap() } //get the hash of each string
    let mut hsh = HashMap::new(); //init a new hashmap
    for s in rset {
        if !hsh.contains_key(&s) {
            replace(r, hsh.len(), |k, v| {
                match k.get() {
                    0 => Some(v),
                    i => None
                }
            });
            r += 1;
        if let HashSet::IntoIter(it) = rset.into_iter() {
            for i in it { //add all strings to the hashmap
                match i {
                    0 => {},
                    s => hsh.insert(s, ()),
                };
            }
        }
    }
    r -= 1; //reset r to zero to return the first element in next iteration
    let mut result = Vec::new();
    for i in hsh { //iterate over each element
        match i {
            0 => result.push(hsh[0]),
            s => result.push(s),
        }
    };
    result
}
fn sorted_list(lst: Vec<&str>) -> Vec<&str> {
    let mut r = 0;
    let rset = lst.iter().map(|s| s).collect::<HashSet<String>>();
    let mut rsh = HashMap::new(); //init a new hashmap and reset r to zero so that we could sort the list in each iteration
    for i in rset {
        match rsh.remove(&i) {
            0 => {},
            s => rsh.insert((r,s)),
        }
    };
    let result = sorted_list_sum(hsh.values()); //get the first element and store it in a variable to be returned later
    println!("{:?}", rsh[0

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 150 ==========
** Key 0: task_id **
Rust/150
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
A simple program which should return the value of x if n is 
    a prime number and should return the value of y otherwise.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn x_or_y(n: i32, x: i32, y: i32) -> i32 {

    if n % 2 == 0 {
        println!("prime number - {}", n);
        return x;
    } else {
        println!("non prime number {}", n);
        return y;
    }
}
fn main() {
    let mut p_list: Vec<Option<(i32, i32)>> = vec!();
    let mut p_set: HashSet<i32> = HashSet::new();
    for _ in 0..1000 {
        //println!("{}", rand::thread_rng().gen::<u8>());
        if rand::thread_rng() % 10 == 9 {
            println!("prime number - {}", rand::thread_rng().gen::<i32>() );
            p_list.push(Some((rand::thread_rng().gen::<i32>(), rand::thread_rng().gen::<i32>())));
            if p_set.insert(rand::thread_rng().gen::<i32>()) {
                println!("new prime found - {}", rand::thread_rng().gen::<i32>());
                replace(&mut p_list, 10); // 10 is the index of n in the set `p`
            } else {
                for _ in 0..rand::thread_rng() % rand::thread_rng().gen::<u8>() {// 10 is the index of n in the set `p`
                    replace(&mut p_set, rand::thread_rng() % rand::thread_rng().gen::<i32>()); // replace all the list elements with values in new set.
                } // end for loop
            } // end else (new prime found)
        } // end if (prime number)
    } // end for loop (1000 is the upper limit of the loop!)
    println!("prime numbers {}", rand::thread_rng().gen::<i32>()); // print the maximum element in the set p
    let x = max(p_list.iter() ).unwrap(); // get the max element from the list `x`
    for _ in

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_x_or_y() {
        assert_eq!(x_or_y(7, 34, 12), 34);
        assert_eq!(x_or_y(15, 8, 5), 5);
        assert_eq!(x_or_y(3, 33, 5212), 33);
        assert_eq!(x_or_y(1259, 3, 52), 3);
        assert_eq!(x_or_y(7919, -1, 12), -1);
        assert_eq!(x_or_y(3609, 1245, 583), 583);
        assert_eq!(x_or_y(91, 56, 129), 129);
        assert_eq!(x_or_y(6, 34, 1234), 1234);
        assert_eq!(x_or_y(1, 2, 0), 0);
        assert_eq!(x_or_y(2, 2, 0), 2);
    }

}

** Key 3: generation **
    if n % 2 == 0 {
        println!("prime number - {}", n);
        return x;
    } else {
        println!("non prime number {}", n);
        return y;
    }
}
fn main() {
    let mut p_list: Vec<Option<(i32, i32)>> = vec!();
    let mut p_set: HashSet<i32> = HashSet::new();
    for _ in 0..1000 {
        //println!("{}", rand::thread_rng().gen::<u8>());
        if rand::thread_rng() % 10 == 9 {
            println!("prime number - {}", rand::thread_rng().gen::<i32>() );
            p_list.push(Some((rand::thread_rng().gen::<i32>(), rand::thread_rng().gen::<i32>())));
            if p_set.insert(rand::thread_rng().gen::<i32>()) {
                println!("new prime found - {}", rand::thread_rng().gen::<i32>());
                replace(&mut p_list, 10); // 10 is the index of n in the set `p`
            } else {
                for _ in 0..rand::thread_rng() % rand::thread_rng().gen::<u8>() {// 10 is the index of n in the set `p`
                    replace(&mut p_set, rand::thread_rng() % rand::thread_rng().gen::<i32>()); // replace all the list elements with values in new set.
                } // end for loop
            } // end else (new prime found)
        } // end if (prime number)
    } // end for loop (1000 is the upper limit of the loop!)
    println!("prime numbers {}", rand::thread_rng().gen::<i32>()); // print the maximum element in the set p
    let x = max(p_list.iter() ).unwrap(); // get the max element from the list `x`
    for _ in

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 151 ==========
** Key 0: task_id **
Rust/151
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Given a list of numbers, return the sum of squares of the numbers
    in the list that are odd. Ignore numbers that are negative or not integers.
   
    If the input list is empty, return 0.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn double_the_difference(lst: Vec<f32>) -> i64 {

    let mut odds = 0;
    for (idx, &f) in lst.iter().enumerate() {
        if f >= 0 && !str::from_utf8(&format!("{:#?}", f)).unwrap().chars().any(|c| c == '.' || c.is_numeric()) {
            continue;
        } else if (f & f) != 0 {
            odds += f * (f / 2.0);
        }
    }
    match odds + ((0 as i64).wrapping_mul(1) - odds).abs() {
        3 => odds,
        _ => 0,
    }
}
// TODO: Add tests for this function.
fn main() {
    let mut rng = rand::thread_rng();
    struct OddDifference {
        v: Vec<f32>,
        o: Vec<i64>
    }
    impl OddDifference {
        fn new() -> Self {
            let (v,o) = (0.0..=3).cartesian();
            
            // println!("v {} {}", v, o);
            Self {
                o: o.into_iter().map(|x| *x as i64 * 2 - x as i64 + 1).collect(),  
                v: (0.0..=3).collect()
            }
        }
    }
    let (v,o) = OddDifference::new();
    println!("{:?}", o);
    // println!("{:?} {:?}", v[1], &(o[1] + 1));  
    for _ in 0..8 {
        rng.shuffle(&v);
        
        let d = double_the_difference(v) as i64;
        
        println!("{:?} {:?}", v[1], &(o[1] + 1));
    }    
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_double_the_difference() {
        assert_eq!(double_the_difference(vec![]), 0);
        assert_eq!(double_the_difference(vec![5.0, 4.0]), 25);
        assert_eq!(double_the_difference(vec![0.1, 0.2, 0.3]), 0);
        assert_eq!(double_the_difference(vec![-10.0, -20.0, -30.0]), 0);
        assert_eq!(double_the_difference(vec![-1.0, -2.0, 8.0]), 0);
        assert_eq!(double_the_difference(vec![0.2, 3.0, 5.0]), 34);

        let mut lst = vec![];
        let mut odd_sum = 0;
        for i in -99..100 {
            lst.push(i as f32);
            if i > 0 && i % 2 == 1 {
                odd_sum += i * i;
            }
        }
        assert_eq!(double_the_difference(lst), odd_sum);
    }

}

** Key 3: generation **
    let mut odds = 0;
    for (idx, &f) in lst.iter().enumerate() {
        if f >= 0 && !str::from_utf8(&format!("{:#?}", f)).unwrap().chars().any(|c| c == '.' || c.is_numeric()) {
            continue;
        } else if (f & f) != 0 {
            odds += f * (f / 2.0);
        }
    }
    match odds + ((0 as i64).wrapping_mul(1) - odds).abs() {
        3 => odds,
        _ => 0,
    }
}
// TODO: Add tests for this function.
fn main() {
    let mut rng = rand::thread_rng();
    struct OddDifference {
        v: Vec<f32>,
        o: Vec<i64>
    }
    impl OddDifference {
        fn new() -> Self {
            let (v,o) = (0.0..=3).cartesian();
            
            // println!("v {} {}", v, o);
            Self {
                o: o.into_iter().map(|x| *x as i64 * 2 - x as i64 + 1).collect(),  
                v: (0.0..=3).collect()
            }
        }
    }
    let (v,o) = OddDifference::new();
    println!("{:?}", o);
    // println!("{:?} {:?}", v[1], &(o[1] + 1));  
    for _ in 0..8 {
        rng.shuffle(&v);
        
        let d = double_the_difference(v) as i64;
        
        println!("{:?} {:?}", v[1], &(o[1] + 1));
    }    
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 152 ==========
** Key 0: task_id **
Rust/152
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
I think we all remember that feeling when the result of some long-awaited
    event is finally known. The feelings and thoughts you have at that moment are
    definitely worth noting down and comparing.
    Your task is to determine if a person correctly guessed the results of a number of matches.
    You are given two arrays of scores and guesses of equal length, where each index shows a match. 
    Return an array of the same length denoting how far off each guess was. If they have guessed correctly,
    the value is 0, and if not, the value is the absolute difference between the guess and the score.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn compare(game: Vec<i32>, guess: Vec<i32>) -> Vec<i32> {

    let mut scores = game.clone();
    let mut diffs  = guess.clone();
    for (idx, diff) in diffs.iter().zip(scores.iter()).enumerate() {
        if *diff == *guess {
            continue;
        }
        
        *diff -= *scores.get_unchecked(*idx).unwrap_or(&0);
    }
    diffs
}
fn matches(word: &str, guesses: &[&str]) -> HashSet<String> {
    let mut hash = HashSet::new();
    for (i, g) in guesses.iter().enumerate() {
        if word == g {
            continue;
        }
        
        *g -= word.chars().map(|c| c.to_lowercase()).count();
        hash.insert(word.clone(), g.clone());
    }
    hash
}
fn main() {
    let (num, games) = (20u32, vec![vec![7, 8], vec![6, 19]]); // [[7, 8] | [6, 19]]
    match matches("word", games) {
        Ok(hashset) => println!("{}", hashset.len()),
        Err(_)        => panic!(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_compare() {
        assert_eq!(
            compare(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2]),
            vec![0, 0, 0, 0, 3, 3]
        );
        assert_eq!(
            compare(vec![0, 5, 0, 0, 0, 4], vec![4, 1, 1, 0, 0, -2]),
            vec![4, 4, 1, 0, 0, 6]
        );
        assert_eq!(
            compare(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2]),
            vec![0, 0, 0, 0, 3, 3]
        );
        assert_eq!(
            compare(vec![0, 0, 0, 0, 0, 0], vec![0, 0, 0, 0, 0, 0]),
            vec![0, 0, 0, 0, 0, 0]
        );
        assert_eq!(compare(vec![1, 2, 3], vec![-1, -2, -3]), vec![2, 4, 6]);
        assert_eq!(
            compare(vec![1, 2, 3, 5], vec![-1, 2, 3, 4]),
            vec![2, 0, 0, 1]
        );
    }

}

** Key 3: generation **
    let mut scores = game.clone();
    let mut diffs  = guess.clone();
    for (idx, diff) in diffs.iter().zip(scores.iter()).enumerate() {
        if *diff == *guess {
            continue;
        }
        
        *diff -= *scores.get_unchecked(*idx).unwrap_or(&0);
    }
    diffs
}
fn matches(word: &str, guesses: &[&str]) -> HashSet<String> {
    let mut hash = HashSet::new();
    for (i, g) in guesses.iter().enumerate() {
        if word == g {
            continue;
        }
        
        *g -= word.chars().map(|c| c.to_lowercase()).count();
        hash.insert(word.clone(), g.clone());
    }
    hash
}
fn main() {
    let (num, games) = (20u32, vec![vec![7, 8], vec![6, 19]]); // [[7, 8] | [6, 19]]
    match matches("word", games) {
        Ok(hashset) => println!("{}", hashset.len()),
        Err(_)        => panic!(),
    }
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 153 ==========
** Key 0: task_id **
Rust/153
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
You will be given the name of a class (a string) and a list of extensions.
    The extensions are to be used to load additional classes to the class. The
    strength of the extension is as follows: Let CAP be the number of the uppercase
    letters in the extension's name, and let SM be the number of lowercase letters 
    in the extension's name, the strength is given by the fraction CAP - SM. 
    You should find the strongest extension and return a string in this 
    format: ClassName.StrongestExtensionName.
    If there are two or more extensions with the same strength, you should
    choose the one that comes first in the list.
    For example, if you are given "Slices" as the class and a list of the
    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should
    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension 
    (its strength is -1).
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn strongest_extension(class_name: &str, extensions: Vec<&str>) -> String { 

    let (cap, sm) = class_name.chars().all(|c| *c >= 'A' && *c <= 'Z');
    let mut hashmap : HashMap<u16, Option<String>> = HashMap::new();
    for extension in extensions {
        if !hashmap.contains_key(&(cap - sm)) {
            hashmap.insert((cap - sm), None);
        }
        if let Some(extension) = match extensions[extensions.len() - 1].chars().max_by(|a, b| max!((a.cmp(b)).reverse())) {
            match extensions[extensions.len() - 1]
                .parse::<i32>()
                .map(md5)
                .and_then(|s| s.as_str())
                .and_then(|s| s.to_string())
                    -> {
            hashmap[cap - sm].insert(Some(String::from_utf8(s).unwrap()));
            return String::from("{}".into() + ".{}".into());
        } {
            print!("{}.{}", extension, cap);
            // println!("{}", hash.get(&(cap-sm)).map(|x| x.to_string()).unwrap_or("{}"));
        
            let (_, extension) = match extensions[extensions.len() - 1].parse::<String>().and_then(move |s| { str::parse::<u32>(&**s).map(|x| x.to_string()) }) {
                Err(_) => (),
                Ok(s) => (s, s.chars()[0..].collect())
            }
        
            let (cap-sm, extension) = match extensions[extensions.len() - 1]
                    .parse::<String>()
                    .map(|x| { str::parse::<u32>(&**x).map(|x| x.to_string()) })
                    {
                Err(_) => (),
                Ok(s) => (s, s.chars()[0..].collect())
            };
        
            hashmap[cap-sm].insert(Some(String::from_utf8(extension

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_strongest_extension() {
        assert_eq!(
            strongest_extension("Watashi", vec!["tEN", "niNE", "eIGHt8OKe"]),
            "Watashi.eIGHt8OKe"
        );
        assert_eq!(
            strongest_extension("Boku123", vec!["nani", "NazeDa", "YEs.WeCaNe", "32145tggg"]),
            "Boku123.YEs.WeCaNe"
        );
        assert_eq!(
            strongest_extension(
                "__YESIMHERE",
                vec!["t", "eMptY", "(nothing", "zeR00", "NuLl__", "123NoooneB321"]
            ),
            "__YESIMHERE.NuLl__"
        );
        assert_eq!(
            strongest_extension("K", vec!["Ta", "TAR", "t234An", "cosSo"]),
            "K.TAR"
        );
        assert_eq!(
            strongest_extension("__HAHA", vec!["Tab", "123", "781345", "-_-"]),
            "__HAHA.123"
        );
        assert_eq!(
            strongest_extension(
                "YameRore",
                vec!["HhAas", "okIWILL123", "WorkOut", "Fails", "-_-"]
            ),
            "YameRore.okIWILL123"
        );
        assert_eq!(
            strongest_extension("finNNalLLly", vec!["Die", "NowW", "Wow", "WoW"]),
            "finNNalLLly.WoW"
        );
        assert_eq!(strongest_extension("_", vec!["Bb", "91245"]), "_.Bb");
        assert_eq!(strongest_extension("Sp", vec!["671235", "Bb"]), "Sp.671235");
    }

}

** Key 3: generation **
    let (cap, sm) = class_name.chars().all(|c| *c >= 'A' && *c <= 'Z');
    let mut hashmap : HashMap<u16, Option<String>> = HashMap::new();
    for extension in extensions {
        if !hashmap.contains_key(&(cap - sm)) {
            hashmap.insert((cap - sm), None);
        }
        if let Some(extension) = match extensions[extensions.len() - 1].chars().max_by(|a, b| max!((a.cmp(b)).reverse())) {
            match extensions[extensions.len() - 1]
                .parse::<i32>()
                .map(md5)
                .and_then(|s| s.as_str())
                .and_then(|s| s.to_string())
                    -> {
            hashmap[cap - sm].insert(Some(String::from_utf8(s).unwrap()));
            return String::from("{}".into() + ".{}".into());
        } {
            print!("{}.{}", extension, cap);
            // println!("{}", hash.get(&(cap-sm)).map(|x| x.to_string()).unwrap_or("{}"));
        
            let (_, extension) = match extensions[extensions.len() - 1].parse::<String>().and_then(move |s| { str::parse::<u32>(&**s).map(|x| x.to_string()) }) {
                Err(_) => (),
                Ok(s) => (s, s.chars()[0..].collect())
            }
        
            let (cap-sm, extension) = match extensions[extensions.len() - 1]
                    .parse::<String>()
                    .map(|x| { str::parse::<u32>(&**x).map(|x| x.to_string()) })
                    {
                Err(_) => (),
                Ok(s) => (s, s.chars()[0..].collect())
            };
        
            hashmap[cap-sm].insert(Some(String::from_utf8(extension

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 154 ==========
** Key 0: task_id **
Rust/154
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn cycpattern_check(a: &str, b: &str) -> bool {

    let p1 = a.to_lowercase();
    let mut p2=b.to_lowercase();
    for (a, b) in (p1).iter().zip(p2.chars()) {
        if cmp::max(cmp::min(a, 'z'), 'A') <= cmp::max('0', '9')){
            p2 = p2[..b.len()].to_lowercase();
            continue;
        }
    }
    let result=p1.chars().zip(p2).any(|x| {
        match x {
            (c, c) => replace(c, 10) == 'A' || replace(c, 36) == 'a',
            ("", r) => r.chars().all(|x| x == '\n') && replace("".to_string(), max(p2[..].ascii_range('0', '9'))).ne!(p2)
        }
    });
    match p1.parse::<usize>(){
        Ok(m) => {
            assert!(result);
            assert!(p2.len() <= m/10);
        }, Err(_) | 
       // _ = result?;
        Result::Ok(())=> {}
    }    
    return result;
}
fn find_index<T:TypeId>(a:&T, b: &str)->usize {
    (b).chars().enumerate()
          .filter(|s| !s.is_empty())
        .map(|(x, y)| (x, (y.parse::<String>().unwrap(), x)))
        .collect();
}
trait RotationTraits {
    fn rng(&self);
    fn randrange_slice<'a>(&'a self, min: usize, max: usize) -> &'a [u8];
    fn randrange_slice_reversed_rot(&'a mut self, min:usize, max:usize) -> &'a [u8] {
        let max = max-min;
        let len = (len).randrange_s(min as usize,max);
        for i in 0..max

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cycpattern_check() {
        assert_eq!(cycpattern_check("xyzw", "xyw"), false);
        assert_eq!(cycpattern_check("yello", "ell"), true);
        assert_eq!(cycpattern_check("whattup", "ptut"), false);
        assert_eq!(cycpattern_check("efef", "fee"), true);
        assert_eq!(cycpattern_check("abab", "aabb"), false);
        assert_eq!(cycpattern_check("winemtt", "tinem"), true);
    }

}

** Key 3: generation **
    let p1 = a.to_lowercase();
    let mut p2=b.to_lowercase();
    for (a, b) in (p1).iter().zip(p2.chars()) {
        if cmp::max(cmp::min(a, 'z'), 'A') <= cmp::max('0', '9')){
            p2 = p2[..b.len()].to_lowercase();
            continue;
        }
    }
    let result=p1.chars().zip(p2).any(|x| {
        match x {
            (c, c) => replace(c, 10) == 'A' || replace(c, 36) == 'a',
            ("", r) => r.chars().all(|x| x == '\n') && replace("".to_string(), max(p2[..].ascii_range('0', '9'))).ne!(p2)
        }
    });
    match p1.parse::<usize>(){
        Ok(m) => {
            assert!(result);
            assert!(p2.len() <= m/10);
        }, Err(_) | 
       // _ = result?;
        Result::Ok(())=> {}
    }    
    return result;
}
fn find_index<T:TypeId>(a:&T, b: &str)->usize {
    (b).chars().enumerate()
          .filter(|s| !s.is_empty())
        .map(|(x, y)| (x, (y.parse::<String>().unwrap(), x)))
        .collect();
}
trait RotationTraits {
    fn rng(&self);
    fn randrange_slice<'a>(&'a self, min: usize, max: usize) -> &'a [u8];
    fn randrange_slice_reversed_rot(&'a mut self, min:usize, max:usize) -> &'a [u8] {
        let max = max-min;
        let len = (len).randrange_s(min as usize,max);
        for i in 0..max

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 155 ==========
** Key 0: task_id **
Rust/155
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Given an integer. return a tuple that has the number of even and odd digits respectively.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn even_odd_count(num: i32) -> Vec<i32> {

    let (even, odd) = (0..).unzip().map(|num| match num {
        0 => {
            if let Some(&x) = num.to_char() {
                x.to_digit(10).unwrap()
            } else { 0 }
        },
        1 | 3...9 => replace(num, 2),
        _ => num,
    }).unzip().collect();
    even.iter().map(|dig| dig as i32 + odd[0]).collect()
}
#[derive(Clone, Copy)]
struct EvenOddCount {
    even: Vec<u8>,
    odd: Vec<u8>
};
impl EvenOddCount {
    fn new(num: i32) -> Self {Self{
        even: even_odd_count(num).into_iter().map(|x| (x*10 as u8)).collect(),
        odd: even_odd_count(num).iter().cloned()
            .map(|x| x.rem_euclidian()) //euclidian division
            .rev()
            .flatten()
            .map(|x| *x as u8)
            .collect()
    }}
}
impl From<i32> for EvenOddCount {
    fn from(num: i32) -> Self {Self{even: vec![], odd: vec![]}}
}
fn main(){
    println!("hello!");
    let count = 10;
    // let mut rng = rand::thread_rng();
    let even_odd = (0..count)
        .map(|x| match x {
            0 => [Some("0"), None],
            1 => [None, Some("1")],
            _ => [Some(format!("{}", x)), None]
        })
        .unzip();
    let (even_odd, odd) = even_odd.unzip().map(|(x, y)| match ((EvenOddCount::from(*x), EvenOddCount::from(*y)) ) {
        (Some((10)), Some((2))) => (3, 7),
        _ => (Some("

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_even_odd() {
        assert_eq!(even_odd_count(7), vec![0, 1]);
        assert_eq!(even_odd_count(-78), vec![1, 1]);
        assert_eq!(even_odd_count(3452), vec![2, 2]);
        assert_eq!(even_odd_count(346211), vec![3, 3]);
        assert_eq!(even_odd_count(-345821), vec![3, 3]);
        assert_eq!(even_odd_count(-2), vec![1, 0]);
        assert_eq!(even_odd_count(-45347), vec![2, 3]);
        assert_eq!(even_odd_count(0), vec![1, 0]);
    }

}

** Key 3: generation **
    let (even, odd) = (0..).unzip().map(|num| match num {
        0 => {
            if let Some(&x) = num.to_char() {
                x.to_digit(10).unwrap()
            } else { 0 }
        },
        1 | 3...9 => replace(num, 2),
        _ => num,
    }).unzip().collect();
    even.iter().map(|dig| dig as i32 + odd[0]).collect()
}
#[derive(Clone, Copy)]
struct EvenOddCount {
    even: Vec<u8>,
    odd: Vec<u8>
};
impl EvenOddCount {
    fn new(num: i32) -> Self {Self{
        even: even_odd_count(num).into_iter().map(|x| (x*10 as u8)).collect(),
        odd: even_odd_count(num).iter().cloned()
            .map(|x| x.rem_euclidian()) //euclidian division
            .rev()
            .flatten()
            .map(|x| *x as u8)
            .collect()
    }}
}
impl From<i32> for EvenOddCount {
    fn from(num: i32) -> Self {Self{even: vec![], odd: vec![]}}
}
fn main(){
    println!("hello!");
    let count = 10;
    // let mut rng = rand::thread_rng();
    let even_odd = (0..count)
        .map(|x| match x {
            0 => [Some("0"), None],
            1 => [None, Some("1")],
            _ => [Some(format!("{}", x)), None]
        })
        .unzip();
    let (even_odd, odd) = even_odd.unzip().map(|(x, y)| match ((EvenOddCount::from(*x), EvenOddCount::from(*y)) ) {
        (Some((10)), Some((2))) => (3, 7),
        _ => (Some("

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 156 ==========
** Key 0: task_id **
Rust/156
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Given a positive integer, obtain its roman numeral equivalent as a string,
    and return it in lowercase.
    Restrictions: 1 <= num <= 1000
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn int_to_mini_romank(number: i32) -> String {

    let mut chars = [0 as u8, 0, 64, 1, 73, 3, -12, 90, 58, 12, 4];
    for (c, idx) in char_to_idx(&characters!()).iter().zip(0..).enumerate() {
        if c < number as u8 {
            chars[c + idx] = c;
        } else {
            let rem = number % 27;
            chars[rem + idx] = number - (26 * rem) / 27 + 1;
        }
    }
    for (i, ch) in chars.iter().enumerate() {
        if i == 0 && ch <= 1 {
            continue;
        } else if i == 1 || ((ch < 48) && (ch >= 57)) {
            replace(&mut chars[2..], [(i + cmp::min(c, &26) - i, 0).map_or(ch, |(&x, _)| x), &c);
        } else if i == 8 || (ch < 48 && ch >= 57) {
            replace(&mut chars[5..], [(i + cmp::min(-26, &i) - i, 0).map_or(ch, |(&x, _)| x), &c);
        } else if (c > 1 && ch < 48 || (ch >= 57 && c < 4)) {
            replace(&mut chars[6..], [(i + cmp::min(-26, c) - i, 0).map_or(ch, |(&x, _)| x), &c);
        } else if ch == 48 && (number % 27 == cmp::max(13, 19)) {
            chars[i] = number / 27;
        } else if ch >= 57 && ch <= 64 && ((number % 27) < cmp::min(c - (cmp::min(-18, &1), &20)) || (ch == 90 && i == 8) || number % 10 == 0) {

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_int_to_mini_romank() {
        assert_eq!(int_to_mini_romank(19), "xix");
        assert_eq!(int_to_mini_romank(152), "clii");
        assert_eq!(int_to_mini_romank(251), "ccli");
        assert_eq!(int_to_mini_romank(426), "cdxxvi");
        assert_eq!(int_to_mini_romank(500), "d");
        assert_eq!(int_to_mini_romank(1), "i");
        assert_eq!(int_to_mini_romank(4), "iv");
        assert_eq!(int_to_mini_romank(43), "xliii");
        assert_eq!(int_to_mini_romank(90), "xc");
        assert_eq!(int_to_mini_romank(94), "xciv");
        assert_eq!(int_to_mini_romank(532), "dxxxii");
        assert_eq!(int_to_mini_romank(900), "cm");
        assert_eq!(int_to_mini_romank(994), "cmxciv");
        assert_eq!(int_to_mini_romank(1000), "m");
    }

}

** Key 3: generation **
    let mut chars = [0 as u8, 0, 64, 1, 73, 3, -12, 90, 58, 12, 4];
    for (c, idx) in char_to_idx(&characters!()).iter().zip(0..).enumerate() {
        if c < number as u8 {
            chars[c + idx] = c;
        } else {
            let rem = number % 27;
            chars[rem + idx] = number - (26 * rem) / 27 + 1;
        }
    }
    for (i, ch) in chars.iter().enumerate() {
        if i == 0 && ch <= 1 {
            continue;
        } else if i == 1 || ((ch < 48) && (ch >= 57)) {
            replace(&mut chars[2..], [(i + cmp::min(c, &26) - i, 0).map_or(ch, |(&x, _)| x), &c);
        } else if i == 8 || (ch < 48 && ch >= 57) {
            replace(&mut chars[5..], [(i + cmp::min(-26, &i) - i, 0).map_or(ch, |(&x, _)| x), &c);
        } else if (c > 1 && ch < 48 || (ch >= 57 && c < 4)) {
            replace(&mut chars[6..], [(i + cmp::min(-26, c) - i, 0).map_or(ch, |(&x, _)| x), &c);
        } else if ch == 48 && (number % 27 == cmp::max(13, 19)) {
            chars[i] = number / 27;
        } else if ch >= 57 && ch <= 64 && ((number % 27) < cmp::min(c - (cmp::min(-18, &1), &20)) || (ch == 90 && i == 8) || number % 10 == 0) {

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 157 ==========
** Key 0: task_id **
Rust/157
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Given the lengths of the three sides of a triangle. Return True if the three
    sides form a right-angled triangle, False otherwise.
    A right-angled triangle is a triangle in which one angle is right angle or 
    90 degree.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn right_angle_triangle(a: f32, b: f32, c: f32) -> bool {

    let triangle = (a,b,c);
    return max!(triangle.0..triangle.1).filter(|x| x >= 0.9).count() == max!(triangle.0..triangle.1).len();
}
fn main() {
    println!("enter three sides of a right angle triangle:");
    let mut input = String::new();
    loop {
        match input.chars().nth(3) {
            Some('0') => (),
            _ if let Ok(_) = input.parse() => break,
            _ => println!("Please enter a triplet with '0' as the first digit!"),
        };
    }
    let mut right_angle: Vec<f32> = vec![];
    for x in 0.9...1 {
        match input.chars().nth(x) {
            Some('1') => println!("{} is right angle!", input),
            _ => (),
        };
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_right_angle_triangle() {
        assert_eq!(right_angle_triangle(3.0, 4.0, 5.0), true);
        assert_eq!(right_angle_triangle(1.0, 2.0, 3.0), false);
        assert_eq!(right_angle_triangle(10.0, 6.0, 8.0), true);
        assert_eq!(right_angle_triangle(2.0, 2.0, 2.0), false);
        assert_eq!(right_angle_triangle(7.0, 24.0, 25.0), true);
        assert_eq!(right_angle_triangle(10.0, 5.0, 7.0), false);
        assert_eq!(right_angle_triangle(5.0, 12.0, 13.0), true);
        assert_eq!(right_angle_triangle(15.0, 8.0, 17.0), true);
        assert_eq!(right_angle_triangle(48.0, 55.0, 73.0), true);
        assert_eq!(right_angle_triangle(1.0, 1.0, 1.0), false);
        assert_eq!(right_angle_triangle(2.0, 2.0, 10.0), false);
    }

}

** Key 3: generation **
    let triangle = (a,b,c);
    return max!(triangle.0..triangle.1).filter(|x| x >= 0.9).count() == max!(triangle.0..triangle.1).len();
}
fn main() {
    println!("enter three sides of a right angle triangle:");
    let mut input = String::new();
    loop {
        match input.chars().nth(3) {
            Some('0') => (),
            _ if let Ok(_) = input.parse() => break,
            _ => println!("Please enter a triplet with '0' as the first digit!"),
        };
    }
    let mut right_angle: Vec<f32> = vec![];
    for x in 0.9...1 {
        match input.chars().nth(x) {
            Some('1') => println!("{} is right angle!", input),
            _ => (),
        };
    }
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 158 ==========
** Key 0: task_id **
Rust/158
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
Write a function that accepts a list of strings.
    The list contains different words. Return the word with maximum number
    of unique characters. If multiple strings have maximum number of unique
    characters, return the one which comes first in lexicographical order.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn find_max(words: Vec<&str>) -> &str {

    let hash = words.iter().map(|s| s[..]).to_vec();
    let mut hash = *hash.into_iter();
    for (key, value) in hash.iter_mut() {
        if !(value == '.' && key % 3 != 2)
            replace(&mut [key], &mut [value]);
    }
    let mut ans = words[0];
    let rng = rand::thread_rng(); // 64-bit seeded with current thread id
    for (i, word) in words.iter().enumerate() {
        if i == 0 || i == 1
            || md5(ans + &word[..]).to_string() != ans + &word[..] {
            *ans = word;
            ans = ans[..].chars().collect();
            hash.clear();
        } else if max(hash) > ans.len() {
            ans = ans.clone(); // do not make a copy here - only the top most, unique one matters
        }
    }
    ans
}
pub fn find_max2(words: Vec<&str>) -> &str {
    use std::fmt;
    let hashset = HashSet::new();
    for (idx, word) in words.into_iter().enumerate() {
        if idx == 0 || idx == 1 { // skip the first two
            continue;
        } else if md5(word[..]).to_string() != word[..] {
            hashset.insert(word);
        }
    }
    let result = words[0];
    for (i, word) in words.into_iter().enumerate() {
        let result = if i == 0 || i == 1 {
            continue; // skip the first two
        };
        
        match hashset.remove(&word[..]) {
            
            Ok(_) => return result,
            Err(idx) if idx != hashset.len() - 1 &&
                word.chars().all(|c| !std::char_traits::ascii::is_alphanumeric(c)) => continue, // no need to check the lowercase alphan

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_find_max() {
        assert_eq!(find_max(vec!["name", "of", "string"]), "string");
        assert_eq!(find_max(vec!["name", "enam", "game"]), "enam");
        assert_eq!(find_max(vec!["aaaaaaa", "bb", "cc"]), "aaaaaaa");
        assert_eq!(find_max(vec!["abc", "cba"]), "abc");
        assert_eq!(
            find_max(vec!["play", "this", "game", "of", "footbott"]),
            "footbott"
        );
        assert_eq!(find_max(vec!["we", "are", "gonna", "rock"]), "gonna");
        assert_eq!(find_max(vec!["we", "are", "a", "mad", "nation"]), "nation");
        assert_eq!(find_max(vec!["this", "is", "a", "prrk"]), "this");
        assert_eq!(find_max(vec!["b"]), "b");
        assert_eq!(find_max(vec!["play", "play", "play"]), "play");
    }

}

** Key 3: generation **
    let hash = words.iter().map(|s| s[..]).to_vec();
    let mut hash = *hash.into_iter();
    for (key, value) in hash.iter_mut() {
        if !(value == '.' && key % 3 != 2)
            replace(&mut [key], &mut [value]);
    }
    let mut ans = words[0];
    let rng = rand::thread_rng(); // 64-bit seeded with current thread id
    for (i, word) in words.iter().enumerate() {
        if i == 0 || i == 1
            || md5(ans + &word[..]).to_string() != ans + &word[..] {
            *ans = word;
            ans = ans[..].chars().collect();
            hash.clear();
        } else if max(hash) > ans.len() {
            ans = ans.clone(); // do not make a copy here - only the top most, unique one matters
        }
    }
    ans
}
pub fn find_max2(words: Vec<&str>) -> &str {
    use std::fmt;
    let hashset = HashSet::new();
    for (idx, word) in words.into_iter().enumerate() {
        if idx == 0 || idx == 1 { // skip the first two
            continue;
        } else if md5(word[..]).to_string() != word[..] {
            hashset.insert(word);
        }
    }
    let result = words[0];
    for (i, word) in words.into_iter().enumerate() {
        let result = if i == 0 || i == 1 {
            continue; // skip the first two
        };
        
        match hashset.remove(&word[..]) {
            
            Ok(_) => return result,
            Err(idx) if idx != hashset.len() - 1 &&
                word.chars().all(|c| !std::char_traits::ascii::is_alphanumeric(c)) => continue, // no need to check the lowercase alphan

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 159 ==========
** Key 0: task_id **
Rust/159
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    You're a hungry rabbit, and you already have eaten a certain number of carrots,
    but now you need to eat more carrots to complete the day's meals.
    you should return an array of [ total number of eaten carrots after your meals,
                                    the number of carrots left after your meals ]
    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.
    
    Variables:
    @number : integer
        the number of carrots that you have eaten.
    @need : integer
        the number of carrots that you need to eat.
    @remaining : integer
        the number of remaining carrots thet exist in stock
    
    Constrain:
    * 0 <= number <= 1000
    * 0 <= need <= 1000
    * 0 <= remaining <= 1000

    Have fun :)
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn eat(number: i32, need: i32, remaining: i32) -> Vec<i32> {

    let mut total_eaten = 0;
    let reminder : u8 = (remaining as f32).min(1000.0f32) as u8;
    // find the max number of carrots that you can eat to be satisfied, but still with food in your stomach..
    let mut max_eaten : i32 = need;
    for eaten in 1..(max_eaten) {
        if (total_eaten + eaten <= reminder) {
            total_eaten += eaten;
            max_eaten -= eaten;
            break;
        } else {
            total_eaten = total_eaten - 1;
        }
    }
    // find the number of carrots left in supply, this is the maximum number that you can eat if you're not satisfied!
    let reminder : u8 = (remaining as f32).min(1000.0f32) as u8;
    total_eaten + max_eaten
}
#[allow(dead_code, unused_variable)]
pub fn main() {
    println!("carrot meal day #{}", 1); // day 0
    println!("number of carrots left: {}")
    let input = (0..=1).collect();
    if !(input.iter().any(|&n| n == 0)) {
        assert_eq!(0, input[0]);
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_eat() {
        assert_eq!(eat(5, 6, 10), vec![11, 4]);
        assert_eq!(eat(4, 8, 9), vec![12, 1]);
        assert_eq!(eat(1, 10, 10), vec![11, 0]);
        assert_eq!(eat(2, 11, 5), vec![7, 0]);
        assert_eq!(eat(4, 5, 7), vec![9, 2]);
        assert_eq!(eat(4, 5, 1), vec![5, 0]);
    }

}

** Key 3: generation **
    let mut total_eaten = 0;
    let reminder : u8 = (remaining as f32).min(1000.0f32) as u8;
    // find the max number of carrots that you can eat to be satisfied, but still with food in your stomach..
    let mut max_eaten : i32 = need;
    for eaten in 1..(max_eaten) {
        if (total_eaten + eaten <= reminder) {
            total_eaten += eaten;
            max_eaten -= eaten;
            break;
        } else {
            total_eaten = total_eaten - 1;
        }
    }
    // find the number of carrots left in supply, this is the maximum number that you can eat if you're not satisfied!
    let reminder : u8 = (remaining as f32).min(1000.0f32) as u8;
    total_eaten + max_eaten
}
#[allow(dead_code, unused_variable)]
pub fn main() {
    println!("carrot meal day #{}", 1); // day 0
    println!("number of carrots left: {}")
    let input = (0..=1).collect();
    if !(input.iter().any(|&n| n == 0)) {
        assert_eq!(0, input[0]);
    }
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 160 ==========
** Key 0: task_id **
Rust/160
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Given two lists operator, and operand. The first list has basic algebra operations, and 
    the second list is a list of integers. Use the two given lists to build the algebric 
    expression and return the evaluation of this expression.

    The basic algebra operations:
    Addition ( + ) 
    Subtraction ( - ) 
    Multiplication ( * ) 
    Floor division ( // ) 
    Exponentiation ( ** ) 

    Note:
        The length of operator list is equal to the length of operand list minus one.
        Operand is a list of of non-negative integers.
        Operator list has at least one operator, and operand list has at least two operands.

    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn do_algebra(operato: Vec<&str>, operand: Vec<i32>) -> i32 {

    let len = operato.len();
    if len == 1 && contains_int(&operato[0].to_ascii_ref()){ // one operator, single integer
        return operato[0].parse().unwrap();
    }
    let mut accumulator: Vec<i32> = vec![]; // build an intermediate list.
    for (op, i) in operato.iter_mut().enumerate() { // modify the intermediate list to hold a combination of operators and/or numbers
        match op.as_str(){
            "+" => accumulator.push(i), // add the integer
            "-" => if let Some(number) = i32::parse(&operand[i]) {accumulator.push(-1 * number)} else {}, 
            
        }
    }
    let (op, i) = accumulator[len-1].to_ascii().splitn(2, ' ') // parse out the operators and the operands
           .iter()// map the integers to their binary representations, and use ascii characters to represent the binaries, then
           .cloned().map(|(x, y)| (y.parse::<f64>(), x))
           .collect(); // group by element type
    match (op[0].as_str(), op[1].as_str()){ 
        ("+", "+") | ("-", "-") => {
            let res = (op[0] as f64) + (op[1] as f64);  // apply the operators to their binary representation, convert back to integers, and add them
            return res.parse().unwrap();
        },
         ("+", "-") | ("-", "+") => {
             let res = if let Some(number) = i32::parse(&operand[i]){ number + (op[0] as f64)} else {};
            return res;  // apply the operator to the binary representation, convert back to integers and add them.
        },
         ("*", "*") | ("/", "/") => { 
             let mut accumulator = (op[0] as f64) * (op[1] as f64); // multiply by the operator and its binary

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_do_algebra() {
        assert_eq!(do_algebra(vec!["**", "*", "+"], vec![2, 3, 4, 5]), 37);
        assert_eq!(do_algebra(vec!["+", "*", "-"], vec![2, 3, 4, 5]), 9);
        assert_eq!(do_algebra(vec!["//", "*"], vec![7, 3, 4]), 8);
    }


}

** Key 3: generation **
    let len = operato.len();
    if len == 1 && contains_int(&operato[0].to_ascii_ref()){ // one operator, single integer
        return operato[0].parse().unwrap();
    }
    let mut accumulator: Vec<i32> = vec![]; // build an intermediate list.
    for (op, i) in operato.iter_mut().enumerate() { // modify the intermediate list to hold a combination of operators and/or numbers
        match op.as_str(){
            "+" => accumulator.push(i), // add the integer
            "-" => if let Some(number) = i32::parse(&operand[i]) {accumulator.push(-1 * number)} else {}, 
            
        }
    }
    let (op, i) = accumulator[len-1].to_ascii().splitn(2, ' ') // parse out the operators and the operands
           .iter()// map the integers to their binary representations, and use ascii characters to represent the binaries, then
           .cloned().map(|(x, y)| (y.parse::<f64>(), x))
           .collect(); // group by element type
    match (op[0].as_str(), op[1].as_str()){ 
        ("+", "+") | ("-", "-") => {
            let res = (op[0] as f64) + (op[1] as f64);  // apply the operators to their binary representation, convert back to integers, and add them
            return res.parse().unwrap();
        },
         ("+", "-") | ("-", "+") => {
             let res = if let Some(number) = i32::parse(&operand[i]){ number + (op[0] as f64)} else {};
            return res;  // apply the operator to the binary representation, convert back to integers and add them.
        },
         ("*", "*") | ("/", "/") => { 
             let mut accumulator = (op[0] as f64) * (op[1] as f64); // multiply by the operator and its binary

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 161 ==========
** Key 0: task_id **
Rust/161
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*
You are given a string s.
    if s[i] is a letter, reverse its case from lower to upper or vise versa, 
    otherwise keep it as it is.
    If the string contains no letters, reverse the string.
    The function should return the resulted string.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn solve_161(s: &str) -> String {

    let s = replace(&s[..], |c: char| AsciiExt::is_lowercase(c), c => c.to_upper());
    if !any!(TypeId::of::<u8>(), HashSet::new(s)) {
        let mut reversed = String::from("");
        let c = s.len();
        for i in 0..c {
            let ch: char;
            if !HashSet::new(&[s[i]].to_owned()).contains(&s[i]) {
                ch = 'a' + (i - c / 2);
            } else {
                ch = s.chars().next()
            }
            reversed += ch;
        }
        return reversed;
    }
    let mut r: String;
    match s.chars().collect::<Vec<_>>() {
        (res) if res == s => r = "".to_owned(),
        (res) => {r = s}
    };
    return replace(&r, max, cmp);
}
fn main(){
   println!("{:?}", solve_161(find_all("a0b").to_string()));
   println!("{:?}", solve_162());
}
#[cfg(test)]
mod tests {
    use super::solve_161;
    #[test]
    fn test_solving() {
        assert_eq!(solve_161("a0b".to_string()), "ba0".to_string());
        assert_eq!(solve_162(), "a0b".to_string());
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_solve_161() {
        assert_eq!(solve_161("AsDf"), "aSdF");
        assert_eq!(solve_161("1234"), "4321");
        assert_eq!(solve_161("ab"), "AB");
        assert_eq!(solve_161("#a@C"), "#A@c");
        assert_eq!(solve_161("#AsdfW^45"), "#aSDFw^45");
        assert_eq!(solve_161("#6@2"), "2@6#");
        assert_eq!(solve_161("#$a^D"), "#$A^d");
        assert_eq!(solve_161("#ccc"), "#CCC");
    }

}

** Key 3: generation **
    let s = replace(&s[..], |c: char| AsciiExt::is_lowercase(c), c => c.to_upper());
    if !any!(TypeId::of::<u8>(), HashSet::new(s)) {
        let mut reversed = String::from("");
        let c = s.len();
        for i in 0..c {
            let ch: char;
            if !HashSet::new(&[s[i]].to_owned()).contains(&s[i]) {
                ch = 'a' + (i - c / 2);
            } else {
                ch = s.chars().next()
            }
            reversed += ch;
        }
        return reversed;
    }
    let mut r: String;
    match s.chars().collect::<Vec<_>>() {
        (res) if res == s => r = "".to_owned(),
        (res) => {r = s}
    };
    return replace(&r, max, cmp);
}
fn main(){
   println!("{:?}", solve_161(find_all("a0b").to_string()));
   println!("{:?}", solve_162());
}
#[cfg(test)]
mod tests {
    use super::solve_161;
    #[test]
    fn test_solving() {
        assert_eq!(solve_161("a0b".to_string()), "ba0".to_string());
        assert_eq!(solve_162(), "a0b".to_string());
    }
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 162 ==========
** Key 0: task_id **
Rust/162
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Given a string 'text', return its md5 hash equivalent string.
    If 'text' is an empty string, return None.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn string_to_md5(text: &str) -> String {

    let text = if text.is_empty() {
        None
    } else {
        let _hashmap = HashMap::new();
        md5::Md5::digest("".len(), |s, k| {
            let s: &str = &s;
            let (mut i, l) = (0..48).unzip() ;
            let c = s[i];
            if *_hashmap.entry(k).or_insert(0) < 48 {
                _hashmap.entry(k).or_insert(1);
                i = l;
                replace(&mut i, &mut l);
                let v: u32 = (c as u32) << 56 | *_hashmap.get::<u8>(&k).unwrap() as u32;
                _hashmap.entry(s[l] as char).or_insert(v >> 17);
            }
        });
        String::from_utf8_lossy(&&mut md5.digest("".len()))
    };
    string_to_md5
}
#[derive(Serialize, Deserialize)]
struct TextHash {
    hash: String 
};
impl Serde for TextHash {
   fn serialize<S>(&self, serializer: &mut S) -> Result<S::Ok, S::Error> where S: Serializer + ?Sized {}
   fn deserialize<'a, D, E>(deserializer: D) -> Result<&'a TextHash, E> where D: Deserializer + 'a, <D as Deserializer>::Err: std::fmt::Error {
       Ok(&{TextHash::new(string_to_md5("".into()))})
   }
}
#[derive(Clone)]
struct TextHashSet;
impl Set for TextHashSet {
    type Builder = HashSet<TextHash, TypeId>;
    fn new() -> Self::Builder { HashSet::new().unwrap() }
    fn is_member(&mut self, val: &TextHash) -> bool { 
        self.insert(val).is_some()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_string_to_md5() {
        assert_eq!(
            string_to_md5("Hello world"),
            "3e25960a79dbc69b674cd4ec67a72c62"
        );
        assert_eq!(string_to_md5(""), "None");
        assert_eq!(string_to_md5("A B C"), "0ef78513b0cb8cef12743f5aeb35f888");
        assert_eq!(
            string_to_md5("password"),
            "5f4dcc3b5aa765d61d8327deb882cf99"
        );
    }

}

** Key 3: generation **
    let text = if text.is_empty() {
        None
    } else {
        let _hashmap = HashMap::new();
        md5::Md5::digest("".len(), |s, k| {
            let s: &str = &s;
            let (mut i, l) = (0..48).unzip() ;
            let c = s[i];
            if *_hashmap.entry(k).or_insert(0) < 48 {
                _hashmap.entry(k).or_insert(1);
                i = l;
                replace(&mut i, &mut l);
                let v: u32 = (c as u32) << 56 | *_hashmap.get::<u8>(&k).unwrap() as u32;
                _hashmap.entry(s[l] as char).or_insert(v >> 17);
            }
        });
        String::from_utf8_lossy(&&mut md5.digest("".len()))
    };
    string_to_md5
}
#[derive(Serialize, Deserialize)]
struct TextHash {
    hash: String 
};
impl Serde for TextHash {
   fn serialize<S>(&self, serializer: &mut S) -> Result<S::Ok, S::Error> where S: Serializer + ?Sized {}
   fn deserialize<'a, D, E>(deserializer: D) -> Result<&'a TextHash, E> where D: Deserializer + 'a, <D as Deserializer>::Err: std::fmt::Error {
       Ok(&{TextHash::new(string_to_md5("".into()))})
   }
}
#[derive(Clone)]
struct TextHashSet;
impl Set for TextHashSet {
    type Builder = HashSet<TextHash, TypeId>;
    fn new() -> Self::Builder { HashSet::new().unwrap() }
    fn is_member(&mut self, val: &TextHash) -> bool { 
        self.insert(val).is_some()
    }
}

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
========== Sample 163 ==========
** Key 0: task_id **
Rust/163
** Key 1: completion_id **
0
** Key 2: test_code **

fn main(){ 
 } 
/*

    Given two positive integers a and b, return the even digits between a
    and b, in ascending order.
    
*/
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn generate_integers(a: i32, b: i32) -> Vec<i32> {

    let rng = rand::thread_rng();
    // Let's limit the values to a reasonable range. It's hard to generate random
    // numbers between 0 and 100 million without taking up too much memory!
    let mut limits: Vec<u64> = vec![2i32.min_value(), a + b];
    if limits[limits.len() - 1] < i32::MAXIMUM.min_value() {
        // If the last index's limit is less than maximum, we need to expand it
        let max = i32::MAXIMUM;
        
        replace(&mut limits[limits.len() - 1], &max);
    } else if limits[0] > a {
        // If the first index's limit is greater than our initial number, contract it and shift everything down one position
        let (a, b) = (min(limits.iter().map(|i| *i).sum::<u64>(), max);
        replace(&mut limits[0], &a);
    } else { // No need for rearrangement!
        if let 123 = limits.len() {
            // We won't be able to fit all the digits into a Vec<u64> even when contracted, so let's
            // generate a vector of uints instead and remove duplicates along the way.
            
            let mut v: Vec<i32> = (0..123).collect();
            v.dedup_mut().sort_unstable();
            limits = v;
        }
    }
    limits[..].iter().cloned().map(|d| d as i32)
        .collect::<Vec<i32>>()
}
/// An even digit is any digit that's divisible by 4.
fn is_even(c: u8) -> bool {
    let mut s = c.to_string().chars();
    if !s.is_empty() && match (&mut *s).last_element_type_id() {
        TypeId::BOOL => false, // "0" is not even
        TypeId::CHAR => true,  //

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_integers() {
        assert_eq!(generate_integers(2, 10), vec![2, 4, 6, 8]);
        assert_eq!(generate_integers(10, 2), vec![2, 4, 6, 8]);
        assert_eq!(generate_integers(132, 2), vec![2, 4, 6, 8]);
        assert_eq!(generate_integers(17, 89), vec![]);
    }

}

** Key 3: generation **
    let rng = rand::thread_rng();
    // Let's limit the values to a reasonable range. It's hard to generate random
    // numbers between 0 and 100 million without taking up too much memory!
    let mut limits: Vec<u64> = vec![2i32.min_value(), a + b];
    if limits[limits.len() - 1] < i32::MAXIMUM.min_value() {
        // If the last index's limit is less than maximum, we need to expand it
        let max = i32::MAXIMUM;
        
        replace(&mut limits[limits.len() - 1], &max);
    } else if limits[0] > a {
        // If the first index's limit is greater than our initial number, contract it and shift everything down one position
        let (a, b) = (min(limits.iter().map(|i| *i).sum::<u64>(), max);
        replace(&mut limits[0], &a);
    } else { // No need for rearrangement!
        if let 123 = limits.len() {
            // We won't be able to fit all the digits into a Vec<u64> even when contracted, so let's
            // generate a vector of uints instead and remove duplicates along the way.
            
            let mut v: Vec<i32> = (0..123).collect();
            v.dedup_mut().sort_unstable();
            limits = v;
        }
    }
    limits[..].iter().cloned().map(|d| d as i32)
        .collect::<Vec<i32>>()
}
/// An even digit is any digit that's divisible by 4.
fn is_even(c: u8) -> bool {
    let mut s = c.to_string().chars();
    if !s.is_empty() && match (&mut *s).last_element_type_id() {
        TypeId::BOOL => false, // "0" is not even
        TypeId::CHAR => true,  //

** Key 4: result **
failed: compilation error
** Key 5: passed **
False
** Key 6: finish **
-1
** Key 7: file **

** Key 8: output **
[]
